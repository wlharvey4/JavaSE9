This is JavaSE9.info, produced by makeinfo version 6.5 from
JavaSE9.texi.


File: JavaSE9.info,  Node: Top,  Next: Java SE 9 Introduction,  Up: (dir)

General Introduction
********************

This file documents Outline Covering Java SE 9.

* Menu:

* Java SE 9 Introduction::
* Classes::
* Methods and Classes::
* Inheritance::
* Packages::
* Interfaces::
* I/O::
* Generics::
* Enumerations::
* Strings::
* java Lang::
* java util Collections::
* java util Utility Classes::
* java io Input Output::
* NIO::
* Networking::
* Event Handling::
* AWT::
* AWT Controls::
* Images::
* Concurrency::
* Streams API::
* Regular Expressions::
* Swing::
* The Makefile::
* Code Chunk Summaries::
* List of Tables::
* List of General Forms::
* Bibliography::
* Concept Index::
* Function Index::

 -- The Detailed Node Listing --

Classes

* Class Fundamentals::
* Declaring Objects::
* Methods::
* Constructors::
* this Keyword::
* Stack Class::

Class Fundamentals

* General Form::

The 'this' Keyword

* Instance Variable Hiding::

TestStack.java

* Stack Instance Variables::
* Stack Constructor Node::
* Stack Instance Methods Node::
* Stack TestStack Node::

Stack Instance Methods Subsection

* Stack Push and Pop Node::

Methods and Classes

* Overloading Methods::
* Objects as Parameters::
* Argument Passing::
* Returning Objects::
* Recursion::
* Access Control::
* static Keyword::
* final Keyword::
* Arrays 2::
* Nested and Inner Classes::
* String Class::
* Command-Line Arguments::
* Varargs::

Overloading Methods

* Overloading Constructors::

Access Control and Inheritance

* Improved Stack Class::

Inheritance

* Inheritance Basics::
* Using super::
* Multilevel Hierarchy::
* Constructors Executed::
* Method Overriding::
* Dynamic Method Dispatch::
* Using Abstract Classes::
* final with Inheritance::
* Object Class::

General Form of a Subclass Inheriting a Superclass

* Member Access and Inheritance::
* Superclass Referencing Subclass::

Using 'super'

* super Calling Superclass Constructor::
* super Referencing Superclass::

Dynamic Method Dispatch

* Why Overridden Methods::
* Applying Method Overriding::

Output

* FindAreas SuperClass Figure Node::
* FindAreas SubClass Rectangle Node::
* FindAreas SubClass Triangle Node::
* FindAreas Main Class Node::

Abstract Classes Can Be Reference Variables

* Improved Figure Class::

Improved Figure Class

* AbstractAreas Abstract Class Figure Node::
* AbstractAreas Main Class::

Using 'final' with Inheritance

* final to Prevent Overriding::
* final to Prevent Inheritance::

Packages

* Packages Intro::
* Defining Packages::
* Classpath::
* Member Access::
* Importing::

Interfaces

* Defining Interfaces::
* Implementing Interfaces::
* Interface References::
* Partial Implementations::
* Nested Interfaces::
* Applying Interfaces::
* Variables in Interfaces::
* Extending Interfaces::
* Default Interface Methods::
* Interface Static Methods::
* Private Interface Methods::

I/O

* I/O Basics::
* Reading Console Input::
* Writing Console Output::
* PrintWriter Class::
* Reading and Writing Files::
* Automatically Closing Files::
* transient and volatile Modifiers::
* Using instanceof::
* strictfp::
* Native Methods::
* Using assert::
* Static Import::
* Overloaded Constructors with this::
* Compact API Profiles::

I/O Basics

* Streams::
* Byte Streams Character Streams::

Byte Streams and Character Streams

* Byte Stream Class::
* Character Stream Class::
* Predefined Streams::

'System.in' Wrapped in 'BufferedReader'

* Reading Characters::
* Reading Strings::

Program Demonstrating Reading Characters from Console

* Import java.io::
* BRRead BufferedReader Constructor Node::
* BRRead Enter Characters Node::

Program Demonstrating Reading a String from Console

* BRReadLines BufferedReader Constructor::
* BRReadLines Enter Lines::

Generics

* Motivation::
* What are Generics::
* Simple Generics Example::
* Notes about Generics::
* Two Type Parameters::
* Generic Class General Form::
* Bounded Types::
* Wildcard Arguments::
* Generic Methods::
* Generic Constructors::

A Simple Generics Example

* Class Gen<T>::
* Class GenDemo::

Class GenDemo

* GenDemo as Integer::
* GenDemo as String::

Notes About Generics

* Reference Types::
* Type Arguments::
* Subtyping::
* Type Safety::

A Generic Class with Two Type Parameters

* Two Types Example Code::

Example of Code with Two Type Parameters

* Class TwoGen::
* Class SimpGen::

Using Wildcard Arguments

* Wildcard Motivation::
* Wildcard Syntax::
* Bounded Wildcards::

Generalized Form

* Example of Generic Method::

Example of Generic Method

* Method isIn::
* GenMethDemo Main::

Enumerations

* Enumeration Basics::
* Enum Methods::
* Enumerations as Class Types::
* Inherit Enum::

'java.lang' includes the following interfaces

* Primitive Wrappers::

Primitive Type Wrappers

* Number::
* Double and Float::
* isInfiinite() and isNaN()::
* Byte Short Integer Long::
* Numbers to from String::

The Makefile

* Makefile Constants::
* Makefile Defaults::
* Makefile Tangle Weave::
* Makefile Clean::

Code Chunk Summaries

* File Definitions::            Source files by definition.
* Code Chunk Definitions::      Code chunks by definition.
* Code Chunk References::       Code chunks by reference.



File: JavaSE9.info,  Node: Java SE 9 Introduction,  Next: Classes,  Prev: Top,  Up: Top

1 Java SE 9 Introduction
************************


File: JavaSE9.info,  Node: Classes,  Next: Methods and Classes,  Prev: Java SE 9 Introduction,  Up: Top

2 Classes
*********

The class is the logical construct upon which the Java language is
built because it defines the shape and nature of an object, and
therefore forms the basis for object-oriented programming in Java.

* Menu:

* Class Fundamentals::
* Declaring Objects::
* Methods::
* Constructors::
* this Keyword::
* Stack Class::


File: JavaSE9.info,  Node: Class Fundamentals,  Next: Declaring Objects,  Up: Classes

2.1 Class Fundamentals
======================

A "class" defines a new data type.  Once defined, this new type can be
used to create objects of that type.  A class is therefore a template
for an object, and an "object" is an instance of a class.  Object and
instance are often used interchangeably.

* Menu:

* General Form::


File: JavaSE9.info,  Node: General Form,  Up: Class Fundamentals

2.1.1 General Form of a Class
-----------------------------

When you define a class, you declare its exact form and nature.  You
do this by specifying the data that it contains and the code that
operates on that data.  A class is declared by use of the 'class'
keyword.

     class classname {
       type instance-variable1;
       type instance-variable2;
       ...
       type instance-variableN;

       type method-name1 (parameter-list {
         body of method
       }

       type method-name2 (parameter-list {
         body of method
       }
       ...
       type method-nameN (parameter-list {
         body of method
       }
     }

GeneralForm 2.1: Class Declaration -- General Form

   The data, or variables, defined within a class are called "instance
variables".  The code is contained within "methods".  Collectively,
the methods and variables defined within a class are called "members"
of the class.  In most cases, the instance variables are acted upon
and accessed by the methods defined for that class.  As a general
rule, it is the methods that determine how a class' data can be used.

   Each instance of the class (that is, each object of the class)
contains its own copy of the instance variables.  The data for one
object is separate and unique from the data for another.  Changes to
the instance variables of one object have no effect on the instance
variables of another.

   Java classes do not need to have a 'main()' method; you only need
to specify one if that class is the starting point for the program.

   In general, you use the "dot operator" to access both the instance
variables and the methods within an object.  Although commonly
referred to as the dot _operator_, the formal specification for Java
categorizes the . as a _separator_.


File: JavaSE9.info,  Node: Declaring Objects,  Next: Methods,  Prev: Class Fundamentals,  Up: Classes

2.2 Declaring Objects
=====================

Because a class creates a new data type, you can use this type to
declare objects of that type.  Obtaining objects of a class is a
two-step process.

  1. Declare a variable of the class type; this variable does not
     define an object.  Instead, it is simply a variable that can
     _refer_ to an object.
  2. Acquire an actual, physical copy of the object and assign it to
     the variable; you can do this using the 'new' operator.  The
     'new' operator dynamically allocates (at run time) memory for an
     object, and returns a reference to to.  This reference is
     (essentially) the address in memory of the object allocated by
     'new'.  This reference is then stored in the variable.  In Java,
     all class objects must be dynamically allocated.

Example Declaration, Allocation, and Assignment
===============================================

     Box mybox; // 1. declare a variable
     mybox = new Box(); // 2. allocate a Box object

   These two declarations can be combined into a single declaration,
and usually are:

     Box mybox = new Box();

   The 'mybox' variable simply holds the memory address of the actual
'Box' object.  The class name followed by parenthese specifies the
"constructor" for the class.


File: JavaSE9.info,  Node: Methods,  Next: Constructors,  Prev: Declaring Objects,  Up: Classes

2.3 Methods
===========

General Form of a Method Declaration
====================================

     type name (parameter-list) {
       body of method
     }

GeneralForm 2.2: Method Declaration -- General Form

type specifies the type of data returned by the method.  This can be
any valid type, including class types that you create.  If the method
does not return a value, its return type must be 'void'.

   "name" is the name of the method.  This can be any legal
identifier.

   "parameter-list" is a sequence of type and identifier pairs
separated by commas.  "Parameters" are essentially variables that
receive the value of the arguments passed to the method when it is
called.  If the method has no parameters, then the parameter list will
be empty.

   Methods that have a return type other than 'void' return a value to
the calling routine using a "return statement":

     return value

   where value is the value returned.


File: JavaSE9.info,  Node: Constructors,  Next: this Keyword,  Prev: Methods,  Up: Classes

2.4 Constructors
================

Java allows objects to initialize themselves when they are created.
This automatic initialization is performed through the use of a
constructor.

   A "constructor" initializes an object immediately upon creation.
It has the same name as the class in which it resides and is
syntactically similar to a method.  Once defined, the constructor is
automatically called when the object is created, before the 'new'
operator completes.  Constructors have no return type.  It is the
constructor's job to initialize the internal state of an object so
that the code creating an instance will have fully initialized, usable
object immediately.


File: JavaSE9.info,  Node: this Keyword,  Next: Stack Class,  Prev: Constructors,  Up: Classes

2.5 The 'this' Keyword
======================

Sometimes a method will need to refer to the object that invoked it.
To allow this, Java defines the 'this' keyword.  'this' can be used
inside any method to refer to the _current_ object.  That is, 'this'
is always a refernce to the object on which the method was invoked.
You can use 'this' anywhere a reference to an object of the current
class' type is permitted.

* Menu:

* Instance Variable Hiding::


File: JavaSE9.info,  Node: Instance Variable Hiding,  Up: this Keyword

2.5.1 Instance Variable Hiding
------------------------------

It is illegal to declare two local variables with the same name inside
the same or enclosing scope.  However, you can have local variables,
including formal parameters to methods, which overlap with the names
of the class' instance variables.  For these cases, the local
variables _hide_ the instance variables of the same name.

   Because 'this' lets you refer directly to the object, you can use
it to resolve any namespace collisions that might occur between
instance variables and local variables.  So, 'this.width = width' is
an example of a local variable ('width') hiding an instance variable
(also 'width'), with 'this' allowing an assignment between them.


File: JavaSE9.info,  Node: Stack Class,  Prev: this Keyword,  Up: Classes

2.6 A Stack Class
=================

To see a practical application of object-oriented programming, here is
one of the archetypal examples of encapsulation: the stack.  A "stack"
stores data using _first-in, last-out_ ordering.  That is, a stack is
like a stack of plates on a table -- the first plate put down on the
table is the last plate to be used.  Stacks are controlled through two
operations traditionally called "push" and "pop".  To put an item on
top of the stack, you will use 'push'.  To take an item off the stack,
you will use 'pop'.  It is easy to encapsulate the entire stack
mechanism.

   Here is a class called 'Stack' that implements a stack for up to
ten integers, plus test class called 'TestStack':

Stack.java
==========

{'Stack.java'} ==
     class Stack {
       <Stack Instance Variables>
       <Stack Constructor>
       <Stack Instance Methods>
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Constructor>       See *note Stack-Constructor::.
<Stack Instance           See *note Stack-Instance-Methods::.
Methods>
<Stack Instance           See *note Stack-Instance-Variables::.
Variables>

TestStack.java
==============

{'TestStack.java'} ==
     class TestStack {
       <TestStack Main Method>
     }


The called chunk <TestStack Main Method> is first defined at *note
TestStack-Main-Method::.

* Menu:

* Stack Instance Variables::
* Stack Constructor Node::
* Stack Instance Methods Node::
* Stack TestStack Node::


File: JavaSE9.info,  Node: Stack Instance Variables,  Next: Stack Constructor Node,  Up: Stack Class

2.6.1 Stack Instance Variables
------------------------------

<Stack Instance Variables> ==
     int[] stck = new int[10];
     int tos;


This chunk is called by {'Stack.java'}; see its first definition at
*note Stack-java::.


File: JavaSE9.info,  Node: Stack Constructor Node,  Next: Stack Instance Methods Node,  Prev: Stack Instance Variables,  Up: Stack Class

2.6.2 Stack Constructor Subsection
----------------------------------

<Stack Constructor> ==
     // initialize top-of-stack tos
     Stack() {
       tos = -1;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'Stack.java'}            See *note Stack-java::.
{'StackImproved.java'}    See *note StackImproved-java::.


File: JavaSE9.info,  Node: Stack Instance Methods Node,  Next: Stack TestStack Node,  Prev: Stack Constructor Node,  Up: Stack Class

2.6.3 Stack Instance Methods Subsection
---------------------------------------

<Stack Instance Methods> ==
     <Stack Push>
     <Stack Pop>

This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'Stack.java'}            See *note Stack-java::.
{'StackImproved.java'}    See *note StackImproved-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Pop>               See *note Stack-Pop::.
<Stack Push>              See *note Stack-Push::.

* Menu:

* Stack Push and Pop Node::


File: JavaSE9.info,  Node: Stack Push and Pop Node,  Up: Stack Instance Methods Node

2.6.3.1 Stack Push and Pop Subsubsection
........................................

<Stack Push> ==
     // Push an item onto the stack
     void push(int item) {
       if (tos == 9)
         System.out.println("Stack is full.");
       else
         stck[++tos] = item;
     }


This chunk is called by <Stack Instance Methods>; see its first
definition at *note Stack-Instance-Methods::.

<Stack Pop> ==
     // Pop an item from the stack
     int pop() {
       if (tos < 0) {
         System.out.println("Stack underflow.");
         return 0;
       } else
         return stck[tos--];
       }
     }


This chunk is called by <Stack Instance Methods>; see its first
definition at *note Stack-Instance-Methods::.


File: JavaSE9.info,  Node: Stack TestStack Node,  Prev: Stack Instance Methods Node,  Up: Stack Class

2.6.4 Stack TestStack Subsection
--------------------------------

<TestStack Main Method> ==
     public static void main(String[] args) {
       Stack mystack1 = new Stack();
       Stack mystack2 = new Stack();

       // push some numbers onto the stack
       for (int i = 0; i < 10; i++)
         mystack1.push(i);
       for (int i = 10; i < 20; i++)
         mystack2.push(i);

       // pop those numbers off the stack
       System.out.println("Stack in mystack1:");
       for (int i = 0; i < 10; i++)
         System.out.println(mystack1.pop());

       System.out.println("Stack in mystack2:");
       for (int i + 0; i < 10; i++)
         System.out.println(mystack2.pop());
     }


This chunk is called by {'TestStack.java'}; see its first definition
at *note TestStack-java::.


File: JavaSE9.info,  Node: Methods and Classes,  Next: Inheritance,  Prev: Classes,  Up: Top

3 Methods and Classes
*********************

This chapter examines several topics relating to methods and classes,
including

   * overloading
   * parameter passing
   * recursion
   * access control
   * keywords 'static' and 'final'
   * 'String' class
   * Arrays
   * nested and inner classes
   * command-line arguments and varargs

* Menu:

* Overloading Methods::
* Objects as Parameters::
* Argument Passing::
* Returning Objects::
* Recursion::
* Access Control::
* static Keyword::
* final Keyword::
* Arrays 2::
* Nested and Inner Classes::
* String Class::
* Command-Line Arguments::
* Varargs::


File: JavaSE9.info,  Node: Overloading Methods,  Next: Objects as Parameters,  Up: Methods and Classes

3.1 Overloading Methods
=======================

It is possible to define two or more methods within the same class
that share the same name as long as their parameter declarations are
different.  When this is the case, the methods are said to be
"overloaded", and the process is referred to as "method overloading".
Method overloading is one of the ways that Java supports polymorphism.

   When an overloaded method is invoked, Java uses the type and number
of arguments as its guid to determine which version of the overloaded
method to actually call.  Thus, overloaded methods must differ in the
type or number of their parameters.  While overloaded methods may have
different return types, thei return type alone is inusfficient to
distinguish two versions of a method.  When Java encounters a call to
an overloaded method, it simply executes the version of the method
whose parameters match the arguments used in the call.

   The match between arguments and parameters need not always be
exact.  In some cases,Java's automatic type conversions can play a
role in overload resolution.  For example, if there is a method with
one 'double' parameter, and that method is invoked with a single 'int'
argument, then, when no exact match is found, Java will automatically
convert the integer into a 'double', and this conversion will be used
to resolve the call.  Java will employ automatic type conversion only
if no exact match is found.

   Method overloading supports polymorphism because it is one way that
Java implements the _one interface, multiple methods_ paradigm.  That
is, Java does not need to rename each similar method just because it
has a slightly different parameter requirements.  The value of
overloading is that it allows related methods to be accessed by use of
a common name, representing the _general action_ that is being
performed, and leaves to the compiler the choice of the right
_specific_ version for a particular circumstance.  The programmer need
only remember the general operation being performed.  Through the
application of polymorphism, several names have been reduced to one.
Overloading can help manage greater complexity.

* Menu:

* Overloading Constructors::


File: JavaSE9.info,  Node: Overloading Constructors,  Up: Overloading Methods

3.1.1 Overloading Constructors
------------------------------

You can also overload constructor methods.


File: JavaSE9.info,  Node: Objects as Parameters,  Next: Argument Passing,  Prev: Overloading Methods,  Up: Methods and Classes

3.2 Objects as Parameters
=========================

It is both correct and common to pass objects to methods as well as
primitive types.  One of the most common uses of object parameters
involves constructors.  Frequently you will want to construct a new
object so that it is initially the same as some existing object.  To
do this, you must define a constructor that takes an object of its
class as a parameter.  Providng many forms of constructors is usually
required to allow objects to be constructed in a convenient and
efficient manner.


File: JavaSE9.info,  Node: Argument Passing,  Next: Returning Objects,  Prev: Objects as Parameters,  Up: Methods and Classes

3.3 Argument Passing
====================

In general, there are two ways that a computer language can pass an
argument to a subroutine:

  1. call-by-value
  2. call-by-reference

   Java uses call-by-value to pass all arguments, although the precise
effect differs between whether a primitive type or a reference type is
passed.

   When you pass a primitive type to a method, it is passed by value.
Thus, a copy of the argument is made, and what occurs to the parameter
that receives the argument has no effect outside the method.

   When you pass an object to a method, the situation changes; objects
are passed by what is effectively call-by-reference.  When you pass a
variable of a class type, you pass a reference to the method and the
parameter receiving it will refer to the same object.  This
effectively means that objects act as if they are passed to methods by
use of call-by-reference.  Changes to the object inside the method
_do_ affect the object used as an argument.  However, when an object
reference is passed to a method, the reference itself is passed by use
of call-by-value; therefore, that reference will continue to refer to
the object, even though the object itself may be modified.


File: JavaSE9.info,  Node: Returning Objects,  Next: Recursion,  Prev: Argument Passing,  Up: Methods and Classes

3.4 Returning Objects
=====================

A method can return any type of data, including class types that you
create.

   Since all objects are dynamically allocated using 'new', you don't
need to worry about an object going out-of-scope because the method in
which it was created terminates.  The object will continue to exist as
long as there is a reference to it somewhere in your program.  When
there are no references to it, the object will be reclaimed the next
time garbage collection takes place.


File: JavaSE9.info,  Node: Recursion,  Next: Access Control,  Prev: Returning Objects,  Up: Methods and Classes

3.5 Recursion
=============

"Recursion" is the process of defining something in terms of itself.
In programming, it is also what allows a method to call itself.  A
method that calls itself is said to be "recursive".

   When a method calls itself, new local variables and parameters are
allocated storage on the stack, and the method code is executed with
these new variables from the start.  As each recursive call returns,
the old local variables and parameters are removed from the stack, and
execution resumes at the point of the call inside the method.

   Recursive versions of many routines may execute a bit slower than
the iterative equivalent because of the added overhead of the
additional method calls.  A large number of recursive calls to a
method could cause a stack overrun.  Because storage for parameters
and local varibles is on the stack and each new call creates a new
copy of these variables, it is possible that the stack could be
exhausted.  If this occurs, the Java run-time system will cause an
exception.

   The main advantage to recursive methods is that they can be used to
create clearer and simpler versions of several algorithms than can
their iterative relatives.  For example, the QuickSort sorting
algorithm is quite difficult to implement in an iterative way.  Also,
some types of AI-related algorithms are most easily implemented using
recursive solutions.


File: JavaSE9.info,  Node: Access Control,  Next: static Keyword,  Prev: Recursion,  Up: Methods and Classes

3.6 Access Control
==================

Encapsulation provides another important attribute besides linking
data with code: "access control".  Through encapsulation, you can
control what parts of a program can access the members of a class.  By
controlling access, you can prevent misuse.  Thus, when correctly
implemented, a class creates a _black box_ which may be used, but the
inner workings of which are not open to tampering.  The classes
introduced earlier do not completely meet this goal.  For example, the
'Stack' class provides the methods 'push()' and 'pop()' as a
controlled interface to the stack, this interface is not enforced --
it is possible for another part of the program to bypass these methods
and access the stack directly.  This could lead to trouble.

   How a member can be accessed is determined by the "access modifier"
attached to its declaration.  Java supplies a rich set of access
modifiers.  Some aspects of access control are related mostly to
inheritance or packages (and now modules).  Those ideas will be
discussed later.  Here, let's examine access control as it relates to
a single class.

Access Modifiers
----------------

Java's access modifiers are:

   * public
   * private
   * protected (applies only to inheritance)
   * default access level

'public' vs 'private' Access
............................

When a member of a class is modified by 'public', then that member can
be accessed by any other code.  When a member of a class is specified
as 'private', then that member can only be accessed by other members
of its class.  Thus, the method 'main()' is always preceded by the
'public' modifier.  It must be called by code that is outside the
program -- the Java run-time system.

Default Access -- No Access Modifier
------------------------------------

When no access modifier is used, then by default the member of a class
is public within its own package, but cannot be accessed outside of
its package.  In the classes developed so far, all members of a class
have used the 'default' access mode.  However, this is typically not
what you will want to be the case.  Usually, you will want to restrict
access to the data members of a class -- allowing access only through
methods.  There will also be times when you will want to define
methods that are private to a class.

Access Modifier Syntax
----------------------

An access modifier precedes the rest of a member's type specification.
That is, it must begin a member's declaration statement.  As an
example:

     public int i;
     private double j;

     private int myMethod(int a, char b) {
       ...
     }

Access Control and Inheritance
------------------------------

Consult the chapter on *note Inheritance:: for more on the topic of
access control in relation to inheritance.

* Menu:

* Improved Stack Class::


File: JavaSE9.info,  Node: Improved Stack Class,  Up: Access Control

3.6.1 An Improved 'Stack' Class
-------------------------------

StackImproved.java
------------------

Compare this code with that of *note Stack Class::.  (1)

{'StackImproved.java'} ==
     class StackImproved {
       <Stack Private Instance Variables>
       <Stack Constructor>
       <Stack Instance Methods>
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Constructor>       See *note Stack-Constructor::.
<Stack Instance           See *note Stack-Instance-Methods::.
Methods>
<Stack Private Instance   See
Variables>                *note Stack-Private-Instance-Variables::.

Stack Private Instance Variables
--------------------------------

<Stack Private Instance Variables> ==
     /* Now, both stck and tos are private.  This means
        that they cannot be accidentally or maliciously
        altered in a way that would be harmful to the stack.
      */

     private int[] stck = new int[10];
     private int tos;


This chunk is called by {'StackImproved.java'}; see its first
definition at *note StackImproved-java::.

   Now both 'stck', which holds the stack, and 'tos', which is the
index of the top of the stack, are specified as 'private'.  This means
that they cannot be accessed or altered except through 'push()' and
'pop()'.  Making 'tos' private, for example, prevents other parts of
your program from inadvertently setting it to a value that is beyond
the end of the 'stck' array.  In other words, the following code,
added to the end of the 'TestStack.java' program (*note
TestStack-Main-Method::), would be illegal and the program would not
compile:

     mystack1.tos = -2;
     mystack2.stck[3] = 100;

   ---------- Footnotes ----------

   (1) Notice how all of the prior code except what is changed can
easily be reused using TexiWebJr's modular system.


File: JavaSE9.info,  Node: static Keyword,  Next: final Keyword,  Prev: Access Control,  Up: Methods and Classes

3.7 'static' Keyword
====================

There will be times when you want to define a class member that will
be used independently of any object of that class.  Normally, a class
member must be accessed in conjunction with an object of its class.
However, it is possible to create a member that can be used by itself
without reference to a specific instance.  To create such a member,
precede its declaration with the keyword 'static'.  When a member is
declared 'static', it can be accessed before any objects of its class
are created, and without reference to any object.

   You can declare both methods and variables to be 'static'.
Instance variables declared as 'static' are essentially global
variables.  When objects of its class are declared, no copy of a
'static' variable is made.  Instead, all instances of the class share
the same 'static' variable.

Restrictions on 'static' Methods
--------------------------------

Methods declared as 'static' have several restrictions:

   * they can only directly call other 'static' methods of their
     class;
   * they can only directly access 'static' variables of their class;
   * they cannot refer to 'this' or 'super' in any way;

'static' Block
--------------

If you need to do computation in order to initialize your 'static'
variables, you can declare a 'static' block that gets executed exactly
once, when the class is first loaded ("static initialization block").

     class UseStatic {
       static int a = 3;
       static int b;

       static {
         b = a * 4;
       }
     }

   As soon as the 'UseStatic' class is loaded, all of the 'static'
statements are run.  First, 'a' is set to '3', then the 'static' block
executes and initializes 'b' to 'a * 4' or '12'.  Then 'main()' is
called (not shown).

Use of 'static' Members Outside Their Class
-------------------------------------------

Outside of the class in which they are defined, 'static' methods and
variables can be used independently of any object.  To do so, you need
only specify the name of their class followed by the dot operator:
classname.method().  classname is the name of the class in which the
'static' method is declared.  A 'static' variable can be accessed in
the same way.  This is how Java implements a controlled version of
global methods and global variables.


File: JavaSE9.info,  Node: final Keyword,  Next: Arrays 2,  Prev: static Keyword,  Up: Methods and Classes

3.8 'final' Keyword
===================

A field can be declared as 'final'.  Doing so prevents its contents
from being modified, making it, esentially, a constant.  This means
that you must initialize a 'final' field when it is declared.  You can
do this in one of two ways: when it is declared, or within a
constructor.

   In addition to fields, both method parameters and local variables
can be declared as 'final'.  Declaring a parameter as 'final' prevents
it from being changed within the method.  Declaring a local variable
'final' prevents it from being assigned a value more than once.

   The keyword 'final' can also be applied to methods, but its meaning
is different than when applied to variables.  This usage of 'final' is
described in the next chapter (*note Inheritance::).


File: JavaSE9.info,  Node: Arrays 2,  Next: Nested and Inner Classes,  Prev: final Keyword,  Up: Methods and Classes

3.9 Arrays Revisited
====================

Arrays are implemented as objects.  Because of this, there is a
special array attribute that you will want to take advantage of.
Specifically, the size of an array--that is, the number of elements
that an array can hold--is found in its 'length' instance variable.
All arrays have this variable, and it will always hold the size of the
array.  Keep in mind that the value of 'length' has nothing to do with
the number of elements that are actually in use.  It only reflects the
number of elements taht the array is designed to hold.


File: JavaSE9.info,  Node: Nested and Inner Classes,  Next: String Class,  Prev: Arrays 2,  Up: Methods and Classes

3.10 Nested and Inner Classes
=============================

It is possible to define a class within another class; such classes
are known as "nested classes".  The scope of a nested class is bounded
by the scope of its enclosing class.  A nested class does not exist
independently of its enclosing class.  A nested class has access to
the members, including private members, of the enclosing class.
However,the enclosing class does not have access to the members of the
nested class.  A nested class that is declared directly within its
enclosing class scope is a member of its enclosing class.  It is also
possible to declare a nested class that is local to a block.

Static Nested Class
===================

There are two types of nested class: "static" and "inner".  A static
nested class is one that has the 'static' modifer applied.  Because it
is static, it must access the non-static members of its enclosing
class through an object.  That is, it cannot refer to non-static
members of its enclosing class directly.  Static nested classes are
seldom used.

Inner Class
===========

The most important type of nested class is the "inner" class.  An
inner class is a non-static nested class.  It has access to all of the
variables and methods of its outer class and may refer to them
directly in the same way that other non-static members of the outer
class do.

   An instance of an inner class can be created only in the context of
its enclosing class.  The Java compiler will report an error
otherwise.  In general, an inner class instance is often creaed by
code wihtin its enclosing scope.

   It is possible to define inner classes within any block scope,
including within the block defined by a method or even within the body
of a 'for' loop.

Handling Events
===============

While nested classes are not applicable to all situations, they are
particularly helpful when handling events.  *Note Event Handling::.
There are also "anonymous inner classes", inner classes that don't
have a name.


File: JavaSE9.info,  Node: String Class,  Next: Command-Line Arguments,  Prev: Nested and Inner Classes,  Up: Methods and Classes

3.11 The 'String' Class
=======================

Every string you create is an object of type 'String'.  Even string
constants are 'String' objects.  For example, in the statement
'System.out.println("This is a String, too");', the quote is a
'String' object.

   Objects of type 'String' are immutable; once a 'String' object is
created, its contents cannot be altered.  Java defines peer classes of
'String', called 'StringBuffer' and 'StringBuilder', which allow
strings to be altered, so all of the normal string manipulations are
still available.

Constructing 'String' Objects and Concatenating 'Strings'
=========================================================

Strings can be constructed in a variable of ways.  The easiest is to
use a statement:

     String myString = "this is a test";

   Java defines one operator for 'String' objects: '+'.  It is used to
concatenate two strings.

     String myString = "I" + " like " + "Java.";

'String' Methods
================

The 'String' class contains several methods that you can use.

   * boolean 'equals(secondStr)'
   * int 'length()'
   * char 'charAt(index)'


File: JavaSE9.info,  Node: Command-Line Arguments,  Next: Varargs,  Prev: String Class,  Up: Methods and Classes

3.12 Using Command-Line Arguments
=================================

Sometimes you will want to pass information into a program when you
run it.  This is accomplished by passing "command-line arguments" to
'main()'.  A command-line argument is the informatino that directly
follows the program's name on the command line when it is executed.
To access the command-line arguments inside a Java program, access the
'String' arguments passed to the 'args' parameter of 'main()'.  The
first command-line argument is stored at 'args[0]', the second at
'args[1]', and so on.  All command-line arguments are passed as
strings.  You must convert numeric values to their internal forms
manually.  *Note java Lang::.


File: JavaSE9.info,  Node: Varargs,  Prev: Command-Line Arguments,  Up: Methods and Classes

3.13 Varargs: Variable-Length Arguments
=======================================

Beginning with JDK 5, Java has included a feature that simplifies the
creation of methods that need to take a variable number of arguments.
This feature is called "varargs" and it is short for "variable-length
arguments".  A method that takes a variable number of arguments is
called a "variable-arity method", or simply "varargs method".

   A variable-length argument is specified by three period (...).  For
example: 'static void vaTest (int ... v) {'.  This syntax tells the
compiler that 'vaTest()' can be called with zero or more arguments.
As a result, 'v' is implicitly declared as an array of type 'int[]'.
Thus, inside 'vaTest()', 'v' is accessed using the normal array
syntax.

   A method can have _normal_ parameters along with a variable-length
parameter, but the variable-length parameter must be the final
parameter declared by the method.  Further, there can be only one
varargs parameter.

     int doIt(int a, int b, double c, int ... vals) {

   After the first three arguments, any remaining arguments are passed
to 'vals'.

Overloading Vararg Methods
==========================

You can overload a method that takes a variable-length argument (i.e.,
it can be given a different type, or additional parameters can be
included, or a non varargs parameter).

   Note that unexpected errors can result when overloading a method
that takes a variable-length argument.  These errors involve ambiguity
because it is possible to create an ambiguous call to an overloaded
varargs method.  In such a case, the program will not compile.  While
each individual method declaration might be valid, the call might yet
be ambiguous.


File: JavaSE9.info,  Node: Inheritance,  Next: Packages,  Prev: Methods and Classes,  Up: Top

4 Inheritance
*************

Inheritance is a cornerstone of object-oriented programming because it
allows the creation of hierarchical classifications.  Using
inheritance, you can create a general class that defines traits common
to a set of related items.  This class can then be inherited by other,
more specific classes, each adding those things that are unique to
them.

   A class that is inherited is called a "superclass".  The class that
does the inheriting is called a "subclass".  A subclass is a
specialized version of a subclass.  It inherits all of the members
defined by the superclass and adds its own, unique elements.

* Menu:

* Inheritance Basics::
* Using super::
* Multilevel Hierarchy::
* Constructors Executed::
* Method Overriding::
* Dynamic Method Dispatch::
* Using Abstract Classes::
* final with Inheritance::
* Object Class::


File: JavaSE9.info,  Node: Inheritance Basics,  Next: Using super,  Up: Inheritance

4.1 Inheritance Basics
======================

To _inherit_ a class, incorporate the definition of one class into
another by using the 'extends' keyword.

     class A {...}
     class B extends A {...}

   A subclass will include all of the members of its superclass.  The
subclass can directly reference all of the members of the superclass
as well.  Subclasses can be superclasses of other subclasses.

General Form of a Subclass Inheriting a Superclass
==================================================

     class subclass-name extends superclass-name {
       body of class
     }

GeneralForm 4.1: Subclass General Form

A subclass can have only one superclass.  Java does not support the
inheritance of multiple superclasses into a single subclass.

* Menu:

* Member Access and Inheritance::
* Superclass Referencing Subclass::


File: JavaSE9.info,  Node: Member Access and Inheritance,  Next: Superclass Referencing Subclass,  Up: Inheritance Basics

4.1.1 Member Access and Inheritance
-----------------------------------

Although a subclass includes all of the members of its superclass, it
cannot access those members of the superclass that have been declared
as 'private'.  A class member that has been declared as 'private' will
remain private to its class.  It is not accessible by any code outside
its class, including subclasses.

   A major advantage of inheritance is that once you have created a
superclass that defines the attributes commoin to a set of objects, it
can be used to create any number of more specific subclasses.  Each
subclass can precisely tailor its own classification.


File: JavaSE9.info,  Node: Superclass Referencing Subclass,  Prev: Member Access and Inheritance,  Up: Inheritance Basics

4.1.2 A Superclass Variable Can Reference a Subclass Object
-----------------------------------------------------------

A reference variable of a superclass can be assigned a reference to
any subclass derived from that superclass.

   It is important to understand that itis the _type of the reference
variable_ -- not the type of the object that it refers to -- that
determines what members can be accessed.  That is, when a reference to
a subclass object is assigned to a superclass reference variable, you
will have access _only_ to those parts of the object defined by the
superclass.  The superclass has no knowledge of what a subclass adds
to it.


File: JavaSE9.info,  Node: Using super,  Next: Multilevel Hierarchy,  Prev: Inheritance Basics,  Up: Inheritance

4.2 Using 'super'
=================

Whenever a subclass needs to refer to its immediate superclass, it can
do so by use of the keyword 'super'.  'super' has two general forms.
The first calls the superclass' constructor.  The second is used to
access a member of the superclass that has been hidden by a member of
a subclass.

* Menu:

* super Calling Superclass Constructor::
* super Referencing Superclass::


File: JavaSE9.info,  Node: super Calling Superclass Constructor,  Next: super Referencing Superclass,  Up: Using super

4.2.1 Using 'super' to Call Superclass Constructors
---------------------------------------------------

A subclass can call a constructor defined by its superclass by use of
the following form of 'super':

     super(arg-list);

GeneralForm 4.2: 'super' Calling a Constructor

   arg-list specifies any arguments needed by the constructor in the
superclass.  'super()' must always be the first statement executed
inside a subclass' constructor.  'super()' can be called using any
form defined by the superclass.


File: JavaSE9.info,  Node: super Referencing Superclass,  Prev: super Calling Superclass Constructor,  Up: Using super

4.2.2 'super' Referencing Superclass
------------------------------------

The second form of 'super' acts somewhat like 'this', except that it
always refers to the superclass of the subclass in which it is used.

     super.member

GeneralForm 4.3: 'super' Referencing its Superclass

   member can be either a method or an instance variable.  This form
of 'super' is most applicable to situations in which member names of a
subclass hide members by the same name in the superclass.

     i = super.i;

   'super' allows access to the 'i' defined in the superclass.
'super' can also be used to call methods that are hidden by a
subclass.


File: JavaSE9.info,  Node: Multilevel Hierarchy,  Next: Constructors Executed,  Prev: Using super,  Up: Inheritance

4.3 Creating a Multilevel Hierarchy
===================================

You can buidl hierarchies that contain as many layers of inheritance
as you like.  It is acceptable to use a subclass as a superclass of
antoher.  Each subclass inherits all of tghe traits found in all of
its superclasses.

   'super' always refers to the constructor in the closest superclass.

   While an entire class hierarchy can be created in a single file,
the individual classes (superclasses and subclasses) can be placed
into their own files and compiled separately.  Using separate files is
the norm, not the exception, in creating class hierarchies.


File: JavaSE9.info,  Node: Constructors Executed,  Next: Method Overriding,  Prev: Multilevel Hierarchy,  Up: Inheritance

4.4 When Constructors are Executed
==================================

In a class hierarchy, constructors complete their execution in order
of derivation, from superclass to subclass.


File: JavaSE9.info,  Node: Method Overriding,  Next: Dynamic Method Dispatch,  Prev: Constructors Executed,  Up: Inheritance

4.5 Method Overriding
=====================

In a class hierarchy, when a method in a subclass has the same name
and type signature as a method in its superclass, then the method in
the subclass is said to "override" the method in the superclass.  When
an overriden method is called from within its subclass, it will always
refer to the version of that method defined by the subclass.  The
version of the method defined by the superclass will be hidden.

   If you wish to access the superclass version of an overridden
method, you can so by using 'super'.

   Method overriding occurs _only_ when the names and the type
signatures of the two methods are identical.  If they are not, then
the two methods are simply overloaded (no name hiding takes place).


File: JavaSE9.info,  Node: Dynamic Method Dispatch,  Next: Using Abstract Classes,  Prev: Method Overriding,  Up: Inheritance

4.6 Dynamic Method Dispatch
===========================

Method overriding forms the basis for one of Java's most powerful
concepts: "dynamic method dispatch".  This is a meachanism by which a
call to an overrident method is resolved at run time, rather than
compile time.  This is important because this is how Java implements
run-time polymorphism.

   A superclass reference variable can refer to a subclass object.
Java uses this fact to resolve calls to overriden methods at run time.
When an overriden method is called through a superclass reference,
Java determines which version of that method to execute based upon the
type of the object being referred to at the time the call occurs.
Thus, this determination is made at run time.  When different types of
objects are referred to, different versions of an overridden method
will be called.  In other words, _it is the type of the object being
referred to_ (not the type of the reference variable) that determines
which version of an overridden method will be executed.  Therefore, if
a superclass contains a method that is overridden by a subclass, then
when different types of objects are referred to through a superclass
reference variable, different versions of the method are executed.

* Menu:

* Why Overridden Methods::
* Applying Method Overriding::


File: JavaSE9.info,  Node: Why Overridden Methods,  Next: Applying Method Overriding,  Up: Dynamic Method Dispatch

4.6.1 Why Overridden Methods?
-----------------------------

Overridden methods allow Java to support run-time polymorphism.
Polymorphism is essential to object-oriented programming for one
reason: it allows a general class to specify methods that will be
common to all of its derivatives, while allowing subclasses to define
the specific implementation of some or all of those methods.
Overridden methods are another way that Java implements the "one
interface, multiple methods" aspect of polymorphism.

   Successfully applying polymorphism is understanding that the
superclasses and subclasses form a hierarchy which moves from lesser
to greater specialization.  Used correctly, the superclass provides
all elements that a subclass can use directly.  It also defines those
methods that the derived class must implement on its own.  This allows
the subclass the flexibility to define its own methods, yet still
enforces a consistent interface.  Thus, by combining inheritance with
overridden methods, a superclass can define the general form of the
methods that will be used by all of its subclasses.

   Dynamic, run-time polymorphism is one of the most powerful
mechanisms that object-oriented design brings to bear on code reuse
and robustness.  The ability of existing code libraries to call
methods on instances of new classes without recompiling while
maintaining a clean abstract interface is a profoundly powerful tool.


File: JavaSE9.info,  Node: Applying Method Overriding,  Prev: Why Overridden Methods,  Up: Dynamic Method Dispatch

4.6.2 Applying
--------------

Let's look at a practical example that uses method overriding.  The
following program creates a superclass called 'Figure' that stores the
dimensions of a two-dimensional object.  It also defines a method
called 'area()' that computes the area of an object.  The program
derives two subclasses from 'Figure'.  The first is 'Rectangle' and
the second is 'Triangle'.  Each of these subclasses overrides 'area()'
so that it returns the area of a rectangle and a triangle
respectively.

{'FindAreas.java '} ==
     <FindAreas SuperClass Figure >
     <FindAreas SubClass Rectangle >
     <FindAreas SubClass Triangle >
     <FindAreas Main Class >


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<FindAreas Main Class >   See *note FindAreas-Main-Class-::.
<FindAreas SubClass       See *note FindAreas-SubClass-Rectangle-::.
Rectangle >
<FindAreas SubClass       See *note FindAreas-SubClass-Triangle-::.
Triangle >
<FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
Figure >

Output
......

The output from the program should be:

     Inside Area for Rectangle.
     Area is 45
     Inside Area for Triangle.
     Area is 40
     Area for Figure is undefined.
     Area is 0

   Through the dual mechanisms of inheritance and run-time
polymorphism, it is possible to define one consistent interface that
is used by several different, yet related, types of objects.  In this
case, if an object is derived from 'Figure', then its area can be
obtained by calling 'area()'.  The interface to this operation is the
same no matter what type is being used.

* Menu:

* FindAreas SuperClass Figure Node::
* FindAreas SubClass Rectangle Node::
* FindAreas SubClass Triangle Node::
* FindAreas Main Class Node::


File: JavaSE9.info,  Node: FindAreas SuperClass Figure Node,  Next: FindAreas SubClass Rectangle Node,  Up: Applying Method Overriding

4.6.2.1 FindAreas Superclass Figure Section
...........................................

<FindAreas SuperClass Figure > ==
     class Figure {
       <Figure Instance Variable Declarations >
       <Figure Constructor >
       <Figure Area Method Declaration >
     }


This chunk is called by {'FindAreas.java '}; see its first definition
at *note FindAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Figure Area Method       See *note Figure-Area-Method-Declaration-::.
Declaration >
<Figure Constructor >     See *note Figure-Constructor-::.
<Figure Instance          See
Variable Declarations >   *note Figure-Instance-Variable-Declarations-::.

Figure Instance Variable Declarations
.....................................

<Figure Instance Variable Declarations > ==
     double dim1;
     double dim2;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
<FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
Figure >

Figure Constructor
..................

<Figure Constructor > ==
     Figure (double 1, double b) {
       dim1 = a;
       dim2 = b;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
<FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
Figure >

Figure Area Method Declaration
..............................

It will be this method that will be overridden by the two subclasses;
while this method will not produce any output, each of the subclasses
will provide a formula for their own area and output that number, even
though the same method ('area()') is being called in each case from
the same variable.

<Figure Area Method Declaration > ==
     double area() {
       System.out.println("Area for Figure is undefined.");
       return 0;
     }


This chunk is called by <FindAreas SuperClass Figure >; see its first
definition at *note FindAreas-SuperClass-Figure-::.


File: JavaSE9.info,  Node: FindAreas SubClass Rectangle Node,  Next: FindAreas SubClass Triangle Node,  Prev: FindAreas SuperClass Figure Node,  Up: Applying Method Overriding

4.6.2.2 FindAreas SubClass Rectangle Section
............................................

<FindAreas SubClass Rectangle > ==
     class Rectangle extends Figure {
       <Rectangle Constructor >
       <Rectangle Area Method Declaration >
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'AbstractAreas.java '}   See *note AbstractAreas-java-::.
{'FindAreas.java '}       See *note FindAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Rectangle Area Method    See
Declaration >             *note Rectangle-Area-Method-Declaration-::.
<Rectangle Constructor    See *note Rectangle-Constructor-::.
>

Rectangle Constructor
.....................

<Rectangle Constructor > ==
     Rectangle (double a, double b) {
       super(a, b);
     }


This chunk is called by <FindAreas SubClass Rectangle >; see its first
definition at *note FindAreas-SubClass-Rectangle-::.

Rectangle Area Method Declaration
.................................

<Rectangle Area Method Declaration > ==
     // override area for rectangle
     double area() {
       System.out.println("Inside Area for Rectangle.";
       return dim1 * dim2;
     }


This chunk is called by <FindAreas SubClass Rectangle >; see its first
definition at *note FindAreas-SubClass-Rectangle-::.


File: JavaSE9.info,  Node: FindAreas SubClass Triangle Node,  Next: FindAreas Main Class Node,  Prev: FindAreas SubClass Rectangle Node,  Up: Applying Method Overriding

4.6.2.3 FindAreas SubClass Triangle Section
...........................................

<FindAreas SubClass Triangle > ==
     class Triangle extends Figure {
       <Triangle Constructor >
       <Triangle Area Method Declaration >
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'AbstractAreas.java '}   See *note AbstractAreas-java-::.
{'FindAreas.java '}       See *note FindAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Triangle Area Method     See
Declaration >             *note Triangle-Area-Method-Declaration-::.
<Triangle Constructor >   See *note Triangle-Constructor-::.

Triangle Constructor
....................

<Triangle Constructor > ==
     Triangle (double a, double b) {
       super(a, b);
     }


This chunk is called by <FindAreas SubClass Triangle >; see its first
definition at *note FindAreas-SubClass-Triangle-::.

Triangle Area Method Declaration
................................

<Triangle Area Method Declaration > ==
     // override area for right triangle
     double area () {
       System.out.println("Inside Area for Triangle.");
       return dim1 * dim2 / 2;
     }


This chunk is called by <FindAreas SubClass Triangle >; see its first
definition at *note FindAreas-SubClass-Triangle-::.


File: JavaSE9.info,  Node: FindAreas Main Class Node,  Prev: FindAreas SubClass Triangle Node,  Up: Applying Method Overriding

4.6.2.4 FindAreas Main Class Section
....................................

<FindAreas Main Class > ==
     class FindAreas {
       <FindAreas Main Method Declaration >
     }


This chunk is called by {'FindAreas.java '}; see its first definition
at *note FindAreas-java-::.

The called chunk <FindAreas Main Method Declaration > is first defined
at *note FindAreas-Main-Method-Declaration-::.

FindAreas Main Method Declaration
.................................

<FindAreas Main Method Declaration > ==
     public static void main (String[] args[]) {
       <Create Basic Figure Objects >
       <Create Basic Figure Reference Variable >
       <Call Overridden Methods One By One >
     }


This chunk is called by <FindAreas Main Class >; see its first
definition at *note FindAreas-Main-Class-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Call Overridden          See
Methods One By One >      *note Call-Overridden-Methods-One-By-One-::.
<Create Basic Figure      See *note Create-Basic-Figure-Objects-::.
Objects >
<Create Basic Figure      See
Reference Variable >      *note Create-Basic-Figure-Reference-Variable-::.

Create Basic Figure Objects
...........................

<Create Basic Figure Objects > ==
     Figure f = new Figure(10, 10);
     Rectangle r = new Rectangle(9, 5);
     Triangle t = new Triangle(10, 8);


This chunk is called by <FindAreas Main Method Declaration >; see its
first definition at *note FindAreas-Main-Method-Declaration-::.

Create Basic Figure Reference Variable
......................................

This superclass reference variable 'Figure figref' will hold,
alternately, references to each of the classes and will call the
method 'area()' on each, producing a different result each time.  This
is the essence of method overriding and dynamic method dispatch.

<Create Basic Figure Reference Variable > ==
     Figure figref;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Main       See
Method Declaration >      *note AbstractAreas-Main-Method-Declaration-::.
<FindAreas Main Method    See
Declaration >             *note FindAreas-Main-Method-Declaration-::.

Call Overridden Methods One By One
..................................

<Call Overridden Methods One By One > ==
     figref = r;
     System.out.println("Area is " + figref.area());

     figref = t;
     System.out.println("Area is " + figref.area());

     figref = f;
     System.out.println("Area is " + figref.area());


This chunk is called by <FindAreas Main Method Declaration >; see its
first definition at *note FindAreas-Main-Method-Declaration-::.


File: JavaSE9.info,  Node: Using Abstract Classes,  Next: final with Inheritance,  Prev: Dynamic Method Dispatch,  Up: Inheritance

4.7 Using Abstract Classes
==========================

There are situations in which you will want to define a superclass
that declares the structure of a given abstraction without providing a
complete implementation of every method.  That is, sometimes you will
wnat to create a superclass that only defines a generalized form that
will be shared by all of its subclasses, leaving it to each subclass
to fill in the details.  Such a class determines the nature of the
methods that the subclasses must implement.  One way this situation
can occur is when a superclass is unable to create a meaningful
implementation for a method.  This is the case with 'Figure' in the
preceding example.  The definition of 'area()' is simply a
placeholder.  It will not compute and display the area of any type of
object.

   It is not uncommon for a method to have no meaningful definition in
the context of its superclass.  Java's solution to this problem is the
"abstract method".

   You can require that certain methods be overridden by subclasses by
specifying the 'abstract' type modifier.  These methods are sometimes
referred to as "subclasser responsibility" because they have no
implementation specified in the superclass.  Thus, a subclass must
override them -- it cannot simply use the version defined in the
superclass.

   To declare an abstract method, use the general form:

     abstract type name (parameter-list);

GeneralForm 4.4: Abstract Method Declaration--General Form

No method body is present.

   Any class that contains one or more abstract methods must also be
declared abstract.  To declare a class abstract, simply use the
'abstract' keyword in front of the 'class' keyword at the beginning of
the class declaration.  There can be no objects of an abstract class.
That is, an abstract class cannot be directlyi instantiated with the
'new' operator.  You cannot declare abstract constructors or abstract
static methods.  Any subclass of an abstract class must either
implement all of the abstract methods in the superclass, or be
declared 'abstract' itself.  Abstract classes can include fully
implemented methods.

Abstract Classes Can Be Reference Variables
===========================================

Although abstract classes cannot be used to instantiate objects, they
can be used to create object references, because Java's approach to
run-time polymorphism is implemented thruogh the use of superclass
references.  Thus, it must be possible to create a reference to an
asbtract class so that it can be used to point to a subclass object.

* Menu:

* Improved Figure Class::


File: JavaSE9.info,  Node: Improved Figure Class,  Up: Using Abstract Classes

4.7.1 Improved Figure Class
---------------------------

Using the abstract class, you can improve the 'Figure' class.  Since
there is no meaningful concept of area for an undefined
two-dimensional figure, the following version of the program declares
'area()' as abstract inside 'Figure'.  This means that all classes
derived from 'Figure' must override 'area()'.

{'AbstractAreas.java '} ==
     <AbstractAreas Abstract Class Figure >
     <FindAreas SubClass Rectangle >
     <FindAreas SubClass Triangle >
     <AbstractAreas Main Class >


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
<AbstractAreas Main       See *note AbstractAreas-Main-Class-::.
Class >
<FindAreas SubClass       See *note FindAreas-SubClass-Rectangle-::.
Rectangle >
<FindAreas SubClass       See *note FindAreas-SubClass-Triangle-::.
Triangle >

* Menu:

* AbstractAreas Abstract Class Figure Node::
* AbstractAreas Main Class::


File: JavaSE9.info,  Node: AbstractAreas Abstract Class Figure Node,  Next: AbstractAreas Main Class,  Up: Improved Figure Class

4.7.1.1 AbstractAreas Abstract Class Figure Section
...................................................

Notice that much of this class stays the same as the original 'Figure'
code, but includes two 'abstract' declarations, one for the class, and
one for the 'area()' method declaration.

<AbstractAreas Abstract Class Figure > ==
     abstract class Figure {
       <Figure Instance Variable Declarations >
       <Figure Constructor >
       <AbstractAreas Abstract Area Method Declaration >
     }


This chunk is called by {'AbstractAreas.java '}; see its first
definition at *note AbstractAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Area Method Declaration   *note AbstractAreas-Abstract-Area-Method-Declaration-::.
>
<Figure Constructor >     See *note Figure-Constructor-::.
<Figure Instance          See
Variable Declarations >   *note Figure-Instance-Variable-Declarations-::.

AbstractAreas Abstract Area Method Declaration
..............................................

<AbstractAreas Abstract Area Method Declaration > ==
     // areas is now an abstract method
     abstract double area ();


This chunk is called by <AbstractAreas Abstract Class Figure >; see
its first definition at *note AbstractAreas-Abstract-Class-Figure-::.


File: JavaSE9.info,  Node: AbstractAreas Main Class,  Prev: AbstractAreas Abstract Class Figure Node,  Up: Improved Figure Class

4.7.1.2 Abstract Main Class
...........................

<AbstractAreas Main Class > ==
     class AbstractAreas {
       <AbstractAreas Main Method Declaration >
     }


This chunk is called by {'AbstractAreas.java '}; see its first
definition at *note AbstractAreas-java-::.

The called chunk <AbstractAreas Main Method Declaration > is first
defined at *note AbstractAreas-Main-Method-Declaration-::.

AbstractAreas Main Method Declaration
.....................................

<AbstractAreas Main Method Declaration > ==
     public static void main (String[] args) {
       <Create Basic Figure Objects Except Figure >
       <Create Basic Figure Reference Variable >
       <Call Overridden Methods One By One Except Figure >
     }


This chunk is called by <AbstractAreas Main Class >; see its first
definition at *note AbstractAreas-Main-Class-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Call Overridden          See
Methods One By One        *note Call-Overridden-Methods-One-By-One-Except-Figure-::.
Except Figure >
<Create Basic Figure      See
Objects Except Figure >   *note Create-Basic-Figure-Objects-Except-Figure-::.
<Create Basic Figure      See
Reference Variable >      *note Create-Basic-Figure-Reference-Variable-::.

Create Basic Figure Objects Except Figure
.........................................

The only difference here is that because the superclass Figure is now
abstract, it cannot be instantiated using 'new'.  It can, however, be
used as a reference variable, and so the declaration 'Figure figref;'
is still valid and does not change from the prior implementation.
*This is the essence of run-time polymorphism and dynamic method
dispatch.*

<Create Basic Figure Objects Except Figure > ==
     // abstract class Figure cannot be instantiated
     // Figure f = new Figure (10, 10);
     Rectangle r = new Rectangle (9, 5);
     Triangle t = new Triangle (10, 8);


This chunk is called by <AbstractAreas Main Method Declaration >; see
its first definition at *note
AbstractAreas-Main-Method-Declaration-::.

Call Overridden Methods One By One Except Figure
................................................

The only difference here is that, because there is no 'Figure' object,
it cannot be referenced.

<Call Overridden Methods One By One Except Figure > ==
     figref = r;
     System.out.println("Area is " + figref.area());

     figref = t;
     System.out.println("Area is " + figref.aread());

     // there is no Figure object, so this will not work.
     // figref = f;


This chunk is called by <AbstractAreas Main Method Declaration >; see
its first definition at *note
AbstractAreas-Main-Method-Declaration-::.


File: JavaSE9.info,  Node: final with Inheritance,  Next: Object Class,  Prev: Using Abstract Classes,  Up: Inheritance

4.8 Using 'final' with Inheritance
==================================

The keyword 'final' has three uses.

  1. create the equivalent of a name constant.
  2. prevent overriding
  3. prevent inheritance

* Menu:

* final to Prevent Overriding::
* final to Prevent Inheritance::


File: JavaSE9.info,  Node: final to Prevent Overriding,  Next: final to Prevent Inheritance,  Up: final with Inheritance

4.8.1 Using 'final' to Prevent Overriding
-----------------------------------------

There will be times when you want to prevent overriding from
occurring.  To disallow a method from being overridden, specify
'final' as a modifier at the start of its declaration.  Methods
declared as 'final' cannot be overridden.

   Methods declared as 'final' can sometimes provide a performance
enhancement.  The compiler is free to "inline" calls to them because
it knows they will not be overridden by a subclass.  Inlining is an
option only with 'final' methods.  Normally, Java resolves calls to
methods dynamically, at run time.  This is called "late binding".
However, since 'final' methods cannot be overridden, a call to one can
be resolved at compile time.  This is called "early binding".


File: JavaSE9.info,  Node: final to Prevent Inheritance,  Prev: final to Prevent Overriding,  Up: final with Inheritance

4.8.2 Using 'final' to Prevent Inheritance
------------------------------------------

Sometimes you will want to prevent a class from being inherited.  To
do this, precede the class declaration with 'final'.  Declaring a
class as 'final' implicitly declares all of its methods as 'final'
also.


File: JavaSE9.info,  Node: Object Class,  Prev: final with Inheritance,  Up: Inheritance

4.9 The Object Class
====================

There is one special class, 'Object', defined by Java.  All other
classes are subclasses of 'Object'.  That is, 'Object' is a superclass
of all other classes.  This means that a reference variable of type
'Object' can refer to an object of any other class.  Also, since
arrays are implemented as classes, a variable of type 'Object' can
also refer to any array.

'Object' Methods
================

'Object' defines the following methods; this means they are available
in every object.

'Object clone()'
     Creates a new object that is the same as the object being cloned.
'boolean equals(Object object)'
     Determines whether one object is equal to another.
'void finalize()'
     Called before an unused object is recycled.  (Deprecated by JDK
     9).
'Class<?> getClass()'
     Obtains the class of an object at run time.
'int hashCode()'
     Returns the hash code associated with the invoking object.
'void notify()'
     Resumes execution of a thread waiting on the invoking object.
'void notifyAll()'
     Resumes execution of all threads waiting on the invoking object.
'String toString()'
     Returns a string that describes the object.
'void wait()'
'void wait(long milliseconds)'
'void wait(long millisconds, int nanoseconds)'
     Waits on another thread of execution

   The methods
   * 'getClass()'
   * 'notify()'
   * 'notifyAll()'
   * 'wait()'

are declared as 'final'.  You may override the others.

   However, notice two methods now:

'equals()'
     compares two objects; returns 'true' if the objects are equal,
     and 'false' if not; the precise definition of equality can vary,
     depending on the type of objects being compared.
'toString()'
     returns a string that contains a description of the object on
     which it is called; this method is automatically called when an
     object is output using 'println()'; many classes override this
     method; doing so allows them to tailor a description specifically
     for the types of objects that they create.


File: JavaSE9.info,  Node: Packages,  Next: Interfaces,  Prev: Inheritance,  Up: Top

5 Packages
**********

Packages are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file
names.  Packages are stored in a hierarchical manner and are
explicitly imported into new class definitions.

* Menu:

* Packages Intro::
* Defining Packages::
* Classpath::
* Member Access::
* Importing::


File: JavaSE9.info,  Node: Packages Intro,  Next: Defining Packages,  Up: Packages

5.1 Introduction to Packages
============================

Java provides a mechanism for partitioning the class namespace into
manageble chunks: the "PACKAGE". The package is both a naming and a
visibility control mechanism.  In other words, you can use the package
mechanism to define classes inside a package that are not accessible
by code outside the package; and you can define class members that are
exposed only to other members of the same package.


File: JavaSE9.info,  Node: Defining Packages,  Next: Classpath,  Prev: Packages Intro,  Up: Packages

5.2 Defining Packages
=====================

To create a package ("define" a package), include the 'package'
command as the first statement in a Java source file.  Thereafter, any
classes declared within that file will belong to the specified
package.  The 'package' statement defines a namespace in which classes
are stored.  Without the 'package' statement, classes are put into the
'default' package (which has no name).

General Form of 'package' statement
-----------------------------------

     package pkg

GeneralForm 5.1: Package Statement -- General Form

pkg is the name of the package.  For example:

     package mypackage;

File System Directories
-----------------------

Java uses the file system directories to store packages.  Therefore,
the '.class' files for any classes you declare to be part of
'mypackage' must be stored in a directory called 'mypackage'.  The
directory name must match the package name exactly.

   More than one file can include the same 'package' statement.  The
'package' statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other
files from being part of that same package.  Most real-world packages
are spread across many files.

Hierarchy of Packages
---------------------

You can create a hierarch of packages.  To do so, separate each
package name form the one above it by use of a period.  The general
form of a multileveled package statement is:

     package pkg1[.pkg2[.pkg3]]

GeneralForm 5.2: Package Statement -- Multilevel Form

   A package hierarchy must be reflected in the file system of your
Java development system.  For example a package declared as:

     package a.b.c;

   needs to be stored in directory 'a/b/c'.

   Be sure to choose package names carefully; you cannot rename a
package without renaming the directory in which the classes are
stored.


File: JavaSE9.info,  Node: Classpath,  Next: Member Access,  Prev: Defining Packages,  Up: Packages

5.3 Finding Packages and CLASSPATH
==================================

Packages are mirrored by directories.  How does the Java run-time
system know where to look for packages?

'cwd'
     By default, the Java run-time system uses the currect working
     directory as its starting point.  Thus, if your package is in a
     subdirectory of the current directory, it will be found.
'CLASSPATH'
     You can specify a directory path or paths by setting the
     'CLASSPATH' environment variable.
'-classpath'
     You can use the '-classpath' option with 'java' and 'javac' to
     specify the path to your classes.
module path
     Beginning with JDK 9, a package can be part of a module, and thus
     found on the 'module path'.

Example Finding a Package
-------------------------

Consider the following package specification:

     package mypack;

   In order for programs to find 'mypack', the program can be executed
from a directory *immediadely above* 'mypack', or the 'CLASSPATH' must
be set to include the path to 'mypack' or the '-classpath' option must
specify the path to 'mypack' when the program is run via 'java'.

   When the second or third of the above options is used, the 'class
path' *must not include* 'mypack' itself.  It must simply specify the
'path' to just above 'mypack'.  For example, if the path to 'mypack'
is

     /MyPrograms/Java/mypack

   then the class path to 'mypack' is

     /MyPrograms/Java


File: JavaSE9.info,  Node: Member Access,  Next: Importing,  Prev: Classpath,  Up: Packages

5.4 Packages and Member Access
==============================

Packages add another dimension to access control.  Classes and
packages are both means of encapsulating and containing the name space
and scope of variables and methods.  _Packages_ act as containiners
for classes and other subordinate packages.  _Classes_ act as
containers for data and code.  The class is Java's smallest unit of
abstraction.  As it relates to the interplay between classes and
packages, Java addresses four categories of visibility for class
members:

   * Subclasses in the same package
   * Non-subclasses in the same package
   * Subclasses in different packages
   * Classes that are neither in the same package nor subclasses

   The three access modifiers

   * private
   * public
   * protected

   provide a variaty of ways to produce many levels of access required
by these categories.

Category                     Private     None        Protected   public
-----------------------------------------------------------------------------
Same Class                   Yes         Yes         Yes         Yes
Same package subclass        No          Yes         Yes         Yes
Same package non-subclass    No          Yes         Yes         Yes
Different package subclass   No          No          Yes         Yes
Different package            No          No          No          Yes
noni-subclass

Table 5.1: Package Access Table -- Shows all combinations of the
access control modifiers


File: JavaSE9.info,  Node: Importing,  Prev: Member Access,  Up: Packages

5.5 Importing Packages
======================

Java includes the 'import' statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be
referred to directly, using only its name.  The 'import' statement is
a convenience to the programmer and is not technically needed to write
a complete Java program.

   In a Java source file, 'import' statements occur immediately
following the 'package' statement (if one exists) and before any class
definitions.  This is the general form of the 'import' statement:

     import pkg1[.pkg2].(classname | *);

GeneralForm 5.3: Import Statement -- General Form

   Here, pkg1 is the name of a top-level package, and pkg2 is the name
of a subordinate package inside the outerpackage separated by a dot
(.).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit 'classname' or a star (*), which
indicates that the Java compiler should import the entire package.

     import java.util.Date;
     imort java.io.*;

   All of the standard Java SE classes included with Java begin with
the name 'java'.  The basic language functions are stored in a package
called 'java.lang'.  Normally, you have to import every package or
class that you want to use, but since Java is useless without much of
the functionality in 'java.lang', it is implicitly imported by the
compiler for all programs.  This is equivalent to the following line
being at the top of all your programs:

     import java.lang.*;

   The 'import' statement is _optional_.  Any place you use a class
name, you can use its _fully qualified name_, which includes its full
package hierarchy.

   When a package is imported, only those items within the package
declared as 'public' will be available to non-subclasses in the
importing code.


File: JavaSE9.info,  Node: Interfaces,  Next: I/O,  Prev: Packages,  Up: Top

6 Interfaces
************

Using the keyword 'interface', you can fully abstract a class'
interface from its implementation.  That is, using 'interface', you
can specify what a class must do, but not how to do it.  Interfaces
are syntactically similar to classes, but they lack instance
variables, and, as a general rule, their methods are declared without
any body.  Once it is defined, any number of classes can implement an
'interface'.  Also, one class can implement any number of interfaces.
To implement an interfce, a class must provide the complete set of
methods required by the interface.  Each class is free to determine
the details of its own implementation.  By providing the 'interface'
keyword, Java allws you to fully utilize the "one interface, multiple
methods" aspect of polymorphism.

   Interfaces are designed to support "dynamic method resolution" at
run time.  Normally, in order for a method to be called from one class
to another, both classes need to be present at compile time so the
Java compiler can check to ensure that the method signatures are
compatible.  This requirement by itself makes for a static and
nonextensible classing environment.  Inevitably in a system like this,
functionality gets pushed up higher and higher in the class hierarchy
so that the mechanisms will be available to more and more subclasses.
Interfaces are designed to avoid this problem.  _They disconnect the
definition of a method or set of methods from the inheritance
hierarchy._  Since interfaces are in a different hierarchy from
classes, it is possible for classes that are unrelated in terms of
class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.

* Menu:

* Defining Interfaces::
* Implementing Interfaces::
* Interface References::
* Partial Implementations::
* Nested Interfaces::
* Applying Interfaces::
* Variables in Interfaces::
* Extending Interfaces::
* Default Interface Methods::
* Interface Static Methods::
* Private Interface Methods::


File: JavaSE9.info,  Node: Defining Interfaces,  Next: Implementing Interfaces,  Up: Interfaces

6.1 Defining Interfaces
=======================

An interface is defined much like a class.  Here is a simplified
general form of an interface definition:

     access interface name {
       return-type method-name1(parameter-list);
       return-type method-name2(parameter-list);

       type final-varname1 = value
       type final-varname2 = value
       ...
       return-type method-nameN(parameter-list);
       type final-varnameN = value
     }

GeneralForm 6.1: Interface Definition -- Simplified General Form

   When no access modifier is included, then default access results,
and the interface is only available to other members of the package in
which it is declared.  When it is declared as 'public', the interface
can be used by code outside its package.  In this case, the interface
mst be the only public interface declared in the file, and the file
must have the same name as the interface.  The methods that are
declared have no bodies.  They end with a semicolon after the
parameter list.  They are, essentially, abstract methods.  Each class
that includes such an interface must implement all of the methods.

Variable Declarations inside Interfaces
---------------------------------------

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly 'final' and 'static', meaning they
cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly 'public'.


File: JavaSE9.info,  Node: Implementing Interfaces,  Next: Interface References,  Prev: Defining Interfaces,  Up: Interfaces

6.2 Implementing Interfaces
===========================

Once an interface has been defined, one or more classes can implement
that interface.  To implement an interface, include the 'implements'
clause in a class definition, and then create the methods required by
the interface.  The general form of a class that includes the
'implements' clause looks like this:

     class clasname [extends superclass] [implements interface [,interface...] {
       class-body
     }

GeneralForm 6.2: Class Implementing Interface -- General Form

   The methods that implement an interface must be declared 'public'.
The type signature of the implementing method must match exactly the
type signature specified in the 'interface' definition.

   It is both permissible and common for classes that implement
interfaces to define additional members of their own.


File: JavaSE9.info,  Node: Interface References,  Next: Partial Implementations,  Prev: Implementing Interfaces,  Up: Interfaces

6.3 Accessing Implementations Through Interface References
==========================================================

You can declare variables as object references that use an interface
rather than a class type.  Any instance of any class that implements
the declared interface can be referred to by such a variable.  When
you call a method through one of these references, the correct version
will be called based on the actual instance of the interface being
referred to.  This is one of the key features of interfaces.  The
method to be executed is looked up dynamically at run-time, allowing
classes to be created later than the code which calls methods on them.
The calling code can dispatch through an interface without having to
know anything about the "callee."  This process is similar to using a
superclass reference to access a subclass object.


File: JavaSE9.info,  Node: Partial Implementations,  Next: Nested Interfaces,  Prev: Interface References,  Up: Interfaces

6.4 Partial Implementations
===========================

If a class includes an interface but does not implement the methds
required by that interface, then that class must be declared as
'abstract'.  Any class that inherits the abstract class must implement
the interface or be declared 'abstract' itself.


File: JavaSE9.info,  Node: Nested Interfaces,  Next: Applying Interfaces,  Prev: Partial Implementations,  Up: Interfaces

6.5 Nested Interfaces
=====================

An interface can be declared a member of a class or another interface.
Such an interface is called a "member interface" or a "nested
interface".  A nested interface can be declared as 'public',
'private', or 'protected'.  This differs from a top-level interface,
which must either be declared as 'public' or use the default access
level.  When a nexted interface is used outside of its enclosing
scope, it must be qualified by the name of the class or interface of
which it is a member.  Thus, outside of the class or interface in
which a nested interface is declared, its name must be fully
qualified.


File: JavaSE9.info,  Node: Applying Interfaces,  Next: Variables in Interfaces,  Prev: Nested Interfaces,  Up: Interfaces

6.6 Applying Interfaces
=======================

See detailed example ...


File: JavaSE9.info,  Node: Variables in Interfaces,  Next: Extending Interfaces,  Prev: Applying Interfaces,  Up: Interfaces

6.7 Variables in Interfaces
===========================

You can use interfaces to import shared constants into multiple
classes by simply declaring an interface that contains variables that
are initialized to the desired values.  When you include that
interface in a class (when you "implement" the interface), all of
those variable names will be in scope as constants.  If an interface
contains no methods, then any class that includes such an interface
doesn't actually implement anything.  It is as if that class were
importing this constant fields into the class name space as 'final'
variables.


File: JavaSE9.info,  Node: Extending Interfaces,  Next: Default Interface Methods,  Prev: Variables in Interfaces,  Up: Interfaces

6.8 Interfaces Can Be Extended
==============================

One interface can inherit another by use of the keyword 'extends'.
The syntax is the same as for inheriting classes.  When a class
implements an interface that inherits another interface, it must
provide implementations for all methods required by the interface
inheritance chain.


File: JavaSE9.info,  Node: Default Interface Methods,  Next: Interface Static Methods,  Prev: Extending Interfaces,  Up: Interfaces

6.9 Default Interface Methods
=============================

Prior to JDK 8, an interface could not define any implementation
whatsoever.  This meant that for all previous versions of Java, the
methods specified by an interface were abstract, constaining no body.
This is the traditional form of an interface.  The release of JDK 8
changed this by adding a new capability to 'interface' called the
"default method".  A default method lets you define a default
implementation for an interface method.  It is possible for an
interface method to provide a body, rather than being abstract.

   A primary motivation for the default method was to provide a means
by which interfaces could be expanded without breaking existing code.
There must be implementations for all methods defined by an interface.
If a new method were added to a popular, widely used interface, then
the addition of that method would break existing code because no
implementation would be found for that new method.  The default method
solves this problem by supplying an implementation that willbe used if
no other implementation is explicitly provided.  Thus, the addition of
a default method will not cause preexisting code to break.

   Another motivation for the default method was the desire to specify
methods in an interface that are, essentially, optional, depending on
how the interface is used.

Interfaces Do No Maintain State and Cannot Be Created
-----------------------------------------------------

It is important to point out that the addition of default methods does
not change a key aspect of 'interface': its inability to maintain
state information.  An interface still cannot have instance variables,
for example.  Thus, *the defining difference between an interface and
a class is that a class can maintain state information, but an
interface cannot.*  Furthermore, it is still not possible to create an
instance of an interface by itself.  It must be implemented by a
class.


File: JavaSE9.info,  Node: Interface Static Methods,  Next: Private Interface Methods,  Prev: Default Interface Methods,  Up: Interfaces

6.10 Use Static Methods in an Interface
=======================================

Another capability added to interface by JDK 8 is the ability to
define one or more 'static' methods.  Like 'static' methods in a
class, a 'static' method defined by an interface can be called
independently of any object.  Thus, no implementation of the interface
is necessary, and no instance of the interface is required, in order
to call a 'static' method.  Instead, a 'static' method is called by
specifying the interface name, followed by a period, followed by the
method name.  Here is the general form:

     InterfaceName.staticMethodName

GeneralForm 6.3: Interface Static Method, Calling

   Notice that this is similar to the way that a 'static' method in a
class is called.  However, 'static' interface methods are not
inherited by either an implementing class or a subinterface.


File: JavaSE9.info,  Node: Private Interface Methods,  Prev: Interface Static Methods,  Up: Interfaces

6.11 Private Interface Methods
==============================

Beginning with JDK 9, an interface can include a private method.  A
private interface method can be called only by a default method or
another private method defined by the same interface.  Because a
private interface method is specified 'private', it cannot be used by
code outside the interface in which it is defined.  This restriction
includes subinterfaces because a private inteface method is not
inherited by a subinterface.

   The key benefit of a private interface method is that it lets two
or more default methods use a common piece of code, thus avoiding code
duplication.


File: JavaSE9.info,  Node: I/O,  Next: Generics,  Prev: Interfaces,  Up: Top

7 I/O
*****

This chapter introduces 'java.io', which supports Java's basic
input/output system, including file I/O. Support for I/O comes from
Java's core API libraries, not from language keywords.  In this
chapter the foundation of this subsystem is introduced so that you can
see how it fits into the larger context of the Java programming and
execution environment.

   This chapter also looks at the 'try-with-resources' statement and
several more Java keywords:

   * 'volatile'
   * 'instanceof'
   * 'native'
   * 'strictfp'
   * 'assert'

* Menu:

* I/O Basics::
* Reading Console Input::
* Writing Console Output::
* PrintWriter Class::
* Reading and Writing Files::
* Automatically Closing Files::
* transient and volatile Modifiers::
* Using instanceof::
* strictfp::
* Native Methods::
* Using assert::
* Static Import::
* Overloaded Constructors with this::
* Compact API Profiles::


File: JavaSE9.info,  Node: I/O Basics,  Next: Reading Console Input,  Up: I/O

7.1 I/O Basics
==============

Most real applications of Java are not text-based, console programs.
Rather, they are either graphically oriented programs that rely on one
of Java's graphical user interface (GUI) frameworks, such as Swing,
the AWT, or JavaFX, for user interaction, or they are Web
applications.  Text-based console programs do not constitute an
important use for Java in the real world.  Java's support for console
I/O is limited and somewhat awkword to use.  Text-based console I/O is
just not that useful in real-world Java programming.

   Java does, however, provide strong, flexible support for I/O as it
relates to files and networks.  Java's I/O system is cohesive and
consistent.  A general overview of I/O is presented here.  A detailed
description is found in chapters describing the Java Library: *Note
java io Input Output:: and *Note NIO::.

* Menu:

* Streams::
* Byte Streams Character Streams::


File: JavaSE9.info,  Node: Streams,  Next: Byte Streams Character Streams,  Up: I/O Basics

7.1.1 Streams
-------------

Java programs perform I/O through streams.  A "stream" is an
abstraction that either produces or consumes information.  A stream is
linked to a physical device by the Java I/O system.  All streams
behave in the same manner, even if the actual physical device to which
they are linked differ.  Thus, the same I/O classes and methods can be
applied to different types of devices.  This means that an input
stream can abstract many different kinds of input; from a disk file, a
keyboard, or a network socket.  Likewise, an output stream may refer
to the console, a disk file, or a network connection.  Java implements
streams within class hierarchies defined in the 'java.io' package.


File: JavaSE9.info,  Node: Byte Streams Character Streams,  Prev: Streams,  Up: I/O Basics

7.1.2 Byte Streams and Character Streams
----------------------------------------

Java defines two types of streams:

   * byte streams
   * character streams

   "Byte streams" provide a convenient means for handling input and
output of bytes.  Byte streams are used when reading or writing binary
data.  "Character streams" provide a convenient means for handling
input and output of characters.  They use Unicode and therefore can be
internationalized.  In some cases, character streams are more
efficient than byte streams.

   The original version of Java (Java 1.0) did not include character
streams and thus all I/O was byte-oriented.  Character streams were
added by Java 1.1 and certain byte-oriented classes and methods were
deprecated.

   At the lowest level, all I/O is still byte-oriented.  The
character-based streams simply provide a convenient and efficient
means for handling characters.

* Menu:

* Byte Stream Class::
* Character Stream Class::
* Predefined Streams::


File: JavaSE9.info,  Node: Byte Stream Class,  Next: Character Stream Class,  Up: Byte Streams Character Streams

7.1.2.1 The Byte Stream Class
.............................

Byte streams are defined by using two class hierarchies.  At the top
are two abstract classes:

   * 'InputStream'
   * 'OutputStream'

   Each of these abstract classes has several concrete subclasses that
handle the differences among various devices, such as disk files,
network connnections, and memory buffers.  The byte stream classes in
'java.io' are shown in *note Table 7.1: ByteStreamClasses.

   To use the stream classes, you must import 'java.io'.

'BufferedInputStream'
'BufferedOutputStream'
     Buffered input and output streams
'ByteArrayInputStream'
'ByteArrayOutputStream'
     Input and Output streams that read from and write to a byte array
'DataInputStream'
'DataOutputStream'
     Input and Output streams that contain methods for reading and
     writing the Java standard data types
'FileInputStream'
'FileOutputStream'
     Input and Output streams that read from and write to a file
'FilterInputStream'
'FilterOutputStream'
     Implements 'InputStream' and 'OutputStream'
'InputStream'
'OutputStream'
     Abstract classes that describe stream input and output
'ObjectInputStream'
'ObjectOutputStream'
     Input and Output streams for objects
'PipedInputStream'
'PipedOutputStream'
     Input and Output pipe
'PrintStream'
     Output stream that contains 'print()' and 'println()'
'PushbackInputStream'
     Input stream that allows bytes to be returned to the input stream
'SequenceInputStream'
     Input stream that is a combination of two or more input streams
     that will be read sequentially, one after the other

Table 7.1: The Byte Stream Classes in 'java.io'

   The abstract classes 'InputStream' and 'OutputStream' define
several key methods that the other stream classes implement.  Two of
the most important are:

   * 'read()'
   * 'write()'

which respectively read and write bytes of data.  Each has a form that
is abstract and must be overridden by derived stream classes.


File: JavaSE9.info,  Node: Character Stream Class,  Next: Predefined Streams,  Prev: Byte Stream Class,  Up: Byte Streams Character Streams

7.1.2.2 The Character Stream Class
..................................

Character streams are defined by using two class hierarchies.  At the
top are two abstract classes:

   * 'Reader'
   * 'Writer'.

   These abstract classes handle Unicode character streams.  Java has
several concrete subclasses of these.  The character stream classes in
'java.io' are shown in *note Table 7.2: CharacterStreamClasses.

'BufferedReader'
'BufferedWriter'
     Buffered input and output character streams
'CharArrayReader'
'CharArrayWriter'
     Input and Output streams that read and write to and from a
     character array
'FileReader'
'FileWriter'
     Input and Output streams that read from and write to a file
'FilterReader'
'FilterWriter'
     Filtered read and writer
'InputStreamReader'
'OutputStreamWriter'
     Input and Output streams that translate bytes to characters
'LineNumberReader'
     Input stream that counts lines
'PipedReader'
'PipedWriter'
     Input and Output pipes
'PrintWriter'
     Output stream that contains 'print()' and 'println()'
'PushbackReader'
     Input stream that allows characters to be return to the input
     stream
'Reader'
'Writer'
     Abstract clases tha describe character stream input and output
'StringReader'
'StringWriter'
     Input and output streams that read from and write to a string

Table 7.2: The Character Stream I/O Classes in 'java.io'

   The abstract classes 'Reader' and 'Writer' define several key
methods that the other stream classes implement.  Two of the most
important methods are:

   * 'read()'
   * 'write()'

which read and write characters of data, respectively.  Each has a
form that is abstract and must be overridden by derived stream
classes.


File: JavaSE9.info,  Node: Predefined Streams,  Prev: Character Stream Class,  Up: Byte Streams Character Streams

7.1.2.3 The Predefined Streams
..............................

The 'java.lang' package defines a class called 'System', which
encapsulates several aspects of the run-time environment.  System
contains three predefined stream variables:

  1. 'in' (standard input), an object of type 'InputStream'
  2. 'out' (standard output), an object of type 'PrintStream'
  3. 'err' (standard error), an object of type 'PrintStream'

These fields are declared as 'public', 'static', and 'final' within
'System'.  This means that they can be used by any other part of your
program and without reference to a specific 'System' object.  While
these are all byte streams, they can be wrapped within character-based
streams, if desired.


File: JavaSE9.info,  Node: Reading Console Input,  Next: Writing Console Output,  Prev: I/O Basics,  Up: I/O

7.2 Reading Console Input
=========================

For commercial applications, the preferred method of reading console
input is to use a character-oriented stream.  This makes your program
easier to internationalize and maintain.

'System.in' Wrapped in 'BufferedReader'
---------------------------------------

Console input is accomplished by reading from 'System.in' To obtain a
character-based stream that is attached to the console, wrap
'System.in' in a 'BufferedReader' object.  'BufferedReader' supports a
buffered input stream.  A commonly-used constructor is:

     BufferedReader(Reader inputReader)

Here, inputReader is the stream that is linked to the instance of
'BufferedReader' that is being created.  'Reader' is the abstract
class.  One of its concrete subclasses is 'InputStreamReader', which
converts bytes to characters.  To obtain a 'InputStreamReader' object
that is linked to 'System.in', use the following constructor:

     InputStreamReader(InputStream inputStream)

   Because 'System.in' refers to an object of type 'InputStream', it
can be used for inputStream.  Putting it all together, the following
line of code creates a 'BufferedReader' that is connected to the
keyboard:

     BufferedReader br = new BufferedReader(
       new InputStreamReader(System.in));

After this statement executes, 'br' is a character-based stream that
is linked to the console through 'System.in'.

* Menu:

* Reading Characters::
* Reading Strings::


File: JavaSE9.info,  Node: Reading Characters,  Next: Reading Strings,  Up: Reading Console Input

7.2.1 Reading Characters
------------------------

To read a character from a 'BufferedReader', use 'read()'.  The
version of 'read()' that we will be using is

     int read() throws IOException

Each time that 'read()' is called, it reads a character from the input
stream and returns it as an integer value.  (1) It returns -1 when an
attempt is made to read at the end of the stream.  It can throw an
'IOException'.

Program Demonstrating Reading Characters from Console
.....................................................

The following program demonstrates 'read()' by reading characters from
the console until the user types a "q".  Any I/O exceptions that might
be generated are simply thrown out of 'main()'.  In more sophisticated
applications, you can handle the exceptions explicitly.

{'BRRead.java'} ==
     <Import java.io>
     class BRRead {
       public static void main(String[] args[]) throws IOException {
         <BRRead BufferedReader Constructor>
         <BRRead Enter Characters>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BRRead BufferedReader    See
Constructor>              *note BRRead-BufferedReader-Constructor::.
<BRRead Enter             See *note BRRead-Enter-Characters::.
Characters>
<Import java.io>          See *note Import-java-io::.

* Menu:

* Import java.io::
* BRRead BufferedReader Constructor Node::
* BRRead Enter Characters Node::

   ---------- Footnotes ----------

   (1) Note that 'System.in' is line buffered by default; this means
that no input is actually passed to the program until the user presses
<enter>.  This does not make 'file' particularly valuable for
interactive console input.


File: JavaSE9.info,  Node: Import java.io,  Next: BRRead BufferedReader Constructor Node,  Up: Reading Characters

7.2.1.1 Import 'java.io'
........................

<Import java.io> ==
     import java.io.*;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'BRRead.java'}           See *note BRRead-java::.
{'BRReadLines.java'}      See *note BRReadLines-java::.


File: JavaSE9.info,  Node: BRRead BufferedReader Constructor Node,  Next: BRRead Enter Characters Node,  Prev: Import java.io,  Up: Reading Characters

7.2.1.2 BRRead BufferedReader Constructor Section
.................................................

<BRRead BufferedReader Constructor> ==
     BufferedReader br = new BufferedReader(
       new InputStreamReader(System.in));


This chunk is called by {'BRRead.java'}; see its first definition at
*note BRRead-java::.


File: JavaSE9.info,  Node: BRRead Enter Characters Node,  Prev: BRRead BufferedReader Constructor Node,  Up: Reading Characters

7.2.1.3 BRRead Enter Characters Section
.......................................

<BRRead Enter Characters> ==
     char c;
     do {
       c = (char) br.read();
       System.out.println(c);
     } while (c != 'q');


This chunk is called by {'BRRead.java'}; see its first definition at
*note BRRead-java::.


File: JavaSE9.info,  Node: Reading Strings,  Prev: Reading Characters,  Up: Reading Console Input

7.2.2 Reading Strings
---------------------

To read a string frmo the keyboard, use the version of 'readLine()'
that is a member of the 'BufferedReader' class.  Its general form is:

     String readLine() throws IOException

It returns a 'String' object.

Program Demonstrating Reading a String from Console
...................................................

The following program demonstrates 'BufferedReader' and the
'readLine()' method; the program reas and displays lines of text until
the word "stop" is entered.

{'BRReadLines.java'} ==
     <Import java.io>

     class BRReadLines {
       public static void main(String[] args) throws IOException {
         <BRReadLines BufferedReader Constructor>
         <BRReadLines Enter Lines>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BRReadLines              See
BufferedReader            *note BRReadLines-BufferedReader-Constructor::.
Constructor>
<BRReadLines Enter        See *note BRReadLines-Enter-Lines::.
Lines>
<Import java.io>          See *note Import-java-io::.

* Menu:

* BRReadLines BufferedReader Constructor::
* BRReadLines Enter Lines::


File: JavaSE9.info,  Node: BRReadLines BufferedReader Constructor,  Next: BRReadLines Enter Lines,  Up: Reading Strings

7.2.2.1 BRReadLines BufferedReader Constructor
..............................................

<BRReadLines BufferedReader Constructor> ==
     // create a BufferedReader using System.in
     BufferedReader br = new BufferedReader(
       new InputStreamReader(System.in))


This chunk is called by {'BRReadLines.java'}; see its first definition
at *note BRReadLines-java::.


File: JavaSE9.info,  Node: BRReadLines Enter Lines,  Prev: BRReadLines BufferedReader Constructor,  Up: Reading Strings

7.2.2.2 BRReadLines Enter Lines
...............................

<BRReadLines Enter Lines> ==
     String str;

     System.out.println("Enter lines of text.");
     System.out.println("Enter 'stop' to quit.");

     do {
       str = br.readLine();
       System.out.println(str);

     } while (!str.equals("stop"));


This chunk is called by {'BRReadLines.java'}; see its first definition
at *note BRReadLines-java::.


File: JavaSE9.info,  Node: Writing Console Output,  Next: PrintWriter Class,  Prev: Reading Console Input,  Up: I/O

7.3 Writing Console Output
==========================


File: JavaSE9.info,  Node: PrintWriter Class,  Next: Reading and Writing Files,  Prev: Writing Console Output,  Up: I/O

7.4 The PrintWriter Class
=========================


File: JavaSE9.info,  Node: Reading and Writing Files,  Next: Automatically Closing Files,  Prev: PrintWriter Class,  Up: I/O

7.5 Reading and Writing Files
=============================


File: JavaSE9.info,  Node: Automatically Closing Files,  Next: transient and volatile Modifiers,  Prev: Reading and Writing Files,  Up: I/O

7.6 Automatically Closing Files
===============================


File: JavaSE9.info,  Node: transient and volatile Modifiers,  Next: Using instanceof,  Prev: Automatically Closing Files,  Up: I/O

7.7 The 'transient' and 'volative' Modifiers
============================================


File: JavaSE9.info,  Node: Using instanceof,  Next: strictfp,  Prev: transient and volatile Modifiers,  Up: I/O

7.8 Using 'instanceof'
======================


File: JavaSE9.info,  Node: strictfp,  Next: Native Methods,  Prev: Using instanceof,  Up: I/O

7.9 'strictfp'
==============


File: JavaSE9.info,  Node: Native Methods,  Next: Using assert,  Prev: strictfp,  Up: I/O

7.10 Native Methods
===================


File: JavaSE9.info,  Node: Using assert,  Next: Static Import,  Prev: Native Methods,  Up: I/O

7.11 Using 'assert'
===================


File: JavaSE9.info,  Node: Static Import,  Next: Overloaded Constructors with this,  Prev: Using assert,  Up: I/O

7.12 Static Import
==================


File: JavaSE9.info,  Node: Overloaded Constructors with this,  Next: Compact API Profiles,  Prev: Static Import,  Up: I/O

7.13 Invoking Overloaded Constructors Through 'this()'
======================================================


File: JavaSE9.info,  Node: Compact API Profiles,  Prev: Overloaded Constructors with this,  Up: I/O

7.14 Compact API Profiles
=========================


File: JavaSE9.info,  Node: Generics,  Next: Enumerations,  Prev: I/O,  Up: Top

8 Generics
**********

"Generics", introduced in J2SE 5.0, allows a type or method to operate
on objects of various types while providing compile-time type safety.
It adds compile-time type safety to the Collections Framework and
eliminates the need of casting.  In other words, generics allow you to
abstract over types.

   Through the use of generics, it is possible to create classes,
interfaces, and methods that will work in a type-safe manner with
various kinds of data.  Many algorithms are logically the same no
matter what type of data they are being applied to.  For example, the
mechanism that supports a stack is the same whether that stack is
storing items of type 'Integer', 'String', 'Object', or 'Thread'.
With generics, you can define an algorithm once, independently of any
specific type of data, and then apply that algorithm to a wide variety
of data types without any additional effort.

   Perhaps the one feature of Java that has been most significantly
affected by generics is the 'Collections Framework'.  A "collection"
is a group of objects.  The Collections Framework defines several
classes, such as lists and maps, that manage collections.  The
collection classes have always been able to work with any type of
object.  The benefit that generics adds is that the collection classes
can now be used with complete type safety.

   This chapter describes the syntax, theory, and use of generics.  It
also shows how generics provide type safety for some previously
difficult cases.

* Menu:

* Motivation::
* What are Generics::
* Simple Generics Example::
* Notes about Generics::
* Two Type Parameters::
* Generic Class General Form::
* Bounded Types::
* Wildcard Arguments::
* Generic Methods::
* Generic Constructors::


File: JavaSE9.info,  Node: Motivation,  Next: What are Generics,  Up: Generics

8.1 Motivation for Generics
===========================

Code Fragment Without Generics
------------------------------

Here is a typical code fragment abstracting over types by using
'Object' and type casting.

     List myIntList = new LinkedList(); // 1
     myIntList.add(new Integer(0)); // 2
     Integer x = (Integer) myIntList.iterator().next(); // 3

   The cast on line 3 is annoying, although essential.  The compiler
can guarantee only that an 'Object' will be returned by the iterator.
This therefore adds both clutter and the possibility of a run-time
error.

Code Fragment with Generics
---------------------------

Generics allow a programmer to mark their intent to restrict a list to
a particular data type.  Here is a version of the same code that uses
generics.

     List<Integer> myIntList = new LinkedList<Integer>(); // 1'
     myIntList.add(new Integer(0)); // 2'
     Integer x = myIntList.iterator().next(); // 3'

   In line 1, the type declaration for the variable 'myIntList'
specifies that it is to hold a 'List' of 'Integer's: 'List<Integer>'.
'List' is a "generic interface" that takes a "type parameter"
('Integer').  The type parameter is also specified when creating the
'List' object ('new LinkedList<Integer>()').  Also, the cast on line 3
is gone.

   So has this just moved the clutter around, from a type cast to a
type parameter?  No, because this has given the compiler the ability
to check the type correctness of the program _at compile-time_.  When
we say that 'myIntList' is declared with type 'List<Integer>', this
tells us something about the variable 'myIntList', which holds true
wherever and whenever it is used, and the compiler will guarantee it.
In contrast, the cast tells us something the programmer thinks is true
at a single point in the code.

   The net effect, especially in large programs, is improved
readability and robustness.


File: JavaSE9.info,  Node: What are Generics,  Next: Simple Generics Example,  Prev: Motivation,  Up: Generics

8.2 What Are Generics
=====================

The term "generics" means parameterized types.  Parameterized types
are important because they enable you to create classes, interfaces,
and methods in whicht the type of data upon which they operate is
specified as a parameter.  Using generics, it is possible to create a
single class, for example, that automatically works with different
types of data.  A class, interface, or method that operates on a
parameterized type is called "generic", as in generic class or generic
method.

   Java has always given the ability to create generalized classes,
interfaces, and methods by operating through references of type
'Object'.  Generics added the type safety that was lacking.  They also
streamlined the process, because it is no longer necessary to
explicitly employ casts to translate between 'Object' and the type of
data that is being operate upon.  Wtih generics, all casts are
automatic and implicit.


File: JavaSE9.info,  Node: Simple Generics Example,  Next: Notes about Generics,  Prev: What are Generics,  Up: Generics

8.3 A Simple Generics Example
=============================

The following program defines two classes.  The first is the generic
class 'Gen', and the second is 'GenDemo', which uses 'Gen'.

{'SimpleGenerics.java'} ==
     <Class Gen>
     <Class GenDemo>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class Gen>               See *note Class-Gen::.
<Class GenDemo>           See *note Class-GenDemo::.

* Menu:

* Class Gen<T>::
* Class GenDemo::


File: JavaSE9.info,  Node: Class Gen<T>,  Next: Class GenDemo,  Up: Simple Generics Example

8.3.1 Class Gen<T>
------------------

This is a simple generic class.  The class 'Gen' is declared with a
parameter of '<T>':

     class Gen<T> {

   'T' is the name of a "type parameter".  This name is used as a
placeholder for the actual type that will be passed to 'Gen' when an
object is created.  Thus, 'T' is used within 'Gen' whenever the type
parameter is needed.

   Notice that 'T' is contained within '< >'.  This syntax can be
generalized.  Whenever a type parameter is being declared, it is
specified within angle brackets.

   Because 'Gen' uses a type parameter, 'Gen' is a _generic class_,
which is also called a _parameterized type_.

Outline of Class Gen<T>
.......................

Class 'Gen' contains four parts:

   * an instance variable declaration
   * a constructor
   * a method returning the instance variable
   * a method describing the type of the instance variable

<Class Gen> ==
     class Gen<T> {
       <Instance Variable ob of Type T>
       <Constructor taking parameter of Type T>
       <Method returning object of type T>
       <Method showing type of T>
     }

This chunk is called by {'SimpleGenerics.java'}; see its first
definition at *note SimpleGenerics-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Constructor taking       See
parameter of Type T>      *note Constructor-taking-parameter-of-Type-T::.
<Instance Variable ob     See *note Instance-Variable-ob-of-Type-T::.
of Type T>
<Method returning         See
object of type T>         *note Method-returning-object-of-type-T::.
<Method showing type of   See *note Method-showing-type-of-T::.
T>

Implementation of Class Gen<T>
..............................

'T' is used to declare an object called 'ob'.  'T' is a placeholder
for the actual type that will be specified when a 'Gen' object is
created.  Thus, 'ob' will be an object of the type passed to 'T'.

<Instance Variable ob of Type T> ==
     T ob;   // declare an object of type T


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

The Constructor
...............

Here is the constructor for 'Gen'.  Notice that its parameter, 'o', is
of type 'T'.  This means that the actual type of 'o' is determined by
the type passed to 'T' when a 'Gen' object is created.  Because both
the parameter 'o' and the member variable 'ob' are of type 'T', they
will both be the same actual type when a 'Gen' object is created.

<Constructor taking parameter of Type T> ==
     // Pass the constructor a reference to
     // an object of type T
     Gen (T o) {
       ob = o;
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

Instance Methods 'getob()' and 'showType()'
...........................................

The type parameter 'T' can also be used to specify the return type of
a method, as here in 'getob()'.  Because 'ob' is also of type 'T', its
type is compatible wih the return type specified by 'getob()'.

<Method returning object of type T> ==
     // Return ob
     T getob() {
       return ob;
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

   The method 'showType()' displays the type of 'T' by calling
'getName()' on the 'Class' object return by the call to 'getClass()'
on 'ob'.  The 'getClass()' method is defined by 'Object' and is thus a
member of _all_ class types.  It returns a 'Class' object that
corresponds to the type of the class of the object on which it is
called.  'Class' defines the 'getName()' method, which returns a
string representation of the class name.

<Method showing type of T> ==
     // Show type of T
     void showType() {
       System.out.println("Type of T is " + ob.getClass().getName();
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.


File: JavaSE9.info,  Node: Class GenDemo,  Prev: Class Gen<T>,  Up: Simple Generics Example

8.3.2 Class GenDemo
-------------------

The 'GenDemo' class demonstrates the generic 'Gen' class.

   But first, take note: The Java compiler does not actually create
different versions of 'Gen', or of any other generic class.  The
compiler removes all generic type information, substituting the
necessary casts, to make your code *behave as if* a specific version
of 'Gen' were created.  There is really only one version of 'Gen' that
actually exists.

   The process of removing generic type information is called "type
erasure".

   'GenDemo' first creates a version of 'Gen' for integers and calls
the methods defined in 'Gen' on it.  It then does the same for a
String object.

<Class GenDemo> ==
     // Demonstrate the generic class
     class GenDemo {
       public static void main(String args[]) {
         <Create a Gen object for Integers>
         <Create a Gen object for Strings>
       }
     }


This chunk is called by {'SimpleGenerics.java'}; see its first
definition at *note SimpleGenerics-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Create a Gen object      See
for Integers>             *note Create-a-Gen-object-for-Integers::.
<Create a Gen object      See *note Create-a-Gen-object-for-Strings::.
for Strings>

* Menu:

* GenDemo as Integer::
* GenDemo as String::


File: JavaSE9.info,  Node: GenDemo as Integer,  Next: GenDemo as String,  Up: Class GenDemo

8.3.2.1 Implementation of Class GenDemo with Type Integer
.........................................................

<Create a Gen object for Integers> ==
     <Integer Type Parameter>
     <Reference to Integer Instance>
     <Show Type>
     <Get Value>

This chunk is called by <Class GenDemo>; see its first definition at
*note Class-GenDemo::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Get Value>               See *note Get-Value::.
<Integer Type             See *note Integer-Type-Parameter::.
Parameter>
<Reference to Integer     See *note Reference-to-Integer-Instance::.
Instance>
<Show Type>               See *note Show-Type::.

Integer Type Declaration
........................

A reference to an Integer is declared in 'iOb'.  Here, the type
'Integer' is specified within the angle brackets after 'Gen'.
'Integer' is a "type argument" that is passed to 'Gen''s type
parameter, 'T'.  This effectively creates a version of 'Gen' in which
all references to 'T' are translated into references to 'Integer'.
Thus, 'ob' is of type 'Integer', and the return type of 'getob()' is
of type 'Integer'.

<Integer Type Parameter> ==
     Gen<Integer> iOb;


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

Reference Assignment
....................

The next line assigns to 'iOb' a reference to an instance of an
'Integer' version of the 'Gen' class.  When the 'Gen' constructor is
called, the type argument 'Integer' is also specified.  This is
because the type of the object (in this case 'iOb' to which the
reference is being assigned is of type 'Gen<Integer>'.  Thus, the
reference returned by 'new' must also be of type 'Gen<Integer>'.  If
it isn't, a compile-time error will result.  This type checking is one
of the main benefits of generics because it ensures type safety.

   Notice the use of autoboxing to encapsulate the value 88 within an
Integer object.

<Reference to Integer Instance> ==
     iOb = new Gen<Integer>(88);


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

   The automatic autoboxing could have been written explicitly, like
so:
     iOb = new Gen<Integer>(Integer.valueOf(88));
but there would be no value to doing it that way.

Showing the Reference's Type
............................

The program then uses 'Gen''s instance method to show the type of
'ob', which is an 'Integer' in this case.

<Show Type> ==
     iOb.showType();


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

Showing the Reference's Value
.............................

The program now obtains the value of 'ob' by assiging 'ob' to an 'int'
variable.  The return type of 'getob()' is 'Integer', which unboxes
into 'int' when assigned to an 'int' variable ('v').  There is no need
to cast the return type of 'getob()' to 'Integer'.

<Get Value> ==
     int v = iOb.getob();
     System.out.println("value: " + v);
     System.out.println();


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.


File: JavaSE9.info,  Node: GenDemo as String,  Prev: GenDemo as Integer,  Up: Class GenDemo

8.3.2.2 Implementation of Class GenDemo with Type String
........................................................

<Create a Gen object for Strings> ==
     // Create a Gen object for Strings.
     Gen<String> strOb = new Gen<String>("Generics Test");

     // Show the type of data used by strOb
     strOb.showType();

     // Get the value of strOb.  Again, notice
     // that no cast is needed.
     String str = strOb.getob();
     System.out.println("value: " + str);


This chunk is called by <Class GenDemo>; see its first definition at
*note Class-GenDemo::.


File: JavaSE9.info,  Node: Notes about Generics,  Next: Two Type Parameters,  Prev: Simple Generics Example,  Up: Generics

8.4 Notes About Generics
========================

* Menu:

* Reference Types::
* Type Arguments::
* Subtyping::
* Type Safety::


File: JavaSE9.info,  Node: Reference Types,  Next: Type Arguments,  Up: Notes about Generics

8.4.1 Generics Work Only with Reference Types
---------------------------------------------

When declaring an instance of a generic type, the type argument passed
to the type parameter must be a reference type.  It cannot be a
primitive type, such as 'int' or 'char'.

   You can use the type wrappers to encapsulate a primitive type.
Java's autoboxing and auto-unboxing mechanism makes the use of the
type wrapper transparent.


File: JavaSE9.info,  Node: Type Arguments,  Next: Subtyping,  Prev: Reference Types,  Up: Notes about Generics

8.4.2 Generic Types Differ Based on their Type Arguments
--------------------------------------------------------

A reference of one specific version of a generic type is not
type-compatible with another version of the same generic type.  In
other words, the following line of code is an error and will not
compile:

     iOb = strOb; // Gen<Integer> != Gen<String>

   These are references to different types because their type
arguments differ.


File: JavaSE9.info,  Node: Subtyping,  Next: Type Safety,  Prev: Type Arguments,  Up: Notes about Generics

8.4.3 Generics and Subtyping
----------------------------

Is the following legal?

     List<String> ls = new ArrayList<String>(); // 1
     List<Object> lo = ls; // 2

   Line 1 is legal.  What about line 2?  This boils down to the
question: "is a List of String a List of Object."  Most people
instinctively answer, "Sure!"

   Now look at these lines:

     lo.add(new Object()); // 3
     String s = ls.get(0); // 4: Attempts to assign an Object to a String!

   Here we've aliased 'ls' and 'lo'.  Accessing 'ls', a list of
'String', through the alias 'lo', we can insert arbitrary objects into
it.  As a result 'ls' does not hold just 'Strings' anymore, and when
we try and get something out of it, we get a rude surprise.

   The Java compiler will prevent this from happening of course.  Line
2 will cause a compile time error.

   The take-away is that, if 'Foo' is a subtype (subclass or
subinterface) of 'Bar', and 'G' is some generic type declaration, it
is not the case that 'G<Foo>' is a subtype of 'G<Bar>'.


File: JavaSE9.info,  Node: Type Safety,  Prev: Subtyping,  Up: Notes about Generics

8.4.4 How Generics Improve Type Safety
--------------------------------------

Generics automatically ensure the type safety of all operations
involving a generic class, such as 'Gen'.  They eliminate the need for
the coder to enter cases and to type-check code by hand.


File: JavaSE9.info,  Node: Two Type Parameters,  Next: Generic Class General Form,  Prev: Notes about Generics,  Up: Generics

8.5 A Generic Class with Two Type Parameters
============================================

You can declare more than one type parameter in a generic type.  To
specify two or more type parameters, use a comma-separated list.  When
an object is created, the same number of type arguments must be passed
as there are type parameters.  The type arguments can be the same or
different.

* Menu:

* Two Types Example Code::


File: JavaSE9.info,  Node: Two Types Example Code,  Up: Two Type Parameters

8.5.1 Example of Code with Two Type Parameters
----------------------------------------------

{'TwoTypeParameters.java'} ==
     <Class TwoGen>
     <Class SimpGen>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class SimpGen>           See *note Class-SimpGen::.
<Class TwoGen>            See *note Class-TwoGen::.

* Menu:

* Class TwoGen::
* Class SimpGen::


File: JavaSE9.info,  Node: Class TwoGen,  Next: Class SimpGen,  Up: Two Types Example Code

8.5.1.1 Class TwoGen
....................

<Class TwoGen> ==
     <Class Declaration>
       <Two Instance Variables Declarations>
       <Constructor of Two Parameters>
       <Instance Methods Show and Get>

This chunk is called by {'TwoTypeParameters.java'}; see its first
definition at *note TwoTypeParameters-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class Declaration>       See *note Class-Declaration::.
<Constructor of Two       See *note Constructor-of-Two-Parameters::.
Parameters>
<Instance Methods Show    See *note Instance-Methods-Show-and-Get::.
and Get>
<Two Instance Variables   See
Declarations>             *note Two-Instance-Variables-Declarations::.

Class Declaration
.................

Notice how 'TwoGen' is declared.  It specifies two type parameters:
'T' and 'V', separated by a comma.  Because it has two type
parameters, two type arguments must be passed to 'TwoGen' when an
object is created.

<Class Declaration> ==
     class TwoGen<T, V> {

This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Instance Variables Declarations
...............................

<Two Instance Variables Declarations> ==
     T ob1;
     V ob2;


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Constructor
...........

<Constructor of Two Parameters> ==
     TwoGen(T o1, V 02) {
       ob1 = o1;
       ob2 = o2;
     }


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Instance Methods Show and Get
.............................

<Instance Methods Show and Get> ==
     void showTypes() {
       System.out.println("Type of T is " + ob1.getClass().getName());
       System.out.println("Type of V is " + ob2.getClass().getName());
     }

     T getob1() {
       return ob1;
     }

     V getob2() {
       return ob2;
     }


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.


File: JavaSE9.info,  Node: Class SimpGen,  Prev: Class TwoGen,  Up: Two Types Example Code

8.5.1.2 Class SimpGen
.....................

Two type arguments must be supplied to the constructor.  In this case,
the two type parameters are 'Integer' and 'String'.

<Class SimpGen> ==
     class SimpGen {
       public static void main(String args[]) {
         TwoGen<Integer, String> tgObj =
           new TwoGen<Integer, String>(88, "Generics");

         // Show the types
         tgObj.showTypes();

         // Obtain and show values
         int v = tgObj.getob1();
         System.out.println("value: " + v);

         String str = thObj.getob2();
         System.out.println("value: " + str);
       }
     }

This chunk is called by {'TwoTypeParameters.java'}; see its first
definition at *note TwoTypeParameters-java::.


File: JavaSE9.info,  Node: Generic Class General Form,  Next: Bounded Types,  Prev: Two Type Parameters,  Up: Generics

8.6 The General Form of a Generic Class
=======================================

The generics syntax shown above can be generalized.  Here is the
syntax for declaring a generic class:

     class class-name<type-param-list> { ...

Here is the full syntax for declaring a reference to a generic class
and instance creation:

     class-name<type-arg-list> var-name =
       new class-name<type-arg-list>(cons-arg-list);

GeneralForm 8.1: General Form for Declaring and Creating a Reference
to a Generic Class


File: JavaSE9.info,  Node: Bounded Types,  Next: Wildcard Arguments,  Prev: Generic Class General Form,  Up: Generics

8.7 Bounded Types
=================

Sometimes it can be useful to limit the types that can be passed to a
type parameter.  Java provides "bounded types".  When specifying a
type parameter, you can create an upper bound that declares the
superclass from which all type arguments must be derived.  This is
accomplished through the use of an 'extends' clause when specifying
the type parameter:

      <T extends superclass>

   This specifies that T can only be replaced by superclass or
subclasses of superclass.  Thus, superclass defines an inclusive,
upper limit.

Interface Type as a Bound
-------------------------

In addition to using a class type as a bound, you can also use an
interface type.  In fact, youi can specify multiple interfaces as
bounds.  Furthermore, a bound can include both a class type and one or
more interfaces.  In this case, the class type must be specified
first.  When a bound includes an interface type, only type arguments
that implement that interface are legal.

   When specifying a bound that has a class and an interface, or
multiple interfaces, use the '&' operator to connnect them.

     class Gen<T extends MyClass & MyInterface> { ...

   Any type argument passed to 'T' must be a subclass of 'MyClass' and
implement 'MyInterface'.


File: JavaSE9.info,  Node: Wildcard Arguments,  Next: Generic Methods,  Prev: Bounded Types,  Up: Generics

8.8 Using Wildcard Arguments
============================

* Menu:

* Wildcard Motivation::
* Wildcard Syntax::
* Bounded Wildcards::


File: JavaSE9.info,  Node: Wildcard Motivation,  Next: Wildcard Syntax,  Up: Wildcard Arguments

8.8.1 Wildcard Motivation
-------------------------

Consider the problem of writing a routine that prints out all the
elements in a collection.  Here's how you might write it in an older
version of the language (i.e., a pre-5.0 release):

     void printCollection(Collection c) {
         Iterator i = c.iterator();
         for (k = 0; k < c.size(); k++) {
             System.out.println(i.next());
         }
     }

   And here is a naive attempt at writing it using generics (and the
new 'for loop' syntax):

         for (Object e : c) {
             System.out.println(e);
         }
     }

   The problem is that this new version is much less useful than the
old one.  Whereas the old code could be called with any kind of
collection as a parameter, the new code only takes
'Collection<Object>', which, as we've just demonstrated, is _not_ a
supertype of all kinds of collections!

   So what is the supertype of all kinds of collections?  It's written
'Collection<?>' (pronounced "collection of unknown"), that is, a
collection whose element type matches anything.  It's called a
"wildcard type".  We can write:

     void printCollection(Collection<?> c) {
         for (Object e : c) {
             System.out.println(e);
         }
     }

   and now, we can call it with any type of collection.  Notice that
inside 'printCollection()', we can still read elements from 'c' and
give them type 'Object'.  This is always safe, since whatever the
actual type of the collection, it does contain objects.  It isn't safe
to add arbitrary objects to it however:

     Collection<?> c = new ArrayList<String>();
     c.add(new Object()); // Compile time error

   Since we don't know what the element type of 'c' stands for, we
cannot add objects to it.  The 'add()' method takes arguments of type
'E', the element type of the collection.  When the actual type
parameter is '?', it stands for some unknown type.  Any parameter we
pass to 'add' would have to be a subtype of this unknown type.  Since
we don't know what type that is, we cannot pass anything in.  The sole
exception is 'null', which is a member of every type.

   On the other hand, given a 'List<?>', we can call 'get()' and make
use of the result.  The result type is an unknown type, but we always
know that it is an object.  It is therefore safe to assign the result
of 'get()' to a variable of type 'Object' or pass it as a parameter
where the type 'Object' is expected.


File: JavaSE9.info,  Node: Wildcard Syntax,  Next: Bounded Wildcards,  Prev: Wildcard Motivation,  Up: Wildcard Arguments

8.8.2 Wildcard Syntax
---------------------

Sometimes type safety can get in the way of perfectly acceptable
constructs.  In such cases, there is a "wildcard" argument that can be
used.  The wildcard argument is specified by the '?', and it
represents an unknown type.  It would be used in place of a type
parameter, for example:

     boolean sameAvg(Stats<?> ob) {
       if(average() == ob.average())
         return true;

       return false;
     }

   Here, 'Stats<?>' matches any 'Stats' object ('Integer', 'Double'),
allowing any two 'Stats' objects to have their averages compared.  The
wildcard does not affect what type of 'Stats' object can be created.
That is governed by the 'extends' clause in the 'Stats' declaration.
The wildcard simply matches any _valid_ 'Stats' object.


File: JavaSE9.info,  Node: Bounded Wildcards,  Prev: Wildcard Syntax,  Up: Wildcard Arguments

8.8.3 Bounded Wildcards
-----------------------

Wildcard arguments can be bounded in much the same way that a type
parameter can be bounded (the "bounded wildcard argument".  A bounded
wildcard is especially important when you are creating a generic type
that will operate on a class hierarchy.

   A bounded wildcard specifies either an upper bound or a lower bound
for the type argument.  This enables you to restrict the types of
objects upon which a method will operate.

Upper Bounded Wildcard
......................

The most common bounded wildcard is the upper bound, which is created
using an 'extends' clause.In general, to establish an upper bound for
a wildcard, use the following type of wildcard expression:

     <? extends superclass>

GeneralForm 8.2: General Form of Upper Bounded Wildcard Syntax

   where superclass is the name of the class that serves as the upper
bound.  This is an inclusive clause.

Lower Bounded Wildcard
......................

You can also specify a lower bound for a wildcard by adding a 'super'
clause to a wildcard declaration.  Here is its general form:

     <? super subclass>

GeneralForm 8.3: General Form of Lower Bounded Wildcard Syntax

   Only classes that are superclasses of subclass are acceptable
arguments


File: JavaSE9.info,  Node: Generic Methods,  Next: Generic Constructors,  Prev: Wildcard Arguments,  Up: Generics

8.9 Creating a Generic Method
=============================

It is possible to declare a generic method that uses one or more type
parameters of its own.  It is also possible to create a generic method
that is enclosed within a non-generic class.

Generalized Form
----------------

     < type-param-list > ret-type meth-name ( param-list ) { ...

GeneralForm 8.4: General Form for Declaring a Generic Method

* Menu:

* Example of Generic Method::


File: JavaSE9.info,  Node: Example of Generic Method,  Up: Generic Methods

8.9.1 Example of Generic Method
-------------------------------

The following program declares a non-generic class called
'GenMethDemo' and a static *generic method* within that class called
'isIn()'.  The 'isIn()' method determines if an object is a member of
an array.  It can be used with any type of object and array as long as
the array contains objects that are compatible with the type of the
object being sought.

{'GenMethDemo.java'} ==
     class GenMethDemo {
       <Static Method isIn>
       <GenMethDemo Main>
     }

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<GenMethDemo Main>        See *note GenMethDemo-Main::.
<Static Method isIn>      See *note Static-Method-isIn::.

* Menu:

* Method isIn::
* GenMethDemo Main::


File: JavaSE9.info,  Node: Method isIn,  Next: GenMethDemo Main,  Up: Example of Generic Method

8.9.1.1 Method isIn()
.....................

The *type parameters* are declared _before_ the return type of the
method.

<Static Method isIn> ==
     static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {

       for (int i = 0; i < y.length; i++)
         if (x.equals(y[i]) return true;

       return false;
     }


This chunk is called by {'GenMethDemo.java'}; see its first definition
at *note GenMethDemo-java::.

   The type T is *upper-bounded* by the 'Comparable' interface, which
must be of the same type as T. Likewise, the second type, V, is also
*upper-bounded* by T. Thus, V must be either the same type as T or a
subclass of T. This relationship enforces that 'isIn()' can be called
only with arguments that are compatible with each other.

   While 'isIn()' is static in this case, generic methods can be
either static or non-static; there is no restriction in this regard.

Explicitly Including Type Arguments
...................................

There is generally no need to specify type arguments when calling this
method from within the 'main' routine.  This is because the type
arguments are automatically discerned, and the types of T and V are
adjusted accordingly.

   Although type inference will be sufficient for most generic method
calls, you can explicitly specify the type argument if needed.  For
example, here is how the first call to 'isIn()' looks when the type
argumetns are specified:

     GenMethDemo.<Integer, Integer>isIn(2, nums)


File: JavaSE9.info,  Node: GenMethDemo Main,  Prev: Method isIn,  Up: Example of Generic Method

8.9.1.2 GenMethDemo Main
........................

<GenMethDemo Main> ==
     public static void main(String args[]) {

       // call isIn() with Integer type
       Integer nums[] = { 1, 2, 3, 4, 5 };

       if ( isIn(2, nums) )
         System.out.println("2 is in nums");

       if ( @isIn(7, nums))
         System.out.println("7 is not in nums");

       System.out.println();

       // call isIn() with String type
       String strs[] = { "one", "two", "three", "four", "five" };

       if ( isIn("two", strs))
         System.out.println("two is in strs");

       if ( !isIn("seven", strs))
         System.out.println("seven is not in strs");

       // call isIn() with mixed types
       // WILL NOT COMPILE! TYPES MUST BE COMPATIBLE
       // if ( isIn("two", nums))
       //    System.out.println("two is in nums");
     }


This chunk is called by {'GenMethDemo.java'}; see its first definition
at *note GenMethDemo-java::.


File: JavaSE9.info,  Node: Generic Constructors,  Prev: Generic Methods,  Up: Generics

8.10 Generic Constructors
=========================

It is possible for constructors to be generic, even if their class is
not (*note generics-constructor::).  The syntax is the same (type
parameters come first).

     < type-param-list> constructor-name ( param-list ) { ...


File: JavaSE9.info,  Node: Enumerations,  Next: Strings,  Prev: Generics,  Up: Top

9 Enumerations
**************

Enumerations were added by JDK 5.  In earlier versions of Java,
enumerations were implemented using 'final' variables.

   An "enumeration" is a list of named constants that define a new
data type and its legal values.  In other words, an enumeration
defines a class type.  An "enumeration object" can only hold values
that were declared in the list.  Other values are not allowed.  An
enumeration allows the programmer to define a set of values that a
data type can legally have.

   By making enumerations classes, the capabilities of the enumeration
are greatly expanded.  An enumeration can have:

   * constructors
   * methods
   * instance variables

* Menu:

* Enumeration Basics::
* Enum Methods::
* Enumerations as Class Types::
* Inherit Enum::


File: JavaSE9.info,  Node: Enumeration Basics,  Next: Enum Methods,  Up: Enumerations

9.1 Enumeration Basics
======================

An enumeration is created using the 'enum' keyword.

     enum Apple {
          Jonathon, GoldenDel, RedDel, Winesap, Cortland
     }

enumeration constants
---------------------

The enum constants 'Jonathon', 'GoldenDel', etc.  are called
"enumeration constants".  The enumeration constants are declared as
'public static final' members of the enum.  Their type is the type of
the enumeration in which they are declared.  These constants are
called "self-typed", in which "self" refers to the enclosing
enumeration.

enumeration objects
-------------------

You can create a variable of an enumeration type.  You do not
instantiate an 'enum' using 'new'.  Rather, you declare an 'enum'
variable like you do for primitive types: 'Apple ap'.  Now, the
variable 'ap' can only hold values of type 'Apple'.

     Apple ap;
     ap = Apple.RedDel;

   The 'enum' type (i.e., 'Apple') must be part of the expression.

Comparing for Equality; Switch
------------------------------

Two enumeration constants can be compared for equality using the '=='
relational operator.  Furthermore, an enumneration value can be used
to control a 'switch' statement.  The 'enum' prefix (type) is not
required for 'switch'.

     switch(ap) {
       case Jonathon: ...
       case Winesap: ...
     }

Printing Enum Types
-------------------

When an enumeration object is printed, its name is output (without the
'enum' type): 'System.out.println(ap)' would produce 'RedDel'.


File: JavaSE9.info,  Node: Enum Methods,  Next: Enumerations as Class Types,  Prev: Enumeration Basics,  Up: Enumerations

9.2 Enum Methods 'values()' and 'valueOf()'
===========================================

All enumerations inherit two methods:

 -- Method on Enum:
          public static enum-type[]
          values ()
     The 'values()' method returns an array that contains a list of
     the enumeration constants.

 -- Method on Enum:
          public static enum-type
          valueOf (String STR)
     The 'valueOf()' method returns the enumeration constant whose
     value corresponds to the string passed in STR.

Examples using 'values()' and 'valueOf()' Methods
-------------------------------------------------

'Apple allapples[] = Apple.values();' is an example of using the
'values()' method to populate an array with enumeration constants.

     for(Apple a : Apple.values()) {
       System.out.println(a);
     }

is an example of iterating directly on the 'values()' method.

     Apple ap;
     ap = Apple.valueOf("Winesap");
     System.out.println("ap contains " + ap);

is an example of using the 'valueOf()' method to obtain the
enumeration constant corresponding to the value of a string.


File: JavaSE9.info,  Node: Enumerations as Class Types,  Next: Inherit Enum,  Prev: Enum Methods,  Up: Enumerations

9.3 Java Enumerations are Class Types
=====================================

A Java enumeration is a class type.  That is, 'enum' defines a class,
which has much the same capabilities as other classes.  An enumeration
can be given constructors, instance variables, and methods.  It can
even implement interfaces.  Each enumeration constant is an object of
its enumeration type.  When an enumeration is given a constructor, the
constructor is called when each enumeration constant is created.
Also, each enumeration constant has its own copy of any instance
variables defined by the enumeration.

     enum Apple {
       Jonathon(10), GoldenDel(9), RedDel(12), Winesap(15), Cortland(8);
       private int price;
       Apple(int p) { price = p; }
       int getPrice() { return price; }
     }

     class EnumDemo {
       public static void main (String[] args) {
         Apple ap;
       }
     }

   In this example, the enumeration 'Apple' is given an instance
variable 'price', a constructor, and an instance method 'getPrice()'.
When the variable 'ap' is declared in 'main()', the constructor for
'Apple' is called once for each constant that is specified.  The
arguments to the constructor are placed in parentheses after the name
of each constant.  Thereafter, each enumeration constant has its own
copy of 'price', which can be obtained by calling the instance method
'getPrice()'.  In addition, there can be multiple overloaded
constructors just as for any other class.

Restrictions on Enums
---------------------

   * An enumeration cannot inherit another class.
   * An 'enum' cannot be a superclass ('enum' cannot be extended).

   The key is to remember that each enumeration constant is an object
of the class in which it is defined.


File: JavaSE9.info,  Node: Inherit Enum,  Prev: Enumerations as Class Types,  Up: Enumerations

9.4 Enumerations Inherit 'Enum'
===============================

All enumerations automatically inherit from one superclass:
'java.lang.Enum'.  This class defines several methods that are
available for use by all enumerations.

'ordinal()' and 'compareTo()'
-----------------------------

 -- Method on Enum:
          final int
          ordinal ()
     The 'ordinal()' method returns a value that indicates an
     enumeration constant's position in the list of constants, called
     its "ordinal value".  In other words, calling 'ordinal()' returns
     the ordinal value of the invoking constant (zero indexed).

 -- Method on Enum:
          final int
          compareTo (enum-type E)
     The ordinal values of two constants can be compared using the
     'compareTo()' method.  Both the invoking constant and E must be
     of the same enumeration enum-type.  This method returns a
     negative value, a zero, or a positive value depending on whether
     the invoking constant's ordinal value is less than, equal to, or
     greater than the passed-in enumeration constant's ordinal value.

'equals()' and '=='
-------------------

 -- Method on Enum:
          boolean
          equals (enum-type E)
 -- Method on Enum:
          boolean
          == (enum-type E)
     Compare for equality an invoking enum constant with a referenced
     enum constant.

   An invoking enum constant can compare for equality itself with any
other object by using 'equals()' or, equivalently, '==', which
overrides the 'equals()' method defined in 'Object'.  'equals()' will
return true only if both objects refer to the same constant within the
same enumeration.  (In other words, 'equals' does not just compare
ordinal values in general.)


File: JavaSE9.info,  Node: Strings,  Next: java Lang,  Prev: Enumerations,  Up: Top

10 String Handling
******************


File: JavaSE9.info,  Node: java Lang,  Next: java util Collections,  Prev: Strings,  Up: Top

11 'java.lang'
**************

Classes and interfaces defined by 'java.lang', which is automatically
imported into all programs.  Contains classes and interfaces that are
fundamental to all of Java programming.  Beginning with JDK 9, all of
'java.lang' is part of the 'java.base' module.

'java.lang' includes the following classes
------------------------------------------

   * Boolean
   * Byte
   * Character
        * Character.Subset
        * Character.UnicodeBlock
   * Class
   * ClassLoader
   * ClassValue
   * Compiler
   * Double
   * Enum
   * Float
   * InheritableThreadLocal
   * Integer
   * Long
   * Math
   * Module
        * ModuleLayer
        * ModuleLayer.Controller
   * Number
   * Object
   * Package
   * Process
        * ProcessBuilder
        * ProcessBuilder.Redirect
   * Runtime
        * RuntimePermission
        * Runtime.Version
   * SecurityManager
   * Short
   * StackFramePermission
   * StackTraceElement
   * StackWalker
   * StrictMath
   * String
        * StringBuffer
        * StringBuilder
   * System
        * System.LoggerFinder
   * Thread
        * ThreadGroup
        * ThreadLocal
   * Throwable
   * Void

'java.lang' includes the following interfaces
---------------------------------------------

   * Appendable
   * AutoClosable
   * CharSequence
   * Clonable
   * Comparable
   * Iterable
   * ProcessHandle
        * ProcessHandle.Info
   * Readable
   * Runnable
   * StackWalker.StackFrame
   * System.Logger
   * Thread.UncaughtExceptionHandler

* Menu:

* Primitive Wrappers::


File: JavaSE9.info,  Node: Primitive Wrappers,  Up: java Lang

11.1 Primitive Type Wrappers
============================

Java uses primitive types for 'int', 'char', etc.  for performance
reasons.  These primitives are not part of the object hierarchy; they
are passed by-value, not by reference.  Sometimes you may need to
create an object representation for a primitive type.  To store a
primitive in a class, you need to wrap the primitive type in a class.

   Java provides classes that correspond to each of the primitive
types.  These classes encapsulate or "wrap" the primitive types within
a class.  They are commonly referred to as "type wrappers".

* Menu:

* Number::
* Double and Float::
* isInfiinite() and isNaN()::
* Byte Short Integer Long::
* Numbers to from String::


File: JavaSE9.info,  Node: Number,  Next: Double and Float,  Up: Primitive Wrappers

11.1.1 Number
-------------


File: JavaSE9.info,  Node: Double and Float,  Next: isInfiinite() and isNaN(),  Prev: Number,  Up: Primitive Wrappers

11.1.2 Double and Float
-----------------------


File: JavaSE9.info,  Node: isInfiinite() and isNaN(),  Next: Byte Short Integer Long,  Prev: Double and Float,  Up: Primitive Wrappers

11.1.3 isInfinite() and isNaN()
-------------------------------


File: JavaSE9.info,  Node: Byte Short Integer Long,  Next: Numbers to from String,  Prev: isInfiinite() and isNaN(),  Up: Primitive Wrappers

11.1.4 Byte, Short, Integer, Long
---------------------------------


File: JavaSE9.info,  Node: Numbers to from String,  Prev: Byte Short Integer Long,  Up: Primitive Wrappers

11.1.5 Converting Numbers to and from String
--------------------------------------------


File: JavaSE9.info,  Node: java util Collections,  Next: java util Utility Classes,  Prev: java Lang,  Up: Top

12 'java.util' -- Part 1: The Collections Framework
***************************************************


File: JavaSE9.info,  Node: java util Utility Classes,  Next: java io Input Output,  Prev: java util Collections,  Up: Top

13 'java.util' -- Part 2: Utility Classes
*****************************************


File: JavaSE9.info,  Node: java io Input Output,  Next: NIO,  Prev: java util Utility Classes,  Up: Top

14 'java.io' -- Input/Output
****************************


File: JavaSE9.info,  Node: NIO,  Next: Networking,  Prev: java io Input Output,  Up: Top

15 NIO
******


File: JavaSE9.info,  Node: Networking,  Next: Event Handling,  Prev: NIO,  Up: Top

16 Networking
*************


File: JavaSE9.info,  Node: Event Handling,  Next: AWT,  Prev: Networking,  Up: Top

17 Event Handling
*****************


File: JavaSE9.info,  Node: AWT,  Next: AWT Controls,  Prev: Event Handling,  Up: Top

18 AWT: Working with Windows, Graphics, and Text
************************************************


File: JavaSE9.info,  Node: AWT Controls,  Next: Images,  Prev: AWT,  Up: Top

19 Using AWT Controls, Layout Managers, and Menus
*************************************************


File: JavaSE9.info,  Node: Images,  Next: Concurrency,  Prev: AWT Controls,  Up: Top

20 Images
*********


File: JavaSE9.info,  Node: Concurrency,  Next: Streams API,  Prev: Images,  Up: Top

21 The Concurrency Utilities
****************************


File: JavaSE9.info,  Node: Streams API,  Next: Regular Expressions,  Prev: Concurrency,  Up: Top

22 The Stream API
*****************


File: JavaSE9.info,  Node: Regular Expressions,  Next: Swing,  Prev: Streams API,  Up: Top

23 Regular Expressions and Other Packages
*****************************************


File: JavaSE9.info,  Node: Swing,  Next: The Makefile,  Prev: Regular Expressions,  Up: Top

24 Introducinvg Swing
*********************


File: JavaSE9.info,  Node: The Makefile,  Next: Code Chunk Summaries,  Prev: Swing,  Up: Top

Appendix A The Makefile
***********************

{'Makefile'} ==
     <Makefile CONSTANTS>
     <Makefile DEFAULTS>
     <Makefile TANGLE WEAVE>
     <Makefile CLEAN>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Makefile CLEAN>          See *note Makefile-CLEAN::.
<Makefile CONSTANTS>      See *note Makefile-CONSTANTS::.
<Makefile DEFAULTS>       See *note Makefile-DEFAULTS::.
<Makefile TANGLE WEAVE>   See *note Makefile-TANGLE-WEAVE::.

* Menu:

* Makefile Constants::
* Makefile Defaults::
* Makefile Tangle Weave::
* Makefile Clean::


File: JavaSE9.info,  Node: Makefile Constants,  Next: Makefile Defaults,  Up: The Makefile

A.1 Makefile Constants
======================

<Makefile CONSTANTS> ==
     FILENAME := JavaSE9


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Makefile Defaults,  Next: Makefile Tangle Weave,  Prev: Makefile Constants,  Up: The Makefile

A.2 Makefile Default Targets
============================

<Makefile DEFAULTS> ==
     .PHONY: all
     all: tangle weave


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Makefile Tangle Weave,  Next: Makefile Clean,  Prev: Makefile Defaults,  Up: The Makefile

A.3 Makefile Tangle Weave Targets
=================================

<Makefile TANGLE WEAVE> ==
     .PHONY: tangle weave jrtangle jrweave
     tangle: jrtangle
     weave: jrweave

     jrtangle: $(FILENAME).twjr
         jrtangle $(FILENAME).twjr

     jrweave: $(FILENAME).texi

     $(FILENAME).texi: $(FILENAME).twjr
         jrweave $(FILENAME).twjr > $(FILENAME).texi

This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Makefile Clean,  Prev: Makefile Tangle Weave,  Up: The Makefile

A.4 Makefile Clean Targets
==========================

<Makefile CLEAN> ==
     .PHONY: clean
     clean:
         rm -f *~
         rm -f $(FILENAME).???


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Code Chunk Summaries,  Next: List of Tables,  Prev: The Makefile,  Up: Top

Appendix B Code Chunk Summaries
*******************************

This major node presents alphabetical lists of all the file
definitions, the code chunk definitions, and the code chunk
references.

* Menu:

* File Definitions::            Source files by definition.
* Code Chunk Definitions::      Code chunks by definition.
* Code Chunk References::       Code chunks by reference.


File: JavaSE9.info,  Node: File Definitions,  Next: Code Chunk Definitions,  Up: Code Chunk Summaries

B.1 Source File Definitions
===========================

{'AbstractAreas.java '}
     This chunk is defined in *note AbstractAreas-java-::.
{'BRRead.java'}
     This chunk is defined in *note BRRead-java::.
{'BRReadLines.java'}
     This chunk is defined in *note BRReadLines-java::.
{'FindAreas.java '}
     This chunk is defined in *note FindAreas-java-::.
{'GenMethDemo.java'}
     This chunk is defined in *note GenMethDemo-java::.
{'Makefile'}
     This chunk is defined in *note Makefile::.
{'SimpleGenerics.java'}
     This chunk is defined in *note SimpleGenerics-java::.
{'Stack.java'}
     This chunk is defined in *note Stack-java::.
{'StackImproved.java'}
     This chunk is defined in *note StackImproved-java::.
{'TestStack.java'}
     This chunk is defined in *note TestStack-java::.
{'TwoTypeParameters.java'}
     This chunk is defined in *note TwoTypeParameters-java::.


File: JavaSE9.info,  Node: Code Chunk Definitions,  Next: Code Chunk References,  Prev: File Definitions,  Up: Code Chunk Summaries

B.2 Code Chunk Definitions
==========================

<AbstractAreas Abstract Area Method Declaration >
     This chunk is defined in *note
     AbstractAreas-Abstract-Area-Method-Declaration-::.
<AbstractAreas Abstract Class Figure >
     This chunk is defined in *note
     AbstractAreas-Abstract-Class-Figure-::.
<AbstractAreas Main Class >
     This chunk is defined in *note AbstractAreas-Main-Class-::.
<AbstractAreas Main Method Declaration >
     This chunk is defined in *note
     AbstractAreas-Main-Method-Declaration-::.
<BRRead BufferedReader Constructor>
     This chunk is defined in *note
     BRRead-BufferedReader-Constructor::.
<BRRead Enter Characters>
     This chunk is defined in *note BRRead-Enter-Characters::.
<BRReadLines BufferedReader Constructor>
     This chunk is defined in *note
     BRReadLines-BufferedReader-Constructor::.
<BRReadLines Enter Lines>
     This chunk is defined in *note BRReadLines-Enter-Lines::.
<Call Overridden Methods One By One >
     This chunk is defined in *note
     Call-Overridden-Methods-One-By-One-::.
<Call Overridden Methods One By One Except Figure >
     This chunk is defined in *note
     Call-Overridden-Methods-One-By-One-Except-Figure-::.
<Class Declaration>
     This chunk is defined in *note Class-Declaration::.
<Class Gen>
     This chunk is defined in *note Class-Gen::.
<Class GenDemo>
     This chunk is defined in *note Class-GenDemo::.
<Class SimpGen>
     This chunk is defined in *note Class-SimpGen::.
<Class TwoGen>
     This chunk is defined in *note Class-TwoGen::.
<Constructor of Two Parameters>
     This chunk is defined in *note Constructor-of-Two-Parameters::.
<Constructor taking parameter of Type T>
     This chunk is defined in *note
     Constructor-taking-parameter-of-Type-T::.
<Create Basic Figure Objects >
     This chunk is defined in *note Create-Basic-Figure-Objects-::.
<Create Basic Figure Objects Except Figure >
     This chunk is defined in *note
     Create-Basic-Figure-Objects-Except-Figure-::.
<Create Basic Figure Reference Variable >
     This chunk is defined in *note
     Create-Basic-Figure-Reference-Variable-::.
<Create a Gen object for Integers>
     This chunk is defined in *note
     Create-a-Gen-object-for-Integers::.
<Create a Gen object for Strings>
     This chunk is defined in *note Create-a-Gen-object-for-Strings::.
<Figure Area Method Declaration >
     This chunk is defined in *note Figure-Area-Method-Declaration-::.
<Figure Constructor >
     This chunk is defined in *note Figure-Constructor-::.
<Figure Instance Variable Declarations >
     This chunk is defined in *note
     Figure-Instance-Variable-Declarations-::.
<FindAreas Main Class >
     This chunk is defined in *note FindAreas-Main-Class-::.
<FindAreas Main Method Declaration >
     This chunk is defined in *note
     FindAreas-Main-Method-Declaration-::.
<FindAreas SubClass Rectangle >
     This chunk is defined in *note FindAreas-SubClass-Rectangle-::.
<FindAreas SubClass Triangle >
     This chunk is defined in *note FindAreas-SubClass-Triangle-::.
<FindAreas SuperClass Figure >
     This chunk is defined in *note FindAreas-SuperClass-Figure-::.
<GenMethDemo Main>
     This chunk is defined in *note GenMethDemo-Main::.
<Get Value>
     This chunk is defined in *note Get-Value::.
<Import java.io>
     This chunk is defined in *note Import-java-io::.
<Instance Methods Show and Get>
     This chunk is defined in *note Instance-Methods-Show-and-Get::.
<Instance Variable ob of Type T>
     This chunk is defined in *note Instance-Variable-ob-of-Type-T::.
<Integer Type Parameter>
     This chunk is defined in *note Integer-Type-Parameter::.
<Makefile CLEAN>
     This chunk is defined in *note Makefile-CLEAN::.
<Makefile CONSTANTS>
     This chunk is defined in *note Makefile-CONSTANTS::.
<Makefile DEFAULTS>
     This chunk is defined in *note Makefile-DEFAULTS::.
<Makefile TANGLE WEAVE>
     This chunk is defined in *note Makefile-TANGLE-WEAVE::.
<Method returning object of type T>
     This chunk is defined in *note
     Method-returning-object-of-type-T::.
<Method showing type of T>
     This chunk is defined in *note Method-showing-type-of-T::.
<Rectangle Area Method Declaration >
     This chunk is defined in *note
     Rectangle-Area-Method-Declaration-::.
<Rectangle Constructor >
     This chunk is defined in *note Rectangle-Constructor-::.
<Reference to Integer Instance>
     This chunk is defined in *note Reference-to-Integer-Instance::.
<Show Type>
     This chunk is defined in *note Show-Type::.
<Stack Constructor>
     This chunk is defined in *note Stack-Constructor::.
<Stack Instance Methods>
     This chunk is defined in *note Stack-Instance-Methods::.
<Stack Instance Variables>
     This chunk is defined in *note Stack-Instance-Variables::.
<Stack Pop>
     This chunk is defined in *note Stack-Pop::.
<Stack Private Instance Variables>
     This chunk is defined in *note
     Stack-Private-Instance-Variables::.
<Stack Push>
     This chunk is defined in *note Stack-Push::.
<Static Method isIn>
     This chunk is defined in *note Static-Method-isIn::.
<TestStack Main Method>
     This chunk is defined in *note TestStack-Main-Method::.
<Triangle Area Method Declaration >
     This chunk is defined in *note
     Triangle-Area-Method-Declaration-::.
<Triangle Constructor >
     This chunk is defined in *note Triangle-Constructor-::.
<Two Instance Variables Declarations>
     This chunk is defined in *note
     Two-Instance-Variables-Declarations::.


File: JavaSE9.info,  Node: Code Chunk References,  Prev: Code Chunk Definitions,  Up: Code Chunk Summaries

B.3 Code Chunk References
=========================

<AbstractAreas Abstract Area Method Declaration >

     This chunk is called by <AbstractAreas Abstract Class Figure >;
     see its first definition at *note
     AbstractAreas-Abstract-Class-Figure-::.
<AbstractAreas Abstract Class Figure >

     This chunk is called by {'AbstractAreas.java '}; see its first
     definition at *note AbstractAreas-java-::.
<AbstractAreas Main Class >

     This chunk is called by {'AbstractAreas.java '}; see its first
     definition at *note AbstractAreas-java-::.
<AbstractAreas Main Method Declaration >

     This chunk is called by <AbstractAreas Main Class >; see its
     first definition at *note AbstractAreas-Main-Class-::.
<BRRead BufferedReader Constructor>

     This chunk is called by {'BRRead.java'}; see its first definition
     at *note BRRead-java::.
<BRRead Enter Characters>

     This chunk is called by {'BRRead.java'}; see its first definition
     at *note BRRead-java::.
<BRReadLines BufferedReader Constructor>

     This chunk is called by {'BRReadLines.java'}; see its first
     definition at *note BRReadLines-java::.
<BRReadLines Enter Lines>

     This chunk is called by {'BRReadLines.java'}; see its first
     definition at *note BRReadLines-java::.
<Call Overridden Methods One By One >

     This chunk is called by <FindAreas Main Method Declaration >; see
     its first definition at *note
     FindAreas-Main-Method-Declaration-::.
<Call Overridden Methods One By One Except Figure >

     This chunk is called by <AbstractAreas Main Method Declaration >;
     see its first definition at *note
     AbstractAreas-Main-Method-Declaration-::.
<Class Declaration>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.
<Class Gen>

     This chunk is called by {'SimpleGenerics.java'}; see its first
     definition at *note SimpleGenerics-java::.
<Class GenDemo>

     This chunk is called by {'SimpleGenerics.java'}; see its first
     definition at *note SimpleGenerics-java::.
<Class SimpGen>

     This chunk is called by {'TwoTypeParameters.java'}; see its first
     definition at *note TwoTypeParameters-java::.
<Class TwoGen>

     This chunk is called by {'TwoTypeParameters.java'}; see its first
     definition at *note TwoTypeParameters-java::.
<Constructor of Two Parameters>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.
<Constructor taking parameter of Type T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Create Basic Figure Objects >

     This chunk is called by <FindAreas Main Method Declaration >; see
     its first definition at *note
     FindAreas-Main-Method-Declaration-::.
<Create Basic Figure Objects Except Figure >

     This chunk is called by <AbstractAreas Main Method Declaration >;
     see its first definition at *note
     AbstractAreas-Main-Method-Declaration-::.
<Create Basic Figure Reference Variable >

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     <AbstractAreas Main       See
     Method Declaration >      *note AbstractAreas-Main-Method-Declaration-::.
     <FindAreas Main Method    See
     Declaration >             *note FindAreas-Main-Method-Declaration-::.
<Create a Gen object for Integers>

     This chunk is called by <Class GenDemo>; see its first definition
     at *note Class-GenDemo::.
<Create a Gen object for Strings>

     This chunk is called by <Class GenDemo>; see its first definition
     at *note Class-GenDemo::.
<Figure Area Method Declaration >

     This chunk is called by <FindAreas SuperClass Figure >; see its
     first definition at *note FindAreas-SuperClass-Figure-::.
<Figure Constructor >

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     <AbstractAreas Abstract   See
     Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
     <FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
     Figure >
<Figure Instance Variable Declarations >

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     <AbstractAreas Abstract   See
     Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
     <FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
     Figure >
<FindAreas Main Class >

     This chunk is called by {'FindAreas.java '}; see its first
     definition at *note FindAreas-java-::.
<FindAreas Main Method Declaration >

     This chunk is called by <FindAreas Main Class >; see its first
     definition at *note FindAreas-Main-Class-::.
<FindAreas SubClass Rectangle >

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     {'AbstractAreas.java '}   See *note AbstractAreas-java-::.
     {'FindAreas.java '}       See *note FindAreas-java-::.
<FindAreas SubClass Triangle >

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     {'AbstractAreas.java '}   See *note AbstractAreas-java-::.
     {'FindAreas.java '}       See *note FindAreas-java-::.
<FindAreas SuperClass Figure >

     This chunk is called by {'FindAreas.java '}; see its first
     definition at *note FindAreas-java-::.
<GenMethDemo Main>

     This chunk is called by {'GenMethDemo.java'}; see its first
     definition at *note GenMethDemo-java::.
<Get Value>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Import java.io>

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     {'BRRead.java'}           See *note BRRead-java::.
     {'BRReadLines.java'}      See *note BRReadLines-java::.
<Instance Methods Show and Get>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.
<Instance Variable ob of Type T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Integer Type Parameter>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Makefile CLEAN>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile CONSTANTS>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile DEFAULTS>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile TANGLE WEAVE>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Method returning object of type T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Method showing type of T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Rectangle Area Method Declaration >

     This chunk is called by <FindAreas SubClass Rectangle >; see its
     first definition at *note FindAreas-SubClass-Rectangle-::.
<Rectangle Constructor >

     This chunk is called by <FindAreas SubClass Rectangle >; see its
     first definition at *note FindAreas-SubClass-Rectangle-::.
<Reference to Integer Instance>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Show Type>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Stack Constructor>

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     {'Stack.java'}            See *note Stack-java::.
     {'StackImproved.java'}    See *note StackImproved-java::.
<Stack Instance Methods>

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     {'Stack.java'}            See *note Stack-java::.
     {'StackImproved.java'}    See *note StackImproved-java::.
<Stack Instance Variables>

     This chunk is called by {'Stack.java'}; see its first definition
     at *note Stack-java::.
<Stack Pop>

     This chunk is called by <Stack Instance Methods>; see its first
     definition at *note Stack-Instance-Methods::.
<Stack Private Instance Variables>

     This chunk is called by {'StackImproved.java'}; see its first
     definition at *note StackImproved-java::.
<Stack Push>

     This chunk is called by <Stack Instance Methods>; see its first
     definition at *note Stack-Instance-Methods::.
<Static Method isIn>

     This chunk is called by {'GenMethDemo.java'}; see its first
     definition at *note GenMethDemo-java::.
<TestStack Main Method>

     This chunk is called by {'TestStack.java'}; see its first
     definition at *note TestStack-java::.
<Triangle Area Method Declaration >

     This chunk is called by <FindAreas SubClass Triangle >; see its
     first definition at *note FindAreas-SubClass-Triangle-::.
<Triangle Constructor >

     This chunk is called by <FindAreas SubClass Triangle >; see its
     first definition at *note FindAreas-SubClass-Triangle-::.
<Two Instance Variables Declarations>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.


File: JavaSE9.info,  Node: List of Tables,  Next: List of General Forms,  Prev: Code Chunk Summaries,  Up: Top

List of Tables
**************

* Menu:

* Table 5.1: PackageAccess.              Package Access Table
* Table 7.1: ByteStreamClasses.          The Byte Stream Classes ...
* Table 7.2: CharacterStreamClasses.     The Character Stream I/O ...


File: JavaSE9.info,  Node: List of General Forms,  Next: Bibliography,  Prev: List of Tables,  Up: Top

List of General Forms
*********************

* Menu:

* GeneralForm 2.1: ClassDeclaration.     Class Declaration -- ...
* GeneralForm 2.2: MethodDeclaration.    Method Declaration -- ...
* GeneralForm 4.1: Subclass.             Subclass General Form
* GeneralForm 4.2: SuperCallingConstructor.
                                         'super' Calling a ...
* GeneralForm 4.3: SuperReferencingSuperclass.
                                         'super' Referencing its ...
* GeneralForm 4.4: AbstractMethodDeclaration.
                                         Abstract Method ...
* GeneralForm 5.1: PackageStatement.     Package Statement -- ...
* GeneralForm 5.2: PackageStatementMulti.Package Statement -- ...
* GeneralForm 5.3: Import.               Import Statement -- ...
* GeneralForm 6.1: InterfaceSimple.      Interface Definition -- ...
* GeneralForm 6.2: ClassImplementsInterface.
                                         Class Implementing ...
* GeneralForm 6.3: InterfaceStaticMethod.Interface Static Method, ...
* GeneralForm 8.1: GenericClass.         General Form Generic Class
* GeneralForm 8.2: UpperBoundedWildcard. Upper Bounded Wildcard
* GeneralForm 8.3: LowerBoundedWildcard. Lower Bounded Wildcard
* GeneralForm 8.4: GenericMethod.        Generic Method Declaration


File: JavaSE9.info,  Node: Bibliography,  Next: Concept Index,  Prev: List of General Forms,  Up: Top

Bibliography
************


File: JavaSE9.info,  Node: Concept Index,  Next: Function Index,  Prev: Bibliography,  Up: Top

Index
*****

 [index ]
* Menu:

* <AbstractAreas Abstract Area Method Declaration >, definition: AbstractAreas Abstract Class Figure Node.
                                                            (line  34)
* <AbstractAreas Abstract Area Method Declaration >, use: AbstractAreas Abstract Class Figure Node.
                                                            (line  10)
* <AbstractAreas Abstract Class Figure >, definition: AbstractAreas Abstract Class Figure Node.
                                                            (line  10)
* <AbstractAreas Abstract Class Figure >, use: Improved Figure Class.
                                                            (line  12)
* <AbstractAreas Main Class >, definition: AbstractAreas Main Class.
                                                            (line   6)
* <AbstractAreas Main Class >, use:      Improved Figure Class.
                                                            (line  12)
* <AbstractAreas Main Method Declaration >, definition: AbstractAreas Main Class.
                                                            (line  21)
* <AbstractAreas Main Method Declaration >, use: AbstractAreas Main Class.
                                                            (line   6)
* <BRRead BufferedReader Constructor>, definition: BRRead BufferedReader Constructor Node.
                                                            (line   6)
* <BRRead BufferedReader Constructor>, use: Reading Characters.
                                                            (line  24)
* <BRRead Enter Characters>, definition: BRRead Enter Characters Node.
                                                            (line   6)
* <BRRead Enter Characters>, use:        Reading Characters.
                                                            (line  24)
* <BRReadLines BufferedReader Constructor>, definition: BRReadLines BufferedReader Constructor.
                                                            (line   6)
* <BRReadLines BufferedReader Constructor>, use: Reading Strings.
                                                            (line  20)
* <BRReadLines Enter Lines>, definition: BRReadLines Enter Lines.
                                                            (line   6)
* <BRReadLines Enter Lines>, use:        Reading Strings.   (line  20)
* <Call Overridden Methods One By One >, definition: FindAreas Main Class Node.
                                                            (line  78)
* <Call Overridden Methods One By One >, use: FindAreas Main Class Node.
                                                            (line  21)
* <Call Overridden Methods One By One Except Figure >, definition: AbstractAreas Main Class.
                                                            (line  70)
* <Call Overridden Methods One By One Except Figure >, use: AbstractAreas Main Class.
                                                            (line  21)
* <Class Declaration>, definition:       Class TwoGen.      (line  34)
* <Class Declaration>, use:              Class TwoGen.      (line   6)
* <Class Gen>, definition:               Class Gen<T>.      (line  33)
* <Class Gen>, use:                      Simple Generics Example.
                                                            (line   9)
* <Class GenDemo>, definition:           Class GenDemo.     (line  22)
* <Class GenDemo>, use:                  Simple Generics Example.
                                                            (line   9)
* <Class SimpGen>, definition:           Class SimpGen.     (line   9)
* <Class SimpGen>, use:                  Two Types Example Code.
                                                            (line   6)
* <Class TwoGen>, definition:            Class TwoGen.      (line   6)
* <Class TwoGen>, use:                   Two Types Example Code.
                                                            (line   6)
* <Constructor of Two Parameters>, definition: Class TwoGen.
                                                            (line  54)
* <Constructor of Two Parameters>, use:  Class TwoGen.      (line   6)
* <Constructor taking parameter of Type T>, definition: Class Gen<T>.
                                                            (line  79)
* <Constructor taking parameter of Type T>, use: Class Gen<T>.
                                                            (line  33)
* <Create a Gen object for Integers>, definition: GenDemo as Integer.
                                                            (line   6)
* <Create a Gen object for Integers>, use: Class GenDemo.   (line  22)
* <Create a Gen object for Strings>, definition: GenDemo as String.
                                                            (line   6)
* <Create a Gen object for Strings>, use: Class GenDemo.    (line  22)
* <Create Basic Figure Objects >, definition: FindAreas Main Class Node.
                                                            (line  45)
* <Create Basic Figure Objects >, use:   FindAreas Main Class Node.
                                                            (line  21)
* <Create Basic Figure Objects Except Figure >, definition: AbstractAreas Main Class.
                                                            (line  53)
* <Create Basic Figure Objects Except Figure >, use: AbstractAreas Main Class.
                                                            (line  21)
* <Create Basic Figure Reference Variable >, definition: FindAreas Main Class Node.
                                                            (line  62)
* <Create Basic Figure Reference Variable >, use: FindAreas Main Class Node.
                                                            (line  21)
* <Create Basic Figure Reference Variable >, use <1>: AbstractAreas Main Class.
                                                            (line  21)
* <Figure Area Method Declaration >, definition: FindAreas SuperClass Figure Node.
                                                            (line  71)
* <Figure Area Method Declaration >, use: FindAreas SuperClass Figure Node.
                                                            (line   6)
* <Figure Constructor >, definition:     FindAreas SuperClass Figure Node.
                                                            (line  46)
* <Figure Constructor >, use:            FindAreas SuperClass Figure Node.
                                                            (line   6)
* <Figure Constructor >, use <1>:        AbstractAreas Abstract Class Figure Node.
                                                            (line  10)
* <Figure Instance Variable Declarations >, definition: FindAreas SuperClass Figure Node.
                                                            (line  29)
* <Figure Instance Variable Declarations >, use: FindAreas SuperClass Figure Node.
                                                            (line   6)
* <Figure Instance Variable Declarations >, use <1>: AbstractAreas Abstract Class Figure Node.
                                                            (line  10)
* <FindAreas Main Class >, definition:   FindAreas Main Class Node.
                                                            (line   6)
* <FindAreas Main Class >, use:          Applying Method Overriding.
                                                            (line  15)
* <FindAreas Main Method Declaration >, definition: FindAreas Main Class Node.
                                                            (line  21)
* <FindAreas Main Method Declaration >, use: FindAreas Main Class Node.
                                                            (line   6)
* <FindAreas SubClass Rectangle >, definition: FindAreas SubClass Rectangle Node.
                                                            (line   6)
* <FindAreas SubClass Rectangle >, use:  Applying Method Overriding.
                                                            (line  15)
* <FindAreas SubClass Rectangle >, use <1>: Improved Figure Class.
                                                            (line  12)
* <FindAreas SubClass Triangle >, definition: FindAreas SubClass Triangle Node.
                                                            (line   6)
* <FindAreas SubClass Triangle >, use:   Applying Method Overriding.
                                                            (line  15)
* <FindAreas SubClass Triangle >, use <1>: Improved Figure Class.
                                                            (line  12)
* <FindAreas SuperClass Figure >, definition: FindAreas SuperClass Figure Node.
                                                            (line   6)
* <FindAreas SuperClass Figure >, use:   Applying Method Overriding.
                                                            (line  15)
* <GenMethDemo Main>, definition:        GenMethDemo Main.  (line   6)
* <GenMethDemo Main>, use:               Example of Generic Method.
                                                            (line  13)
* <Get Value>, definition:               GenDemo as Integer.
                                                            (line  91)
* <Get Value>, use:                      GenDemo as Integer.
                                                            (line   6)
* <Import java.io>, definition:          Import java.io.    (line   6)
* <Import java.io>, use:                 Reading Characters.
                                                            (line  24)
* <Import java.io>, use <1>:             Reading Strings.   (line  20)
* <Instance Methods Show and Get>, definition: Class TwoGen.
                                                            (line  67)
* <Instance Methods Show and Get>, use:  Class TwoGen.      (line   6)
* <Instance Variable ob of Type T>, definition: Class Gen<T>.
                                                            (line  63)
* <Instance Variable ob of Type T>, use: Class Gen<T>.      (line  33)
* <Integer Type Parameter>, definition:  GenDemo as Integer.
                                                            (line  36)
* <Integer Type Parameter>, use:         GenDemo as Integer.
                                                            (line   6)
* <Makefile CLEAN>, definition:          Makefile Clean.    (line   6)
* <Makefile CLEAN>, use:                 The Makefile.      (line   6)
* <Makefile CONSTANTS>, definition:      Makefile Constants.
                                                            (line   6)
* <Makefile CONSTANTS>, use:             The Makefile.      (line   6)
* <Makefile DEFAULTS>, definition:       Makefile Defaults. (line   6)
* <Makefile DEFAULTS>, use:              The Makefile.      (line   6)
* <Makefile TANGLE WEAVE>, definition:   Makefile Tangle Weave.
                                                            (line   6)
* <Makefile TANGLE WEAVE>, use:          The Makefile.      (line   6)
* <Method returning object of type T>, definition: Class Gen<T>.
                                                            (line  97)
* <Method returning object of type T>, use: Class Gen<T>.   (line  33)
* <Method showing type of T>, definition: Class Gen<T>.     (line 115)
* <Method showing type of T>, use:       Class Gen<T>.      (line  33)
* <Rectangle Area Method Declaration >, definition: FindAreas SubClass Rectangle Node.
                                                            (line  43)
* <Rectangle Area Method Declaration >, use: FindAreas SubClass Rectangle Node.
                                                            (line   6)
* <Rectangle Constructor >, definition:  FindAreas SubClass Rectangle Node.
                                                            (line  31)
* <Rectangle Constructor >, use:         FindAreas SubClass Rectangle Node.
                                                            (line   6)
* <Reference to Integer Instance>, definition: GenDemo as Integer.
                                                            (line  58)
* <Reference to Integer Instance>, use:  GenDemo as Integer.
                                                            (line   6)
* <Show Type>, definition:               GenDemo as Integer.
                                                            (line  76)
* <Show Type>, use:                      GenDemo as Integer.
                                                            (line   6)
* <Stack Constructor>, definition:       Stack Constructor Node.
                                                            (line   6)
* <Stack Constructor>, use:              Stack Class.       (line  22)
* <Stack Constructor>, use <1>:          Improved Stack Class.
                                                            (line  11)
* <Stack Instance Methods>, definition:  Stack Instance Methods Node.
                                                            (line   6)
* <Stack Instance Methods>, use:         Stack Class.       (line  22)
* <Stack Instance Methods>, use <1>:     Improved Stack Class.
                                                            (line  11)
* <Stack Instance Variables>, definition: Stack Instance Variables.
                                                            (line   6)
* <Stack Instance Variables>, use:       Stack Class.       (line  22)
* <Stack Pop>, definition:               Stack Push and Pop Node.
                                                            (line  19)
* <Stack Pop>, use:                      Stack Instance Methods Node.
                                                            (line   6)
* <Stack Private Instance Variables>, definition: Improved Stack Class.
                                                            (line  31)
* <Stack Private Instance Variables>, use: Improved Stack Class.
                                                            (line  11)
* <Stack Push>, definition:              Stack Push and Pop Node.
                                                            (line   6)
* <Stack Push>, use:                     Stack Instance Methods Node.
                                                            (line   6)
* <Static Method isIn>, definition:      Method isIn.       (line   9)
* <Static Method isIn>, use:             Example of Generic Method.
                                                            (line  13)
* <TestStack Main Method>, definition:   Stack TestStack Node.
                                                            (line   6)
* <TestStack Main Method>, use:          Stack Class.       (line  42)
* <Triangle Area Method Declaration >, definition: FindAreas SubClass Triangle Node.
                                                            (line  42)
* <Triangle Area Method Declaration >, use: FindAreas SubClass Triangle Node.
                                                            (line   6)
* <Triangle Constructor >, definition:   FindAreas SubClass Triangle Node.
                                                            (line  30)
* <Triangle Constructor >, use:          FindAreas SubClass Triangle Node.
                                                            (line   6)
* <Two Instance Variables Declarations>, definition: Class TwoGen.
                                                            (line  43)
* <Two Instance Variables Declarations>, use: Class TwoGen. (line   6)
* ==:                                    Enumeration Basics.
                                                            (line  38)
* {AbstractAreas.java }, definition:     Improved Figure Class.
                                                            (line  12)
* {BRRead.java}, definition:             Reading Characters.
                                                            (line  24)
* {BRReadLines.java}, definition:        Reading Strings.   (line  20)
* {FindAreas.java }, definition:         Applying Method Overriding.
                                                            (line  15)
* {GenMethDemo.java}, definition:        Example of Generic Method.
                                                            (line  13)
* {Makefile}, definition:                The Makefile.      (line   6)
* {SimpleGenerics.java}, definition:     Simple Generics Example.
                                                            (line   9)
* {Stack.java}, definition:              Stack Class.       (line  22)
* {StackImproved.java}, definition:      Improved Stack Class.
                                                            (line  11)
* {TestStack.java}, definition:          Stack Class.       (line  42)
* {TwoTypeParameters.java}, definition:  Two Types Example Code.
                                                            (line   6)
* abstract class:                        Interfaces.        (line   6)
* abstract class, inheritance:           Using Abstract Classes.
                                                            (line   6)
* abstract method:                       Using Abstract Classes.
                                                            (line   6)
* abstract methods, interface:           Defining Interfaces.
                                                            (line  22)
* abstract methods, interface <1>:       Default Interface Methods.
                                                            (line   6)
* abstract over types:                   Generics.          (line   6)
* abstract type modifier:                Using Abstract Classes.
                                                            (line   6)
* access control table:                  Member Access.     (line  27)
* access control, packages:              Member Access.     (line   6)
* access control, single class:          Access Control.    (line   6)
* access modifiers:                      Access Control.    (line   6)
* access, member:                        Member Access.     (line   6)
* accessibility:                         Packages Intro.    (line   6)
* anonymous inner classes:               Nested and Inner Classes.
                                                            (line   6)
* API, Stream:                           Streams API.       (line   5)
* argument passing:                      Argument Passing.  (line   6)
* arguments, command-line:               Command-Line Arguments.
                                                            (line   6)
* arguments, varargs:                    Varargs.           (line   6)
* Arrays:                                Arrays 2.          (line   6)
* arrays as objects:                     Arrays 2.          (line   6)
* assert:                                I/O.               (line   6)
* auto-boxing, generics:                 Reference Types.   (line   6)
* auto-unboxing, generics:               Reference Types.   (line   6)
* autoboxing in generic reference:       GenDemo as Integer.
                                                            (line  46)
* AWT:                                   AWT.               (line   6)
* AWT Controls:                          AWT Controls.      (line   6)
* AWT Layout Managers, Menus:            AWT Controls.      (line   5)
* binary data, reading and writing:      Byte Streams Character Streams.
                                                            (line   6)
* binding, late, early:                  final to Prevent Overriding.
                                                            (line   6)
* bounded types:                         Bounded Types.     (line   6)
* bounded wildcards:                     Bounded Wildcards. (line   6)
* bounded wildcards, lower bound:        Bounded Wildcards. (line  32)
* bounded wildcards, upper bound:        Bounded Wildcards. (line  18)
* bounded wildcards, upper bound <1>:    Bounded Wildcards. (line  20)
* BRRead BufferedReader Constructor:     BRRead BufferedReader Constructor Node.
                                                            (line   6)
* BRRead Enter Characters:               BRRead Enter Characters Node.
                                                            (line   6)
* BRRead.java:                           Reading Characters.
                                                            (line  19)
* BRReadLines BufferedReader Constructor: BRReadLines BufferedReader Constructor.
                                                            (line   6)
* BRReadLines Enter Lines:               BRReadLines Enter Lines.
                                                            (line   6)
* BRReadLines.java:                      Reading Strings.   (line  16)
* BufferedReader:                        Reading Console Input.
                                                            (line  13)
* Byte Stream Class:                     Byte Stream Class. (line   6)
* Byte Streams, definition:              Byte Streams Character Streams.
                                                            (line   6)
* casts, eliminated in generics:         Type Safety.       (line   6)
* casts, generics, automatic, implicit:  What are Generics. (line   6)
* Character Stream Class:                Character Stream Class.
                                                            (line   6)
* Character Streams, definition:         Byte Streams Character Streams.
                                                            (line   6)
* character streams, Unicode:            Character Stream Class.
                                                            (line   6)
* character-based stream:                Reading Console Input.
                                                            (line   6)
* characters, reading:                   Reading Characters.
                                                            (line   6)
* charAT():                              String Class.      (line  33)
* Class:                                 Class Gen<T>.      (line 107)
* Class fundamentals:                    Class Fundamentals.
                                                            (line   6)
* class name, from getName():            Class Gen<T>.      (line 107)
* class namespace, compartmentalize:     Packages.          (line   6)
* Class object, from getClass():         Class Gen<T>.      (line 107)
* class String:                          String Class.      (line   6)
* class, general form:                   General Form.      (line   6)
* class, new data type:                  Class Fundamentals.
                                                            (line   6)
* classed in java.lang:                  java Lang.         (line  14)
* Classes:                               Classes.           (line   6)
* classes, nested and inner:             Nested and Inner Classes.
                                                            (line   6)
* CLASSPATH -classpath:                  Classpath.         (line   6)
* Collections Framework:                 Generics.          (line   6)
* collections, generics:                 Generics.          (line   6)
* collisions, prevention:                Packages.          (line   6)
* command-line arguments:                Command-Line Arguments.
                                                            (line   6)
* compartmentalized:                     Packages.          (line   6)
* compile time:                          Interfaces.        (line  19)
* compile-time type check:               Motivation.        (line  31)
* Concurrency Utilities:                 Concurrency.       (line   5)
* console I/O:                           I/O Basics.        (line   6)
* console input, reading:                Reading Console Input.
                                                            (line   6)
* constant, final variable:              final Keyword.     (line   6)
* Constants:                             Makefile Constants.
                                                            (line   6)
* constructor:                           Declaring Objects. (line   6)
* Constructors:                          Constructors.      (line   6)
* constructors, overloading:             Overloading Constructors.
                                                            (line   6)
* containers, packages as:               Packages.          (line   6)
* creating generic method:               Generic Methods.   (line   6)
* data type, enumeration:                Enumerations.      (line   6)
* default access level:                  Access Control.    (line  28)
* default method, interface, motivation: Default Interface Methods.
                                                            (line  15)
* default methods, interface:            Default Interface Methods.
                                                            (line   6)
* default package:                       Defining Packages. (line   6)
* difference between class and interface: Default Interface Methods.
                                                            (line  32)
* dispatch through an interface:         Interface References.
                                                            (line   6)
* dot operator:                          General Form.      (line  48)
* dynamic allocation, run time:          Declaring Objects. (line   6)
* dynamic dispatch, interface method look-ups: Interface References.
                                                            (line   6)
* dynamic method dispatch:               Dynamic Method Dispatch.
                                                            (line   6)
* dynamic method resolution:             Interfaces.        (line  19)
* early binding:                         final to Prevent Overriding.
                                                            (line   6)
* encapsulation, access control:         Access Control.    (line   6)
* enum valueOf():                        Enum Methods.      (line   6)
* enum values():                         Enum Methods.      (line   6)
* enum variable, declare:                Enumeration Basics.
                                                            (line  25)
* enumeration capabilities:              Enumerations.      (line   6)
* enumeration comparison:                Enumeration Basics.
                                                            (line  38)
* enumeration constants:                 Enumeration Basics.
                                                            (line  15)
* enumeration constants <1>:             Enumerations as Class Types.
                                                            (line   6)
* enumeration constructor:               Enumerations as Class Types.
                                                            (line   6)
* enumeration instance variables:        Enumerations as Class Types.
                                                            (line   6)
* enumeration methods:                   Enum Methods.      (line   6)
* enumeration methods <1>:               Enumerations as Class Types.
                                                            (line   6)
* enumeration object:                    Enumerations.      (line   6)
* enumeration restrictions:              Enumerations as Class Types.
                                                            (line  41)
* enumeration variable:                  Enumeration Basics.
                                                            (line  25)
* Enumeration, basics:                   Enumeration Basics.
                                                            (line   6)
* Enumerations:                          Enumerations.      (line   6)
* enumerations as class types:           Enumerations as Class Types.
                                                            (line   6)
* enumerations inherit Enum:             Inherit Enum.      (line   6)
* enums, printing:                       Enumeration Basics.
                                                            (line  51)
* equality, enum types:                  Enumeration Basics.
                                                            (line  38)
* equals():                              String Class.      (line  33)
* equals() <1>:                          Object Class.      (line  49)
* erasure:                               Class GenDemo.     (line   6)
* err:                                   Predefined Streams.
                                                            (line   6)
* Event Handling:                        Event Handling.    (line   5)
* example generic method:                Example of Generic Method.
                                                            (line   6)
* example, generics:                     Simple Generics Example.
                                                            (line   6)
* exposure of code:                      Packages Intro.    (line   6)
* extending interfaces:                  Extending Interfaces.
                                                            (line   6)
* extends clause:                        Bounded Types.     (line   6)
* extends keyword:                       Inheritance Basics.
                                                            (line   6)
* extents, with interfaces:              Extending Interfaces.
                                                            (line   6)
* final Keyword:                         final Keyword.     (line   6)
* final to prevent inheritance:          final to Prevent Inheritance.
                                                            (line   6)
* final to prevent overriding:           final to Prevent Overriding.
                                                            (line   6)
* final with inheritance:                final with Inheritance.
                                                            (line   6)
* final, traditional enums:              Enumerations.      (line   6)
* finding packages:                      Classpath.         (line   6)
* fully qualified name:                  Importing.         (line  39)
* generic class:                         Simple Generics Example.
                                                            (line   6)
* generic class <1>:                     Class Gen<T>.      (line   6)
* generic class, general form:           Generic Class General Form.
                                                            (line   6)
* generic class, method:                 What are Generics. (line   6)
* generic class, two type parameters:    Two Type Parameters.
                                                            (line   6)
* generic code, demonstrating an implementation: Class GenDemo.
                                                            (line   6)
* generic constructors:                  Generic Constructors.
                                                            (line   6)
* generic interface:                     Motivation.        (line  31)
* generic method, creating:              Generic Methods.   (line   6)
* generic method, example:               Example of Generic Method.
                                                            (line   6)
* generic method, static:                Method isIn.       (line  28)
* generic methods, including type arguments: Method isIn.   (line  34)
* generic reference assignment to Integer: GenDemo as Integer.
                                                            (line  46)
* generic reference to Integer:          GenDemo as Integer.
                                                            (line  28)
* generic reference, creating:           GenDemo as Integer.
                                                            (line   6)
* generic type argument, reference type: Reference Types.   (line   6)
* generic type checking:                 GenDemo as Integer.
                                                            (line  46)
* generic types differ, type arguments:  Type Arguments.    (line   6)
* Generics (chapter):                    Generics.          (line   6)
* generics eliminate casts:              Type Safety.       (line   6)
* generics ensure type safety:           Type Safety.       (line   6)
* generics example:                      Simple Generics Example.
                                                            (line   6)
* generics improve type safety:          Type Safety.       (line   6)
* generics, bounded types:               Bounded Types.     (line   6)
* generics, casts:                       What are Generics. (line   6)
* generics, compile-time error, mismatched types: GenDemo as Integer.
                                                            (line  46)
* generics, generic constructors:        Generic Constructors.
                                                            (line   6)
* generics, interface as bound:          Bounded Types.     (line  22)
* generics, introduction:                Generics.          (line   6)
* generics, motivation:                  Motivation.        (line   6)
* generics, motivation, readability and robustness: Motivation.
                                                            (line  31)
* generics, only reference types:        Reference Types.   (line   6)
* generics, subtyping:                   Subtyping.         (line   6)
* generics, two type arguments:          Class TwoGen.      (line  29)
* generics, two type parameters, declaration: Class TwoGen. (line  29)
* generics, type safety benefit:         GenDemo as Integer.
                                                            (line  46)
* generics, what they are:               What are Generics. (line   6)
* generics, wildcard arguments:          Wildcard Arguments.
                                                            (line   6)
* getClass(), defined in Object:         Class Gen<T>.      (line 107)
* getName(), defined in Class:           Class Gen<T>.      (line 107)
* global members:                        static Keyword.    (line  55)
* Graphics:                              AWT.               (line   6)
* hiding, instance variables:            Instance Variable Hiding.
                                                            (line   6)
* hierarchical classifications:          Inheritance.       (line   6)
* hierarchical structure, packages:      Packages.          (line   6)
* hierarchy of packages:                 Defining Packages. (line  41)
* hierarchy, constructors executed:      Constructors Executed.
                                                            (line   6)
* hierarchy, files:                      Multilevel Hierarchy.
                                                            (line   6)
* hierarchy, multilevel, creating:       Multilevel Hierarchy.
                                                            (line   6)
* I/O:                                   I/O.               (line   6)
* I/O Basics:                            I/O Basics.        (line   6)
* Images:                                Images.            (line   5)
* implements clause:                     Implementing Interfaces.
                                                            (line   6)
* import is optional:                    Importing.         (line  39)
* import java.io:                        Import java.io.    (line   6)
* import packages:                       Packages.          (line   6)
* import statement, general form and example: Importing.    (line  14)
* imported packages must be public:      Importing.         (line  43)
* importing packages:                    Importing.         (line   6)
* in:                                    Predefined Streams.
                                                            (line   6)
* index interface, default methods:      Default Interface Methods.
                                                            (line   6)
* Inheritance:                           Inheritance.       (line   6)
* inheritance basics:                    Inheritance Basics.
                                                            (line   6)
* inheritance, member access:            Member Access and Inheritance.
                                                            (line   6)
* inheriting interfaces:                 Extending Interfaces.
                                                            (line   6)
* inline, inlining:                      final to Prevent Overriding.
                                                            (line   6)
* inner classes:                         Nested and Inner Classes.
                                                            (line   6)
* inner classes, anonymous:              Nested and Inner Classes.
                                                            (line   6)
* inner classes, event handling:         Nested and Inner Classes.
                                                            (line   6)
* input stream:                          Streams.           (line   6)
* input/output system:                   I/O.               (line   6)
* InputStream:                           Reading Console Input.
                                                            (line  13)
* InputStreamReader concrete subclass:   Reading Console Input.
                                                            (line  13)
* instance variables:                    General Form.      (line  32)
* instance, class:                       Class Fundamentals.
                                                            (line   6)
* instanceof:                            I/O.               (line   6)
* intefaces, applying:                   Applying Interfaces.
                                                            (line   6)
* interface as bound, generics:          Bounded Types.     (line  22)
* interface default access, no modified: Defining Interfaces.
                                                            (line  22)
* interface definition, simplified general form: Defining Interfaces.
                                                            (line   7)
* interface method defintion, declared public: Implementing Interfaces.
                                                            (line  18)
* interface methods, abstract methods:   Defining Interfaces.
                                                            (line  22)
* interface methods, private:            Private Interface Methods.
                                                            (line   6)
* interface public access:               Defining Interfaces.
                                                            (line  22)
* interface references, accessing implementations: Interface References.
                                                            (line   6)
* interface variable declarations:       Defining Interfaces.
                                                            (line  35)
* interface, implement:                  Interfaces.        (line   6)
* interface, partial implementation:     Partial Implementations.
                                                            (line   6)
* interface, static method:              Interface Static Methods.
                                                            (line   6)
* interface, traditional form:           Default Interface Methods.
                                                            (line   6)
* Interfaces (chapter):                  Interfaces.        (line   6)
* interfaces in java.lang:               java Lang.         (line  62)
* interfaces, defining:                  Defining Interfaces.
                                                            (line   6)
* interfaces, extending:                 Extending Interfaces.
                                                            (line   6)
* interfaces, final variables in:        Variables in Interfaces.
                                                            (line   6)
* interfaces, implementing:              Implementing Interfaces.
                                                            (line   6)
* interfaces, inheriting:                Extending Interfaces.
                                                            (line   6)
* interfaces, introduction:              Interfaces.        (line   6)
* interfaces, key aspect, no state:      Default Interface Methods.
                                                            (line  32)
* interfaces, key feature, reference look-ups: Interface References.
                                                            (line   6)
* interfaces, nested:                    Nested Interfaces. (line   6)
* interfaces, shared constants:          Variables in Interfaces.
                                                            (line   6)
* internationalization, character streams: Byte Streams Character Streams.
                                                            (line   6)
* internationalization, character streams <1>: Reading Console Input.
                                                            (line   6)
* introduction to Java SE 9:             Java SE 9 Introduction.
                                                            (line   5)
* Introduction to Packages (section):    Packages Intro.    (line   6)
* iteration, iterative:                  Recursion.         (line   6)
* J2SE 5.0:                              Generics.          (line   6)
* Java I/O system:                       Streams.           (line   6)
* Java SE 9 introduction:                Java SE 9 Introduction.
                                                            (line   6)
* java.io:                               I/O.               (line   6)
* java.io <1>:                           Character Stream Class.
                                                            (line   6)
* java.io <2>:                           java io Input Output.
                                                            (line   5)
* java.io package:                       Streams.           (line   6)
* java.lang:                             Importing.         (line  29)
* java.lang <1>:                         java Lang.         (line   6)
* java.util Collections Framework:       java util Collections.
                                                            (line   5)
* java.util Utility Classes:             java util Utility Classes.
                                                            (line   5)
* JDK 5:                                 Enumerations.      (line   6)
* JDK 8, default method in interface:    Default Interface Methods.
                                                            (line   6)
* JDK 8, static interface method:        Interface Static Methods.
                                                            (line   6)
* JDK 9, package part of module:         Classpath.         (line   6)
* JDK 9, private interface method:       Private Interface Methods.
                                                            (line   6)
* keyword extends:                       Inheritance Basics.
                                                            (line   6)
* keyword final:                         final Keyword.     (line   6)
* keyword interface:                     Interfaces.        (line   6)
* keyword static:                        static Keyword.    (line   6)
* keyword, enum:                         Enumeration Basics.
                                                            (line   6)
* late binding:                          final to Prevent Overriding.
                                                            (line   6)
* length instance variable:              Arrays 2.          (line   6)
* length():                              String Class.      (line  33)
* lower bounded wildcard:                Bounded Wildcards. (line  32)
* main() method, class:                  General Form.      (line  45)
* Makefiel Weave:                        Makefile Tangle Weave.
                                                            (line   6)
* Makefile Clean targets:                Makefile Clean.    (line   6)
* Makefile defaults:                     Makefile Defaults. (line   6)
* Makefile Tangle:                       Makefile Tangle Weave.
                                                            (line   6)
* Makefile, The (appendix):              The Makefile.      (line   6)
* member access:                         Member Access.     (line   6)
* member access, inheritance:            Member Access and Inheritance.
                                                            (line   6)
* member hiding:                         super Referencing Superclass.
                                                            (line   6)
* member interfaces:                     Nested Interfaces. (line   6)
* members:                               General Form.      (line  32)
* method overriding:                     Method Overriding. (line   6)
* method signatures compatible:          Interfaces.        (line  19)
* method, static, interface:             Interface Static Methods.
                                                            (line   6)
* method, varargs:                       Varargs.           (line   6)
* methods:                               General Form.      (line  32)
* Methods:                               Methods.           (line   6)
* Methods and Classes:                   Methods and Classes.
                                                            (line   6)
* methods, enumeration:                  Enum Methods.      (line   6)
* methods, overloading:                  Overloading Methods.
                                                            (line   6)
* module path:                           Classpath.         (line   6)
* modules, packages:                     Classpath.         (line   6)
* multilevel hierarchy:                  Multilevel Hierarchy.
                                                            (line   6)
* name, method:                          Methods.           (line  15)
* naming mechanism:                      Packages Intro.    (line   6)
* native:                                I/O.               (line   6)
* nested classes:                        Nested and Inner Classes.
                                                            (line   6)
* nested interfaces:                     Nested Interfaces. (line   6)
* Networking:                            Networking.        (line   5)
* new operator:                          Declaring Objects. (line   6)
* NIO:                                   NIO.               (line   5)
* Object:                                Class Gen<T>.      (line 107)
* Object class:                          Object Class.      (line   6)
* object references, interfaces:         Interface References.
                                                            (line   6)
* Object type:                           What are Generics. (line   6)
* object, class:                         Class Fundamentals.
                                                            (line   6)
* objects as parameters:                 Objects as Parameters.
                                                            (line   6)
* objects, declaring:                    Declaring Objects. (line   6)
* objects, dynamical allocation:         Returning Objects. (line   6)
* objects, references to:                Returning Objects. (line   6)
* objects, returning from methods:       Returning Objects. (line   6)
* one interface, many methods polymorphism: Why Overridden Methods.
                                                            (line   6)
* _one interface, multiple methods_:     Overloading Methods.
                                                            (line   6)
* out:                                   Predefined Streams.
                                                            (line   6)
* output stream:                         Streams.           (line   6)
* overload versus override:              Method Overriding. (line   6)
* overload, overloaded:                  Overloading Methods.
                                                            (line   6)
* overloading constructors:              Overloading Constructors.
                                                            (line   6)
* overloading methods:                   Overloading Methods.
                                                            (line   6)
* overloading, automatic type conversion: Overloading Methods.
                                                            (line   6)
* overriding, method:                    Method Overriding. (line   6)
* package command:                       Defining Packages. (line   6)
* package namespace:                     Defining Packages. (line   6)
* package renaming:                      Defining Packages. (line  56)
* package statement:                     Defining Packages. (line   6)
* package statement, example:            Defining Packages. (line  20)
* package statement, general form:       Defining Packages. (line  16)
* package statement, multilevel form:    Defining Packages. (line  43)
* package, java.io:                      Streams.           (line   6)
* Packages (chapter):                    Packages.          (line   6)
* packages hierarchy:                    Defining Packages. (line  41)
* packages stored in file system:        Defining Packages. (line  27)
* packages, access control:              Member Access.     (line   6)
* Packages, Defining (section):          Defining Packages. (line   6)
* packages, finding, example:            Classpath.         (line  26)
* packages, how stored:                  Packages.          (line   6)
* packages, import:                      Packages.          (line   6)
* packages, importing:                   Importing.         (line   6)
* packages, purposes, prevent collisions: Packages.         (line   6)
* parameter list, method:                Methods.           (line  15)
* parameter, generic class:              Class Gen<T>.      (line   6)
* parameterized type:                    Class Gen<T>.      (line   6)
* parameterized types:                   What are Generics. (line   6)
* parameters, as objects:                Objects as Parameters.
                                                            (line   6)
* partitioning mechanism:                Packages Intro.    (line   6)
* performance enhancement, inlining:     final to Prevent Overriding.
                                                            (line   6)
* polymorphism, dynamic run-time:        Why Overridden Methods.
                                                            (line   6)
* polymorphism, one interface multiple methods: Interfaces. (line   6)
* polymorphism, overloading of methods:  Overloading Methods.
                                                            (line   6)
* polymorphism, run-time:                Dynamic Method Dispatch.
                                                            (line   6)
* Predefined Streams:                    Predefined Streams.
                                                            (line   6)
* preexisting code, default method, interface: Default Interface Methods.
                                                            (line  15)
* Primitive Wrappers:                    Primitive Wrappers.
                                                            (line   6)
* private access modifier:               Access Control.    (line  28)
* private and inheritance:               Member Access and Inheritance.
                                                            (line   6)
* protected access modifier:             Access Control.    (line  28)
* public access modifier:                Access Control.    (line  28)
* read(), from BufferedReader:           Reading Characters.
                                                            (line   6)
* read(), InputStream abstract class:    Byte Stream Class. (line  58)
* read(), Reader:                        Character Stream Class.
                                                            (line  55)
* Reader abstract class:                 Character Stream Class.
                                                            (line   6)
* Reader abstract class <1>:             Reading Console Input.
                                                            (line  13)
* reading characters:                    Reading Characters.
                                                            (line   6)
* Reading Console Input:                 Reading Console Input.
                                                            (line   6)
* reading strings:                       Reading Strings.   (line   6)
* recursion, recursive:                  Recursion.         (line   6)
* reference variable, superclass:        Superclass Referencing Subclass.
                                                            (line   6)
* Regular Expressions:                   Regular Expressions.
                                                            (line   5)
* run time, dynamic allocation:          Declaring Objects. (line   6)
* run-time:                              Interfaces.        (line  19)
* run-time polymorphism, abstract class: Using Abstract Classes.
                                                            (line  52)
* run-time system, finding packages:     Classpath.         (line   6)
* self-typed constants:                  Enumeration Basics.
                                                            (line  15)
* Stack Class:                           Stack Class.       (line   6)
* Stack class, improved:                 Improved Stack Class.
                                                            (line   6)
* stack exhaustion, recursion:           Recursion.         (line   6)
* stack overun, recursion:               Recursion.         (line   6)
* standard Java classes, imported implicitly: Importing.    (line  29)
* static and non-static nested classes:  Nested and Inner Classes.
                                                            (line   6)
* static environment:                    Interfaces.        (line  19)
* static generic method:                 Method isIn.       (line  28)
* static initialization block:           static Keyword.    (line  34)
* static Keyword:                        static Keyword.    (line   6)
* static members:                        static Keyword.    (line   6)
* static method, interface:              Interface Static Methods.
                                                            (line   6)
* static restrictions on methods:        static Keyword.    (line  24)
* Stream API:                            Streams API.       (line   6)
* Stream Class, Byte:                    Byte Stream Class. (line   6)
* Stream Class, Character:               Character Stream Class.
                                                            (line   6)
* stream definition:                     Streams.           (line   6)
* stream variables, predefined:          Predefined Streams.
                                                            (line   6)
* stream, character-based:               Reading Console Input.
                                                            (line   6)
* stream, input:                         Streams.           (line   6)
* stream, output:                        Streams.           (line   6)
* Streams:                               Streams.           (line   6)
* Streams, Character:                    Byte Streams Character Streams.
                                                            (line   6)
* Streams, Predefined:                   Predefined Streams.
                                                            (line   6)
* strictfp:                              I/O.               (line   6)
* String Class:                          String Class.      (line   6)
* String concatenation:                  String Class.      (line  20)
* String construction:                   String Class.      (line  20)
* String Handling:                       Strings.           (line   5)
* String methods:                        String Class.      (line  33)
* String operator +:                     String Class.      (line  20)
* Strings:                               Strings.           (line   6)
* strings, reading:                      Reading Strings.   (line   6)
* subclass:                              Inheritance.       (line   6)
* super calling superclass constructors: super Calling Superclass Constructor.
                                                            (line   6)
* super referencing superclass:          super Referencing Superclass.
                                                            (line   6)
* super, using:                          Using super.       (line   6)
* superclass:                            Inheritance.       (line   6)
* superclass referencing subclass:       Superclass Referencing Subclass.
                                                            (line   6)
* Swing:                                 Swing.             (line   5)
* switch statement, enum types:          Enumeration Basics.
                                                            (line  38)
* System class:                          Predefined Streams.
                                                            (line   6)
* System.in:                             Reading Console Input.
                                                            (line  13)
* template, class:                       Class Fundamentals.
                                                            (line   6)
* Text:                                  AWT.               (line   5)
* text-based console programs:           I/O Basics.        (line   6)
* this Keyword:                          this Keyword.      (line   6)
* toString():                            Object Class.      (line  49)
* try-with-resources:                    I/O.               (line   6)
* type abstraction, generics:            Generics.          (line   6)
* type argument, passed to type parameter: GenDemo as Integer.
                                                            (line   6)
* type correctness:                      Motivation.        (line  31)
* type erasure:                          Class GenDemo.     (line   6)
* type parameter:                        Motivation.        (line  31)
* type parameter, generic class:         Class Gen<T>.      (line   6)
* type safety, generics:                 What are Generics. (line   6)
* type wrappers:                         Primitive Wrappers.
                                                            (line   6)
* type wrappers, generics:               Reference Types.   (line   6)
* type, method:                          Methods.           (line  15)
* Unicode:                               Byte Streams Character Streams.
                                                            (line   6)
* Unicode character streams:             Character Stream Class.
                                                            (line   6)
* Unicode character streams <1>:         Character Stream Class.
                                                            (line   6)
* upper bound:                           Bounded Types.     (line   6)
* upper bound wildcard argument:         Bounded Wildcards. (line  20)
* upper bounded wildcard:                Bounded Wildcards. (line  18)
* vararg ambiguity:                      Varargs.           (line  32)
* vararg overloading:                    Varargs.           (line  32)
* varargs:                               Varargs.           (line   6)
* varargs method:                        Varargs.           (line   6)
* variable, enum type:                   Enumeration Basics.
                                                            (line  25)
* variable-arity method:                 Varargs.           (line   6)
* variable-length arguments:             Varargs.           (line   6)
* visibility mechanism:                  Packages Intro.    (line   6)
* volative:                              I/O.               (line   6)
* wildcard arguments, generics:          Wildcard Arguments.
                                                            (line   6)
* wildcard syntax:                       Wildcard Syntax.   (line   6)
* wildcards, bounded:                    Bounded Wildcards. (line   6)
* wildcards, motivation:                 Wildcard Motivation.
                                                            (line   6)
* Windows:                               AWT.               (line   6)
* Wrappers, Primitives:                  Primitive Wrappers.
                                                            (line   6)
* write(), OutputStream abstract class:  Byte Stream Class. (line  58)
* write(), Writer:                       Character Stream Class.
                                                            (line  55)
* Writer abstract class:                 Character Stream Class.
                                                            (line   6)


File: JavaSE9.info,  Node: Function Index,  Prev: Concept Index,  Up: Top

Function Index
**************

 [index ]
* Menu:

* == on Enum:                            Inherit Enum.       (line 37)
* boolean equals(Object object):         Object Class.       (line 21)
* Class<?> getClass():                   Object Class.       (line 26)
* compareTo on Enum:                     Inherit Enum.       (line 21)
* equals on Enum:                        Inherit Enum.       (line 34)
* int hashCode():                        Object Class.       (line 28)
* Object clone():                        Object Class.       (line 19)
* ordinal on Enum:                       Inherit Enum.       (line 13)
* String toString():                     Object Class.       (line 34)
* valueOf on Enum:                       Enum Methods.       (line 14)
* values on Enum:                        Enum Methods.       (line  8)
* void finalize():                       Object Class.       (line 23)
* void notify():                         Object Class.       (line 30)
* void notifyAll():                      Object Class.       (line 32)
* void wait():                           Object Class.       (line 36)
* void wait(long millisconds, int nanoseconds): Object Class.
                                                             (line 38)
* void wait(long milliseconds):          Object Class.       (line 37)



Tag Table:
Node: Top75
Node: Java SE 9 Introduction5274
Node: Classes5416
Node: Class Fundamentals5860
Node: General Form6276
Ref: ClassDeclaration6616
Node: Declaring Objects8131
Node: Methods9525
Ref: MethodDeclaration9724
Node: Constructors10567
Node: this Keyword11331
Node: Instance Variable Hiding11884
Node: Stack Class12688
Ref: Stack-java13512
Ref: TestStack-java14067
Node: Stack Instance Variables14368
Ref: Stack-Instance-Variables14535
Node: Stack Constructor Node14701
Ref: Stack-Constructor14912
Node: Stack Instance Methods Node15291
Ref: Stack-Instance-Methods15508
Node: Stack Push and Pop Node16170
Ref: Stack-Push16341
Ref: Stack-Pop16649
Node: Stack TestStack Node16978
Ref: TestStack-Main-Method17150
Node: Methods and Classes17878
Node: Overloading Methods18584
Node: Overloading Constructors20894
Node: Objects as Parameters21082
Node: Argument Passing21758
Node: Returning Objects23100
Node: Recursion23727
Node: Access Control25239
Node: Improved Stack Class28184
Ref: StackImproved-java28418
Ref: Stack-Private-Instance-Variables29056
Ref: Improved Stack Class-Footnote-130080
Node: static Keyword30199
Node: final Keyword32638
Node: Arrays 233541
Node: Nested and Inner Classes34238
Node: String Class36363
Node: Command-Line Arguments37620
Node: Varargs38444
Node: Inheritance40260
Node: Inheritance Basics41215
Ref: Subclass41811
Node: Member Access and Inheritance42141
Node: Superclass Referencing Subclass42917
Node: Using super43697
Node: super Calling Superclass Constructor44225
Ref: SuperCallingConstructor44554
Node: super Referencing Superclass44861
Ref: SuperReferencingSuperclass45197
Node: Multilevel Hierarchy45623
Node: Constructors Executed46378
Node: Method Overriding46688
Node: Dynamic Method Dispatch47574
Node: Why Overridden Methods49021
Node: Applying Method Overriding50571
Ref: FindAreas-java-51203
Node: FindAreas SuperClass Figure Node52574
Ref: FindAreas-SuperClass-Figure-52801
Ref: Figure-Instance-Variable-Declarations-53588
Ref: Figure-Constructor-54059
Ref: Figure-Area-Method-Declaration-54874
Node: FindAreas SubClass Rectangle Node55141
Ref: FindAreas-SubClass-Rectangle-55411
Ref: Rectangle-Constructor-56245
Ref: Rectangle-Area-Method-Declaration-56534
Node: FindAreas SubClass Triangle Node56848
Ref: FindAreas-SubClass-Triangle-57109
Ref: Triangle-Constructor-57933
Ref: Triangle-Area-Method-Declaration-58216
Node: FindAreas Main Class Node58537
Ref: FindAreas-Main-Class-58742
Ref: FindAreas-Main-Method-Declaration-59132
Ref: Create-Basic-Figure-Objects-59994
Ref: Create-Basic-Figure-Reference-Variable-60623
Ref: Call-Overridden-Methods-One-By-One-61136
Node: Using Abstract Classes61526
Ref: AbstractMethodDeclaration63036
Node: Improved Figure Class64259
Ref: AbstractAreas-java-64706
Node: AbstractAreas Abstract Class Figure Node65486
Ref: AbstractAreas-Abstract-Class-Figure-65907
Ref: AbstractAreas-Abstract-Area-Method-Declaration-66783
Node: AbstractAreas Main Class67047
Ref: AbstractAreas-Main-Class-67236
Ref: AbstractAreas-Main-Method-Declaration-67662
Ref: Create-Basic-Figure-Objects-Except-Figure-69003
Ref: Call-Overridden-Methods-One-By-One-Except-Figure-69566
Node: final with Inheritance69987
Node: final to Prevent Overriding70390
Node: final to Prevent Inheritance71303
Node: Object Class71723
Node: Packages73860
Node: Packages Intro74318
Node: Defining Packages74862
Ref: PackageStatement75464
Ref: PackageStatementMulti76434
Node: Classpath76857
Node: Member Access78397
Ref: PackageAccess79372
Node: Importing79973
Ref: Import80597
Node: Interfaces81872
Node: Defining Interfaces83975
Ref: InterfaceSimple84230
Node: Implementing Interfaces85560
Ref: ClassImplementsInterface86054
Node: Interface References86539
Node: Partial Implementations87530
Node: Nested Interfaces87964
Node: Applying Interfaces88738
Node: Variables in Interfaces88938
Node: Extending Interfaces89668
Node: Default Interface Methods90147
Node: Interface Static Methods92251
Ref: InterfaceStaticMethod92983
Node: Private Interface Methods93265
Node: I/O94021
Node: I/O Basics94999
Node: Streams96008
Node: Byte Streams Character Streams96814
Node: Byte Stream Class97898
Ref: ByteStreamClasses98536
Node: Character Stream Class100000
Ref: CharacterStreamClasses100551
Node: Predefined Streams101859
Node: Reading Console Input102696
Node: Reading Characters104277
Ref: BRRead-java105178
Ref: Reading Characters-Footnote-1105957
Node: Import java.io106187
Ref: Import-java-io106355
Node: BRRead BufferedReader Constructor Node106678
Ref: BRRead-BufferedReader-Constructor106933
Node: BRRead Enter Characters Node107152
Ref: BRRead-Enter-Characters107364
Node: Reading Strings107593
Ref: BRReadLines-java108217
Node: BRReadLines BufferedReader Constructor108963
Ref: BRReadLines-BufferedReader-Constructor109181
Node: BRReadLines Enter Lines109462
Ref: BRReadLines-Enter-Lines109650
Node: Writing Console Output110007
Node: PrintWriter Class110181
Node: Reading and Writing Files110357
Node: Automatically Closing Files110546
Node: transient and volatile Modifiers110754
Node: Using instanceof110979
Node: strictfp111141
Node: Native Methods111269
Node: Using assert111403
Node: Static Import111542
Node: Overloaded Constructors with this111698
Node: Compact API Profiles111934
Node: Generics112090
Node: Motivation113923
Node: What are Generics115899
Node: Simple Generics Example116966
Ref: SimpleGenerics-java117281
Node: Class Gen<T>117676
Ref: Class-Gen118671
Ref: Instance-Variable-ob-of-Type-T119783
Ref: generics-constructor119983
Ref: Constructor-taking-parameter-of-Type-T120329
Ref: Method-returning-object-of-type-T120865
Ref: Method-showing-type-of-T121490
Node: Class GenDemo121729
Ref: Class-GenDemo122508
Node: GenDemo as Integer123265
Ref: Create-a-Gen-object-for-Integers123477
Ref: Integer-Type-Parameter124607
Ref: Reference-to-Integer-Instance125454
Ref: Show-Type125997
Ref: Get-Value126489
Node: GenDemo as String126730
Ref: Create-a-Gen-object-for-Strings126940
Node: Notes about Generics127395
Node: Reference Types127651
Node: Type Arguments128177
Node: Subtyping128740
Node: Type Safety129874
Node: Two Type Parameters130233
Node: Two Types Example Code130781
Ref: TwoTypeParameters-java130955
Node: Class TwoGen131359
Ref: Class-TwoGen131496
Ref: Class-Declaration132526
Ref: Two-Instance-Variables-Declarations132732
Ref: Constructor-of-Two-Parameters132915
Ref: Instance-Methods-Show-and-Get133171
Node: Class SimpGen133562
Ref: Class-SimpGen133825
Node: Generic Class General Form134394
Ref: GenericClass134701
Node: Bounded Types135025
Node: Wildcard Arguments136423
Node: Wildcard Motivation136668
Node: Wildcard Syntax139215
Node: Bounded Wildcards140133
Ref: UpperBoundedWildcard140954
Ref: LowerBoundedWildcard141334
Node: Generic Methods141499
Ref: GenericMethod141899
Node: Example of Generic Method142067
Ref: GenMethDemo-java142568
Node: Method isIn143022
Ref: Static-Method-isIn143242
Node: GenMethDemo Main144613
Ref: GenMethDemo-Main144763
Node: Generic Constructors145658
Node: Enumerations146025
Node: Enumeration Basics146899
Node: Enum Methods148494
Node: Enumerations as Class Types149721
Node: Inherit Enum151595
Node: Strings153431
Node: java Lang153557
Node: Primitive Wrappers155202
Node: Number155991
Node: Double and Float156107
Node: isInfiinite() and isNaN()156277
Node: Byte Short Integer Long156480
Node: Numbers to from String156693
Node: java util Collections156894
Node: java util Utility Classes157113
Node: java io Input Output157323
Node: NIO157489
Node: Networking157596
Node: Event Handling157711
Node: AWT157834
Node: AWT Controls158021
Node: Images158202
Node: Concurrency158311
Node: Streams API158457
Node: Regular Expressions158594
Node: Swing158773
Node: The Makefile158913
Ref: Makefile159058
Node: Makefile Constants159689
Ref: Makefile-CONSTANTS159830
Node: Makefile Defaults159966
Ref: Makefile-DEFAULTS160149
Node: Makefile Tangle Weave160299
Ref: Makefile-TANGLE-WEAVE160488
Node: Makefile Clean160880
Ref: Makefile-CLEAN161029
Node: Code Chunk Summaries161216
Node: File Definitions161706
Node: Code Chunk Definitions162700
Node: Code Chunk References168354
Node: List of Tables178621
Node: List of General Forms178977
Node: Bibliography180373
Node: Concept Index180505
Node: Function Index241750

End Tag Table
