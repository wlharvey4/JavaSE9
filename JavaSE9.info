This is JavaSE9.info, produced by makeinfo version 6.5 from
JavaSE9.texi.


File: JavaSE9.info,  Node: Top,  Next: Java SE 9 Introduction,  Up: (dir)

General Introduction
********************

This file documents Outline Covering Java SE 9.

* Menu:

* Java SE 9 Introduction::
* Classes::
* Methods and Classes::
* Inheritance::
* Packages::
* Interfaces::
* Generics::
* Enumerations::
* Strings::
* java Lang::
* java util Collections::
* java util Utility Classes::
* java io Input Output::
* NIO::
* Networking::
* Event Handling::
* AWT::
* AWT Controls::
* Images::
* Concurrency::
* Streams::
* Regular Expressions::
* Swing::
* The Makefile::
* Code Chunk Summaries::
* List of Tables::
* List of General Forms::
* Bibliography::
* Concept Index::
* Function Index::

 -- The Detailed Node Listing --

Classes

* Class Fundamentals::
* Declaring Objects::
* Methods::
* Constructors::
* this Keyword::
* Stack Class::

Class Fundamentals

* General Form::

The 'this' Keyword

* Instance Variable Hiding::

TestStack.java

* Stack Instance Variables::
* Stack Constructor Node::
* Stack Instance Methods Node::
* Stack TestStack Node::

Stack Instance Methods Subsection

* Stack Push and Pop Node::

Methods and Classes

* Overloading Methods::
* Objects as Parameters::
* Argument Passing::
* Returning Objects::
* Recursion::
* Access Control::
* static Keyword::
* final Keyword::
* Arrays 2::
* Nested and Inner Classes::
* The String Class::
* Command-Line Arguments::
* Varargs::

Overloading Methods

* Overloading Constructors::

Access Control and Inheritance

* Improved Stack Class::

Packages

* Packages Intro::
* Defining Packages::
* Classpath::
* Member Access::
* Importing::

Interfaces

* Defining Interfaces::
* Implementing Interfaces::
* Interface References::
* Partial Implementations::
* Nested Interfaces::
* Applying Interfaces::
* Variables in Interfaces::
* Extending Interfaces::
* Default Interface Methods::
* Interface Static Methods::
* Private Interface Methods::

Generics

* Motivation::
* What are Generics::
* Simple Generics Example::
* Notes about Generics::
* Two Type Parameters::
* Generic Class General Form::
* Bounded Types::
* Wildcard Arguments::
* Generic Methods::
* Generic Constructors::

A Simple Generics Example

* Class Gen<T>::
* Class GenDemo::

Class GenDemo

* GenDemo as Integer::
* GenDemo as String::

Notes About Generics

* Reference Types::
* Type Arguments::
* Subtyping::
* Type Safety::

A Generic Class with Two Type Parameters

* Two Types Example Code::

Example of Code with Two Type Parameters

* Class TwoGen::
* Class SimpGen::

Using Wildcard Arguments

* Wildcard Motivation::
* Wildcard Syntax::
* Bounded Wildcards::

Generalized Form

* Example of Generic Method::

Example of Generic Method

* Method isIn::
* GenMethDemo Main::

Enumerations

* Enumeration Basics::
* Enum Methods::
* Enumerations as Class Types::
* Inherit Enum::

'java.lang' includes the following interfaces

* Primitive Wrappers::

Primitive Type Wrappers

* Number::
* Double and Float::
* isInfiinite() and isNaN()::
* Byte Short Integer Long::
* Numbers to from String::

The Makefile

* Makefile Constants::
* Makefile Defaults::
* Makefile Tangle Weave::
* Makefile Clean::

Code Chunk Summaries

* File Definitions::            Source files by definition.
* Code Chunk Definitions::      Code chunks by definition.
* Code Chunk References::       Code chunks by reference.



File: JavaSE9.info,  Node: Java SE 9 Introduction,  Next: Classes,  Prev: Top,  Up: Top

1 Java SE 9 Introduction
************************


File: JavaSE9.info,  Node: Classes,  Next: Methods and Classes,  Prev: Java SE 9 Introduction,  Up: Top

2 Classes
*********

The class is the logical construct upon which the Java language is
built because it defines the shape and nature of an object, and
therefore forms the basis for object-oriented programming in Java.

* Menu:

* Class Fundamentals::
* Declaring Objects::
* Methods::
* Constructors::
* this Keyword::
* Stack Class::


File: JavaSE9.info,  Node: Class Fundamentals,  Next: Declaring Objects,  Up: Classes

2.1 Class Fundamentals
======================

A "class" defines a new data type.  Once defined, this new type can be
used to create objects of that type.  A class is therefore a template
for an object, and an "object" is an instance of a class.  Object and
instance are often used interchangeably.

* Menu:

* General Form::


File: JavaSE9.info,  Node: General Form,  Up: Class Fundamentals

2.1.1 General Form of a Class
-----------------------------

When you define a class, you declare its exact form and nature.  You
do this by specifying the data that it contains and the code that
operates on that data.  A class is declared by use of the 'class'
keyword.

     class classname {
       type instance-variable1;
       type instance-variable2;
       ...
       type instance-variableN;

       type method-name1 (parameter-list {
         body of method
       }

       type method-name2 (parameter-list {
         body of method
       }
       ...
       type method-nameN (parameter-list {
         body of method
       }
     }

GeneralForm 2.1: Class Declaration -- General Form

   The data, or variables, defined within a class are called "instance
variables".  The code is contained within "methods".  Collectively,
the methods and variables defined within a class are called "members"
of the class.  In most cases, the instance variables are acted upon
and accessed by the methods defined for that class.  As a general
rule, it is the methods that determine how a class' data can be used.

   Each instance of the class (that is, each object of the class)
contains its own copy of the instance variables.  The data for one
object is separate and unique from the data for another.  Changes to
the instance variables of one object have no effect on the instance
variables of another.

   Java classes do not need to have a 'main()' method; you only need
to specify one if that class is the starting point for the program.

   In general, you use the "dot operator" to access both the instance
variables and the methods within an object.  Although commonly
referred to as the dot _operator_, the formal specification for Java
categorizes the . as a _separator_.


File: JavaSE9.info,  Node: Declaring Objects,  Next: Methods,  Prev: Class Fundamentals,  Up: Classes

2.2 Declaring Objects
=====================

Because a class creates a new data type, you can use this type to
declare objects of that type.  Obtaining objects of a class is a
two-step process.

  1. Declare a variable of the class type; this variable does not
     define an object.  Instead, it is simply a variable that can
     _refer_ to an object.
  2. Acquire an actual, physical copy of the object and assign it to
     the variable; you can do this using the 'new' operator.  The
     'new' operator dynamically allocates (at run time) memory for an
     object, and returns a reference to to.  This reference is
     (essentially) the address in memory of the object allocated by
     'new'.  This reference is then stored in the variable.  In Java,
     all class objects must be dynamically allocated.

Example Declaration, Allocation, and Assignment
===============================================

     Box mybox; // 1. declare a variable
     mybox = new Box(); // 2. allocate a Box object

   These two declarations can be combined into a single declaration,
and usually are:

     Box mybox = new Box();

   The 'mybox' variable simply holds the memory address of the actual
'Box' object.  The class name followed by parenthese specifies the
"constructor" for the class.


File: JavaSE9.info,  Node: Methods,  Next: Constructors,  Prev: Declaring Objects,  Up: Classes

2.3 Methods
===========

General Form of a Method Declaration
====================================

     type name (parameter-list) {
       body of method
     }

GeneralForm 2.2: Method Declaration -- General Form

type specifies the type of data returned by the method.  This can be
any valid type, including class types that you create.  If the method
does not return a value, its return type must be 'void'.

   "name" is the name of the method.  This can be any legal
identifier.

   "parameter-list" is a sequence of type and identifier pairs
separated by commas.  "Parameters" are essentially variables that
receive the value of the arguments passed to the method when it is
called.  If the method has no parameters, then the parameter list will
be empty.

   Methods that have a return type other than 'void' return a value to
the calling routine using a "return statement":

     return value

   where value is the value returned.


File: JavaSE9.info,  Node: Constructors,  Next: this Keyword,  Prev: Methods,  Up: Classes

2.4 Constructors
================

Java allows objects to initialize themselves when they are created.
This automatic initialization is performed through the use of a
constructor.

   A "constructor" initializes an object immediately upon creation.
It has the same name as the class in which it resides and is
syntactically similar to a method.  Once defined, the constructor is
automatically called when the object is created, before the 'new'
operator completes.  Constructors have no return type.  It is the
constructor's job to initialize the internal state of an object so
that the code creating an instance will have fully initialized, usable
object immediately.


File: JavaSE9.info,  Node: this Keyword,  Next: Stack Class,  Prev: Constructors,  Up: Classes

2.5 The 'this' Keyword
======================

Sometimes a method will need to refer to the object that invoked it.
To allow this, Java defines the 'this' keyword.  'this' can be used
inside any method to refer to the _current_ object.  That is, 'this'
is always a refernce to the object on which the method was invoked.
You can use 'this' anywhere a reference to an object of the current
class' type is permitted.

* Menu:

* Instance Variable Hiding::


File: JavaSE9.info,  Node: Instance Variable Hiding,  Up: this Keyword

2.5.1 Instance Variable Hiding
------------------------------

It is illegal to declare two local variables with the same name inside
the same or enclosing scope.  However, you can have local variables,
including formal parameters to methods, which overlap with the names
of the class' instance variables.  For these cases, the local
variables _hide_ the instance variables of the same name.

   Because 'this' lets you refer directly to the object, you can use
it to resolve any namespace collisions that might occur between
instance variables and local variables.  So, 'this.width = width' is
an example of a local variable ('width') hiding an instance variable
(also 'width'), with 'this' allowing an assignment between them.


File: JavaSE9.info,  Node: Stack Class,  Prev: this Keyword,  Up: Classes

2.6 A Stack Class
=================

To see a practical application of object-oriented programming, here is
one of the archetypal examples of encapsulation: the stack.  A "stack"
stores data using _first-in, last-out_ ordering.  That is, a stack is
like a stack of plates on a table -- the first plate put down on the
table is the last plate to be used.  Stacks are controlled through two
operations traditionally called "push" and "pop".  To put an item on
top of the stack, you will use 'push'.  To take an item off the stack,
you will use 'pop'.  It is easy to encapsulate the entire stack
mechanism.

   Here is a class called 'Stack' that implements a stack for up to
ten integers, plus test class called 'TestStack':

Stack.java
==========

{'Stack.java'} ==
     class Stack {
       <Stack Instance Variables>
       <Stack Constructor>
       <Stack Instance Methods>
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Constructor>       See *note Stack-Constructor::.
<Stack Instance           See *note Stack-Instance-Methods::.
Methods>
<Stack Instance           See *note Stack-Instance-Variables::.
Variables>

TestStack.java
==============

{'TestStack.java'} ==
     class TestStack {
       <TestStack Main Method>
     }


The called chunk <TestStack Main Method> is first defined at *note
TestStack-Main-Method::.

* Menu:

* Stack Instance Variables::
* Stack Constructor Node::
* Stack Instance Methods Node::
* Stack TestStack Node::


File: JavaSE9.info,  Node: Stack Instance Variables,  Next: Stack Constructor Node,  Up: Stack Class

2.6.1 Stack Instance Variables
------------------------------

<Stack Instance Variables> ==
     int[] stck = new int[10];
     int tos;


This chunk is called by {'Stack.java'}; see its first definition at
*note Stack-java::.


File: JavaSE9.info,  Node: Stack Constructor Node,  Next: Stack Instance Methods Node,  Prev: Stack Instance Variables,  Up: Stack Class

2.6.2 Stack Constructor Subsection
----------------------------------

<Stack Constructor> ==
     // initialize top-of-stack tos
     Stack() {
       tos = -1;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'Stack.java'}            See *note Stack-java::.
{'StackImproved.java'}    See *note StackImproved-java::.


File: JavaSE9.info,  Node: Stack Instance Methods Node,  Next: Stack TestStack Node,  Prev: Stack Constructor Node,  Up: Stack Class

2.6.3 Stack Instance Methods Subsection
---------------------------------------

<Stack Instance Methods> ==
     <Stack Push>
     <Stack Pop>

This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'Stack.java'}            See *note Stack-java::.
{'StackImproved.java'}    See *note StackImproved-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Pop>               See *note Stack-Pop::.
<Stack Push>              See *note Stack-Push::.

* Menu:

* Stack Push and Pop Node::


File: JavaSE9.info,  Node: Stack Push and Pop Node,  Up: Stack Instance Methods Node

2.6.3.1 Stack Push and Pop Subsubsection
........................................

<Stack Push> ==
     // Push an item onto the stack
     void push(int item) {
       if (tos == 9)
         System.out.println("Stack is full.");
       else
         stck[++tos] = item;
     }


This chunk is called by <Stack Instance Methods>; see its first
definition at *note Stack-Instance-Methods::.

<Stack Pop> ==
     // Pop an item from the stack
     int pop() {
       if (tos < 0) {
         System.out.println("Stack underflow.");
         return 0;
       } else
         return stck[tos--];
       }
     }


This chunk is called by <Stack Instance Methods>; see its first
definition at *note Stack-Instance-Methods::.


File: JavaSE9.info,  Node: Stack TestStack Node,  Prev: Stack Instance Methods Node,  Up: Stack Class

2.6.4 Stack TestStack Subsection
--------------------------------

<TestStack Main Method> ==
     public static void main(String[] args) {
       Stack mystack1 = new Stack();
       Stack mystack2 = new Stack();

       // push some numbers onto the stack
       for (int i = 0; i < 10; i++)
         mystack1.push(i);
       for (int i = 10; i < 20; i++)
         mystack2.push(i);

       // pop those numbers off the stack
       System.out.println("Stack in mystack1:");
       for (int i = 0; i < 10; i++)
         System.out.println(mystack1.pop());

       System.out.println("Stack in mystack2:");
       for (int i + 0; i < 10; i++)
         System.out.println(mystack2.pop());
     }


This chunk is called by {'TestStack.java'}; see its first definition
at *note TestStack-java::.


File: JavaSE9.info,  Node: Methods and Classes,  Next: Inheritance,  Prev: Classes,  Up: Top

3 Methods and Classes
*********************

This chapter examines several topics relating to methods and classes,
including

   * overloading
   * parameter passing
   * recursion
   * access control
   * keywords 'static' and 'final'
   * 'String' class
   * Arrays
   * nested and inner classes
   * command-line arguments and varargs

* Menu:

* Overloading Methods::
* Objects as Parameters::
* Argument Passing::
* Returning Objects::
* Recursion::
* Access Control::
* static Keyword::
* final Keyword::
* Arrays 2::
* Nested and Inner Classes::
* The String Class::
* Command-Line Arguments::
* Varargs::


File: JavaSE9.info,  Node: Overloading Methods,  Next: Objects as Parameters,  Up: Methods and Classes

3.1 Overloading Methods
=======================

It is possible to define two or more methods within the same class
that share the same name as long as their parameter declarations are
different.  When this is the case, the methods are said to be
"overloaded", and the process is referred to as "method overloading".
Method overloading is one of the ways that Java supports polymorphism.

   When an overloaded method is invoked, Java uses the type and number
of arguments as its guid to determine which version of the overloaded
method to actually call.  Thus, overloaded methods must differ in the
type or number of their parameters.  While overloaded methods may have
different return types, thei return type alone is inusfficient to
distinguish two versions of a method.  When Java encounters a call to
an overloaded method, it simply executes the version of the method
whose parameters match the arguments used in the call.

   The match between arguments and parameters need not always be
exact.  In some cases,Java's automatic type conversions can play a
role in overload resolution.  For example, if there is a method with
one 'double' parameter, and that method is invoked with a single 'int'
argument, then, when no exact match is found, Java will automatically
convert the integer into a 'double', and this conversion will be used
to resolve the call.  Java will employ automatic type conversion only
if no exact match is found.

   Method overloading supports polymorphism because it is one way that
Java implements the _one interface, multiple methods_ paradigm.  That
is, Java does not need to rename each similar method just because it
has a slightly different parameter requirements.  The value of
overloading is that it allows related methods to be accessed by use of
a common name, representing the _general action_ that is being
performed, and leaves to the compiler the choice of the right
_specific_ version for a particular circumstance.  The programmer need
only remember the general operation being performed.  Through the
application of polymorphism, several names have been reduced to one.
Overloading can help manage greater complexity.

* Menu:

* Overloading Constructors::


File: JavaSE9.info,  Node: Overloading Constructors,  Up: Overloading Methods

3.1.1 Overloading Constructors
------------------------------

You can also overload constructor methods.


File: JavaSE9.info,  Node: Objects as Parameters,  Next: Argument Passing,  Prev: Overloading Methods,  Up: Methods and Classes

3.2 Objects as Parameters
=========================

It is both correct and common to pass objects to methods as well as
primitive types.  One of the most common uses of object parameters
involves constructors.  Frequently you will want to construct a new
object so that it is initially the same as some existing object.  To
do this, you must define a constructor that takes an object of its
class as a parameter.  Providng many forms of constructors is usually
required to allow objects to be constructed in a convenient and
efficient manner.


File: JavaSE9.info,  Node: Argument Passing,  Next: Returning Objects,  Prev: Objects as Parameters,  Up: Methods and Classes

3.3 Argument Passing
====================

In general, there are two ways that a computer language can pass an
argument to a subroutine:

  1. call-by-value
  2. call-by-reference

   Java uses call-by-value to pass all arguments, although the precise
effect differs between whether a primitive type or a reference type is
passed.

   When you pass a primitive type to a method, it is passed by value.
Thus, a copy of the argument is made, and what occurs to the parameter
that receives the argument has no effect outside the method.

   When you pass an object to a method, the situation changes; objects
are passed by what is effectively call-by-reference.  When you pass a
variable of a class type, you pass a reference to the method and the
parameter receiving it will refer to the same object.  This
effectively means that objects act as if they are passed to methods by
use of call-by-reference.  Changes to the object inside the method
_do_ affect the object used as an argument.  However, when an object
reference is passed to a method, the reference itself is passed by use
of call-by-value; therefore, that reference will continue to refer to
the object, even though the object itself may be modified.


File: JavaSE9.info,  Node: Returning Objects,  Next: Recursion,  Prev: Argument Passing,  Up: Methods and Classes

3.4 Returning Objects
=====================

A method can return any type of data, including class types that you
create.

   Since all objects are dynamically allocated using 'new', you don't
need to worry about an object going out-of-scope because the method in
which it was created terminates.  The object will continue to exist as
long as there is a reference to it somewhere in your program.  When
there are no references to it, the object will be reclaimed the next
time garbage collection takes place.


File: JavaSE9.info,  Node: Recursion,  Next: Access Control,  Prev: Returning Objects,  Up: Methods and Classes

3.5 Recursion
=============

"Recursion" is the process of defining something in terms of itself.
In programming, it is also what allows a method to call itself.  A
method that calls itself is said to be "recursive".

   When a method calls itself, new local variables and parameters are
allocated storage on the stack, and the method code is executed with
these new variables from the start.  As each recursive call returns,
the old local variables and parameters are removed from the stack, and
execution resumes at the point of the call inside the method.

   Recursive versions of many routines may execute a bit slower than
the iterative equivalent because of the added overhead of the
additional method calls.  A large number of recursive calls to a
method could cause a stack overrun.  Because storage for parameters
and local varibles is on the stack and each new call creates a new
copy of these variables, it is possible that the stack could be
exhausted.  If this occurs, the Java run-time system will cause an
exception.

   The main advantage to recursive methods is that they can be used to
create clearer and simpler versions of several algorithms than can
their iterative relatives.  For example, the QuickSort sorting
algorithm is quite difficult to implement in an iterative way.  Also,
some types of AI-related algorithms are most easily implemented using
recursive solutions.


File: JavaSE9.info,  Node: Access Control,  Next: static Keyword,  Prev: Recursion,  Up: Methods and Classes

3.6 Access Control
==================

Encapsulation provides another important attribute besides linking
data with code: "access control".  Through encapsulation, you can
control what parts of a program can access the members of a class.  By
controlling access, you can prevent misuse.  Thus, when correctly
implemented, a class creates a _black box_ which may be used, but the
inner workings of which are not open to tampering.  The classes
introduced earlier do not completely meet this goal.  For example, the
'Stack' class provides the methods 'push()' and 'pop()' as a
controlled interface to the stack, this interface is not enforced --
it is possible for another part of the program to bypass these methods
and access the stack directly.  This could lead to trouble.

   How a member can be accessed is determined by the "access modifier"
attached to its declaration.  Java supplies a rich set of access
modifiers.  Some aspects of access control are related mostly to
inheritance or packages (and now modules).  Those ideas will be
discussed later.  Here, let's examine access control as it relates to
a single class.

Access Modifiers
----------------

Java's access modifiers are:

   * public
   * private
   * protected (applies only to inheritance)
   * default access level

'public' vs 'private' Access
............................

When a member of a class is modified by 'public', then that member can
be accessed by any other code.  When a member of a class is specified
as 'private', then that member can only be accessed by other members
of its class.  Thus, the method 'main()' is always preceded by the
'public' modifier.  It must be called by code that is outside the
program -- the Java run-time system.

Default Access -- No Access Modifier
------------------------------------

When no access modifier is used, then by default the member of a class
is public within its own package, but cannot be accessed outside of
its package.  In the classes developed so far, all members of a class
have used the 'default' access mode.  However, this is typically not
what you will want to be the case.  Usually, you will want to restrict
access to the data members of a class -- allowing access only through
methods.  There will also be times when you will want to define
methods that are private to a class.

Access Modifier Syntax
----------------------

An access modifier precedes the rest of a member's type specification.
That is, it must begin a member's declaration statement.  As an
example:

     public int i;
     private double j;

     private int myMethod(int a, char b) {
       ...
     }

Access Control and Inheritance
------------------------------

Consult the chapter on *note Inheritance:: for more on the topic of
access control in relation to inheritance.

* Menu:

* Improved Stack Class::


File: JavaSE9.info,  Node: Improved Stack Class,  Up: Access Control

3.6.1 An Improved 'Stack' Class
-------------------------------

StackImproved.java
------------------

Compare this code with that of *note Stack Class::.  (1)

{'StackImproved.java'} ==
     class StackImproved {
       <Stack Private Instance Variables>
       <Stack Constructor>
       <Stack Instance Methods>
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Constructor>       See *note Stack-Constructor::.
<Stack Instance           See *note Stack-Instance-Methods::.
Methods>
<Stack Private Instance   See
Variables>                *note Stack-Private-Instance-Variables::.

Stack Private Instance Variables
--------------------------------

<Stack Private Instance Variables> ==
     /* Now, both stck and tos are private.  This means
        that they cannot be accidentally or maliciously
        altered in a way that would be harmful to the stack.
      */

     private int[] stck = new int[10];
     private int tos;


This chunk is called by {'StackImproved.java'}; see its first
definition at *note StackImproved-java::.

   Now both 'stck', which holds the stack, and 'tos', which is the
index of the top of the stack, are specified as 'private'.  This means
that they cannot be accessed or altered except through 'push()' and
'pop()'.  Making 'tos' private, for example, prevents other parts of
your program from inadvertently setting it to a value that is beyond
the end of the 'stck' array.  In other words, the following code,
added to the end of the 'TestStack.java' program (*note
TestStack-Main-Method::), would be illegal and the program would not
compile:

     mystack1.tos = -2;
     mystack2.stck[3] = 100;

   ---------- Footnotes ----------

   (1) Notice how all of the prior code except what is changed can
easily be reused using TexiWebJr's modular system.


File: JavaSE9.info,  Node: static Keyword,  Next: final Keyword,  Prev: Access Control,  Up: Methods and Classes

3.7 'static' Keyword
====================

There will be times when you want to define a class member that will
be used independently of any object of that class.  Normally, a class
member must be accessed in conjunction with an object of its class.
However, it is possible to create a member that can be used by itself
without reference to a specific instance.  To create such a member,
precede its declaration with the keyword 'static'.  When a member is
declared 'static', it can be accessed before any objects of its class
are created, and without reference to any object.

   You can declare both methods and variables to be 'static'.
Instance variables declared as 'static' are essentially global
variables.  When objects of its class are declared, no copy of a
'static' variable is made.  Instead, all instances of the class share
the same 'static' variable.

Restrictions on 'static' Methods
--------------------------------

Methods declared as 'static' have several restrictions:

   * they can only directly call other 'static' methods of their
     class;
   * they can only directly access 'static' variables of their class;
   * they cannot refer to 'this' or 'super' in any way;

'static' Block
--------------

If you need to do computation in order to initialize your 'static'
variables, you can declare a 'static' block that gets executed exactly
once, when the class is first loaded ("static initialization block").

     class UseStatic {
       static int a = 3;
       static int b;

       static {
         b = a * 4;
       }
     }

   As soon as the 'UseStatic' class is loaded, all of the 'static'
statements are run.  First, 'a' is set to '3', then the 'static' block
executes and initializes 'b' to 'a * 4' or '12'.  Then 'main()' is
called (not shown).

Use of 'static' Members Outside Their Class
-------------------------------------------

Outside of the class in which they are defined, 'static' methods and
variables can be used independently of any object.  To do so, you need
only specify the name of their class followed by the dot operator:
classname.method().  classname is the name of the class in which the
'static' method is declared.  A 'static' variable can be accessed in
the same way.  This is how Java implements a controlled version of
global methods and global variables.


File: JavaSE9.info,  Node: final Keyword,  Next: Arrays 2,  Prev: static Keyword,  Up: Methods and Classes

3.8 'final' Keyword
===================

A field can be declared as 'final'.  Doing so prevents its contents
from being modified, making it, esentially, a constant.  This means
that you must initialize a 'final' field when it is declared.  You can
do this in one of two ways: when it is declared, or within a
constructor.

   In addition to fields, both method parameters and local variables
can be declared as 'final'.  Declaring a parameter as 'final' prevents
it from being changed within the method.  Declaring a local variable
'final' prevents it from being assigned a value more than once.

   The keyword 'final' can also be applied to methods, but its meaning
is different than when applied to variables.  This usage of 'final' is
described in the next chapter (*note Inheritance::).


File: JavaSE9.info,  Node: Arrays 2,  Next: Nested and Inner Classes,  Prev: final Keyword,  Up: Methods and Classes

3.9 Arrays Revisited
====================

Arrays are implemented as objects.  Because of this, there is a
special array attribute that you will want to take advantage of.
Specifically, the size of an array--that is, the number of elements
that an array can hold--is found in its 'length' instance variable.
All arrays have this variable, and it will always hold the size of the
array.  Keep in mind that the value of 'length' has nothing to do with
the number of elements that are actually in use.  It only reflects the
number of elements taht the array is designed to hold.


File: JavaSE9.info,  Node: Nested and Inner Classes,  Next: The String Class,  Prev: Arrays 2,  Up: Methods and Classes

3.10 Nested and Inner Classes
=============================


File: JavaSE9.info,  Node: The String Class,  Next: Command-Line Arguments,  Prev: Nested and Inner Classes,  Up: Methods and Classes

3.11 The 'String' Class
=======================


File: JavaSE9.info,  Node: Command-Line Arguments,  Next: Varargs,  Prev: The String Class,  Up: Methods and Classes

3.12 Using Command-Line Arguments
=================================


File: JavaSE9.info,  Node: Varargs,  Prev: Command-Line Arguments,  Up: Methods and Classes

3.13 Varargs: Variable-Length Arguments
=======================================


File: JavaSE9.info,  Node: Inheritance,  Next: Packages,  Prev: Methods and Classes,  Up: Top

4 Inheritance
*************

Inheritance is a cornerstone of object-oriented programming because it
allows the creation of hierarchical classifications.  Using
inheritance, you can create a general class taht defines traits common
to a set of related items.  This class can then be inherited by other,
more specific classes, each adding those things that are unique to
them.

   A class that is inherited is called a "superclass".  The class that
does the inheriting is called a "subclass".  A subclass is a
specialized version of a subclass.  It inherits all of the members
defined by the superclass and adds its own, unique elements.


File: JavaSE9.info,  Node: Packages,  Next: Interfaces,  Prev: Inheritance,  Up: Top

5 Packages
**********

Packages are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file
names.  Packages are stored in a hierarchical manner and are
explicitly imported into new class definitions.

* Menu:

* Packages Intro::
* Defining Packages::
* Classpath::
* Member Access::
* Importing::


File: JavaSE9.info,  Node: Packages Intro,  Next: Defining Packages,  Up: Packages

5.1 Introduction to Packages
============================

Java provides a mechanism for partitioning the class namespace into
manageble chunks: the "PACKAGE". The package is both a naming and a
visibility control mechanism.  In other words, you can use the package
mechanism to define classes inside a package that are not accessible
by code outside the package; and you can define class members that are
exposed only to other members of the same package.


File: JavaSE9.info,  Node: Defining Packages,  Next: Classpath,  Prev: Packages Intro,  Up: Packages

5.2 Defining Packages
=====================

To create a package ("define" a package), include the 'package'
command as the first statement in a Java source file.  Thereafter, any
classes declared within that file will belong to the specified
package.  The 'package' statement defines a namespace in which classes
are stored.  Without the 'package' statement, classes are put into the
'default' package (which has no name).

General Form of 'package' statement
-----------------------------------

     package pkg

GeneralForm 5.1: Package Statement -- General Form

pkg is the name of the package.  For example:

     package mypackage;

File System Directories
-----------------------

Java uses the file system directories to store packages.  Therefore,
the '.class' files for any classes you declare to be part of
'mypackage' must be stored in a directory called 'mypackage'.  The
directory name must match the package name exactly.

   More than one file can include the same 'package' statement.  The
'package' statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other
files from being part of that same package.  Most real-world packages
are spread across many files.

Hierarchy of Packages
---------------------

You can create a hierarch of packages.  To do so, separate each
package name form the one above it by use of a period.  The general
form of a multileveled package statement is:

     package pkg1[.pkg2[.pkg3]]

GeneralForm 5.2: Package Statement -- Multilevel Form

   A package hierarchy must be reflected in the file system of your
Java development system.  For example a package declared as:

     package a.b.c;

   needs to be stored in directory 'a/b/c'.

   Be sure to choose package names carefully; you cannot rename a
package without renaming the directory in which the classes are
stored.


File: JavaSE9.info,  Node: Classpath,  Next: Member Access,  Prev: Defining Packages,  Up: Packages

5.3 Finding Packages and CLASSPATH
==================================

Packages are mirrored by directories.  How does the Java run-time
system know where to look for packages?

'cwd'
     By default, the Java run-time system uses the currect working
     directory as its starting point.  Thus, if your package is in a
     subdirectory of the current directory, it will be found.
'CLASSPATH'
     You can specify a directory path or paths by setting the
     'CLASSPATH' environment variable.
'-classpath'
     You can use the '-classpath' option with 'java' and 'javac' to
     specify the path to your classes.
module path
     Beginning with JDK 9, a package can be part of a module, and thus
     found on the 'module path'.

Example Finding a Package
-------------------------

Consider the following package specification:

     package mypack;

   In order for programs to find 'mypack', the program can be executed
from a directory *immediadely above* 'mypack', or the 'CLASSPATH' must
be set to include the path to 'mypack' or the '-classpath' option must
specify the path to 'mypack' when the program is run via 'java'.

   When the second or third of the above options is used, the 'class
path' *must not include* 'mypack' itself.  It must simply specify the
'path' to just above 'mypack'.  For example, if the path to 'mypack'
is

     /MyPrograms/Java/mypack

   then the class path to 'mypack' is

     /MyPrograms/Java


File: JavaSE9.info,  Node: Member Access,  Next: Importing,  Prev: Classpath,  Up: Packages

5.4 Packages and Member Access
==============================

Packages add another dimension to access control.  Classes and
packages are both means of encapsulating and containing the name space
and scope of variables and methods.  _Packages_ act as containiners
for classes and other subordinate packages.  _Classes_ act as
containers for data and code.  The class is Java's smallest unit of
abstraction.  As it relates to the interplay between classes and
packages, Java addresses four categories of visibility for class
members:

   * Subclasses in the same package
   * Non-subclasses in the same package
   * Subclasses in different packages
   * Classes that are neither in the same package nor subclasses

   The three access modifiers

   * private
   * public
   * protected

   provide a variaty of ways to produce many levels of access required
by these categories.

Category                     Private     None        Protected   public
-----------------------------------------------------------------------------
Same Class                   Yes         Yes         Yes         Yes
Same package subclass        No          Yes         Yes         Yes
Same package non-subclass    No          Yes         Yes         Yes
Different package subclass   No          No          Yes         Yes
Different package            No          No          No          Yes
noni-subclass

Table 5.1: Package Access Table -- Shows all combinations of the
access control modifiers


File: JavaSE9.info,  Node: Importing,  Prev: Member Access,  Up: Packages

5.5 Importing Packages
======================

Java includes the 'import' statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be
referred to directly, using only its name.  The 'import' statement is
a convenience to the programmer and is not technically needed to write
a complete Java program.

   In a Java source file, 'import' statements occur immediately
following the 'package' statement (if one exists) and before any class
definitions.  This is the general form of the 'import' statement:

     import pkg1[.pkg2].(classname | *);

GeneralForm 5.3: Import Statement -- General Form

   Here, pkg1 is the name of a top-level package, and pkg2 is the name
of a subordinate package inside the outerpackage separated by a dot
(.).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit 'classname' or a star (*), which
indicates that the Java compiler should import the entire package.

     import java.util.Date;
     imort java.io.*;

   All of the standard Java SE classes included with Java begin with
the name 'java'.  The basic language functions are stored in a package
called 'java.lang'.  Normally, you have to import every package or
class that you want to use, but since Java is useless without much of
the functionality in 'java.lang', it is implicitly imported by the
compiler for all programs.  This is equivalent to the following line
being at the top of all your programs:

     import java.lang.*;

   The 'import' statement is _optional_.  Any place you use a class
name, you can use its _fully qualified name_, which includes its full
package hierarchy.

   When a package is imported, only those items within the package
declared as 'public' will be available to non-subclasses in the
importing code.


File: JavaSE9.info,  Node: Interfaces,  Next: Generics,  Prev: Packages,  Up: Top

6 Interfaces
************

Using the keyword 'interface', you can fully abstract a class'
interface from its implementation.  That is, using 'interface', you
can specify what a class must do, but not how to do it.  Interfaces
are syntactically similar to classes, but they lack instance
variables, and, as a general rule, their methods are declared without
any body.  Once it is defined, any number of classes can implement an
'interface'.  Also, one class can implement any number of interfaces.
To implement an interfce, a class must provide the complete set of
methods required by the interface.  Each class is free to determine
the details of its own implementation.  By providing the 'interface'
keyword, Java allws you to fully utilize the "one interface, multiple
methods" aspect of polymorphism.

   Interfaces are designed to support "dynamic method resolution" at
run time.  Normally, in order for a method to be called from one class
to another, both classes need to be present at compile time so the
Java compiler can check to ensure that the method signatures are
compatible.  This requirement by itself makes for a static and
nonextensible classing environment.  Inevitably in a system like this,
functionality gets pushed up higher and higher in the class hierarchy
so that the mechanisms will be available to more and more subclasses.
Interfaces are designed to avoid this problem.  _They disconnect the
definition of a method or set of methods from the inheritance
hierarchy._  Since interfaces are in a different hierarchy from
classes, it is possible for classes that are unrelated in terms of
class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.

* Menu:

* Defining Interfaces::
* Implementing Interfaces::
* Interface References::
* Partial Implementations::
* Nested Interfaces::
* Applying Interfaces::
* Variables in Interfaces::
* Extending Interfaces::
* Default Interface Methods::
* Interface Static Methods::
* Private Interface Methods::


File: JavaSE9.info,  Node: Defining Interfaces,  Next: Implementing Interfaces,  Up: Interfaces

6.1 Defining Interfaces
=======================

An interface is defined much like a class.  Here is a simplified
general form of an interface definition:

     access interface name {
       return-type method-name1(parameter-list);
       return-type method-name2(parameter-list);

       type final-varname1 = value
       type final-varname2 = value
       ...
       return-type method-nameN(parameter-list);
       type final-varnameN = value
     }

GeneralForm 6.1: Interface Definition -- Simplified General Form

   When no access modifier is included, then default access results,
and the interface is only available to other members of the package in
which it is declared.  When it is declared as 'public', the interface
can be used by code outside its package.  In this case, the interface
mst be the only public interface declared in the file, and the file
must have the same name as the interface.  The methods that are
declared have no bodies.  They end with a semicolon after the
parameter list.  They are, essentially, abstract methods.  Each class
that includes such an interface must implement all of the methods.

Variable Declarations inside Interfaces
---------------------------------------

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly 'final' and 'static', meaning they
cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly 'public'.


File: JavaSE9.info,  Node: Implementing Interfaces,  Next: Interface References,  Prev: Defining Interfaces,  Up: Interfaces

6.2 Implementing Interfaces
===========================

Once an interface has been defined, one or more classes can implement
that interface.  To implement an interface, include the 'implements'
clause in a class definition, and then create the methods required by
the interface.  The general form of a class that includes the
'implements' clause looks like this:

     class clasname [extends superclass] [implements interface [,interface...] {
       class-body
     }

GeneralForm 6.2: Class Implementing Interface -- General Form

   The methods that implement an interface must be declared 'public'.
The type signature of the implementing method must match exactly the
type signature specified in the 'interface' definition.

   It is both permissible and common for classes that implement
interfaces to define additional members of their own.


File: JavaSE9.info,  Node: Interface References,  Next: Partial Implementations,  Prev: Implementing Interfaces,  Up: Interfaces

6.3 Accessing Implementations Through Interface References
==========================================================

You can declare variables as object references that use an interface
rather than a class type.  Any instance of any class that implements
the declared interface can be referred to by such a variable.  When
you call a method through one of these references, the correct version
will be called based on the actual instance of the interface being
referred to.  This is one of the key features of interfaces.  The
method to be executed is looked up dynamically at run-time, allowing
classes to be created later than the code which calls methods on them.
The calling code can dispatch through an interface without having to
know anything about the "callee."  This process is similar to using a
superclass reference to access a subclass object.


File: JavaSE9.info,  Node: Partial Implementations,  Next: Nested Interfaces,  Prev: Interface References,  Up: Interfaces

6.4 Partial Implementations
===========================

If a class includes an interface but does not implement the methds
required by that interface, then that class must be declared as
'abstract'.  Any class that inherits the abstract class must implement
the interface or be declared 'abstract' itself.


File: JavaSE9.info,  Node: Nested Interfaces,  Next: Applying Interfaces,  Prev: Partial Implementations,  Up: Interfaces

6.5 Nested Interfaces
=====================

An interface can be declared a member of a class or another interface.
Such an interface is called a "member interface" or a "nested
interface".  A nested interface can be declared as 'public',
'private', or 'protected'.  This differs from a top-level interface,
which must either be declared as 'public' or use the default access
level.  When a nexted interface is used outside of its enclosing
scope, it must be qualified by the name of the class or interface of
which it is a member.  Thus, outside of the class or interface in
which a nested interface is declared, its name must be fully
qualified.


File: JavaSE9.info,  Node: Applying Interfaces,  Next: Variables in Interfaces,  Prev: Nested Interfaces,  Up: Interfaces

6.6 Applying Interfaces
=======================

See detailed example ...


File: JavaSE9.info,  Node: Variables in Interfaces,  Next: Extending Interfaces,  Prev: Applying Interfaces,  Up: Interfaces

6.7 Variables in Interfaces
===========================

You can use interfaces to import shared constants into multiple
classes by simply declaring an interface that contains variables that
are initialized to the desired values.  When you include that
interface in a class (when you "implement" the interface), all of
those variable names will be in scope as constants.  If an interface
contains no methods, then any class that includes such an interface
doesn't actually implement anything.  It is as if that class were
importing this constant fields into the class name space as 'final'
variables.


File: JavaSE9.info,  Node: Extending Interfaces,  Next: Default Interface Methods,  Prev: Variables in Interfaces,  Up: Interfaces

6.8 Interfaces Can Be Extended
==============================

One interface can inherit another by use of the keyword 'extends'.
The syntax is the same as for inheriting classes.  When a class
implements an interface that inherits another interface, it must
provide implementations for all methods required by the interface
inheritance chain.


File: JavaSE9.info,  Node: Default Interface Methods,  Next: Interface Static Methods,  Prev: Extending Interfaces,  Up: Interfaces

6.9 Default Interface Methods
=============================

Prior to JDK 8, an interface could not define any implementation
whatsoever.  This meant that for all previous versions of Java, the
methods specified by an interface were abstract, constaining no body.
This is the traditional form of an interface.  The release of JDK 8
changed this by adding a new capability to 'interface' called the
"default method".  A default method lets you define a default
implementation for an interface method.  It is possible for an
interface method to provide a body, rather than being abstract.

   A primary motivation for the default method was to provide a means
by which interfaces could be expanded without breaking existing code.
There must be implementations for all methods defined by an interface.
If a new method were added to a popular, widely used interface, then
the addition of that method would break existing code because no
implementation would be found for that new method.  The default method
solves this problem by supplying an implementation that willbe used if
no other implementation is explicitly provided.  Thus, the addition of
a default method will not cause preexisting code to break.

   Another motivation for the default method was the desire to specify
methods in an interface that are, essentially, optional, depending on
how the interface is used.

Interfaces Do No Maintain State and Cannot Be Created
-----------------------------------------------------

It is important to point out that the addition of default methods does
not change a key aspect of 'interface': its inability to maintain
state information.  An interface still cannot have instance variables,
for example.  Thus, *the defining difference between an interface and
a class is that a class can maintain state information, but an
interface cannot.*  Furthermore, it is still not possible to create an
instance of an interface by itself.  It must be implemented by a
class.


File: JavaSE9.info,  Node: Interface Static Methods,  Next: Private Interface Methods,  Prev: Default Interface Methods,  Up: Interfaces

6.10 Use Static Methods in an Interface
=======================================

Another capability added to interface by JDK 8 is the ability to
define one or more 'static' methods.  Like 'static' methods in a
class, a 'static' method defined by an interface can be called
independently of any object.  Thus, no implementation of the interface
is necessary, and no instance of the interface is required, in order
to call a 'static' method.  Instead, a 'static' method is called by
specifying the interface name, followed by a period, followed by the
method name.  Here is the general form:

     InterfaceName.staticMethodName

GeneralForm 6.3: Interface Static Method, Calling

   Notice that this is similar to the way that a 'static' method in a
class is called.  However, 'static' interface methods are not
inherited by either an implementing class or a subinterface.


File: JavaSE9.info,  Node: Private Interface Methods,  Prev: Interface Static Methods,  Up: Interfaces

6.11 Private Interface Methods
==============================

Beginning with JDK 9, an interface can include a private method.  A
private interface method can be called only by a default method or
another private method defined by the same interface.  Because a
private interface method is specified 'private', it cannot be used by
code outside the interface in which it is defined.  This restriction
includes subinterfaces because a private inteface method is not
inherited by a subinterface.

   The key benefit of a private interface method is that it lets two
or more default methods use a common piece of code, thus avoiding code
duplication.


File: JavaSE9.info,  Node: Generics,  Next: Enumerations,  Prev: Interfaces,  Up: Top

7 Generics
**********

"Generics", introduced in J2SE 5.0, allows a type or method to operate
on objects of various types while providing compile-time type safety.
It adds compile-time type safety to the Collections Framework and
eliminates the need of casting.  In other words, generics allow you to
abstract over types.

   Through the use of generics, it is possible to create classes,
interfaces, and methods that will work in a type-safe manner with
various kinds of data.  Many algorithms are logically the same no
matter what type of data they are being applied to.  For example, the
mechanism that supports a stack is the same whether that stack is
storing items of type 'Integer', 'String', 'Object', or 'Thread'.
With generics, you can define an algorithm once, independently of any
specific type of data, and then apply that algorithm to a wide variety
of data types without any additional effort.

   Perhaps the one feature of Java that has been most significantly
affected by generics is the 'Collections Framework'.  A "collection"
is a group of objects.  The Collections Framework defines several
classes, such as lists and maps, that manage collections.  The
collection classes have always been able to work with any type of
object.  The benefit that generics adds is that the collection classes
can now be used with complete type safety.

   This chapter describes the syntax, theory, and use of generics.  It
also shows how generics provide type safety for some previously
difficult cases.

* Menu:

* Motivation::
* What are Generics::
* Simple Generics Example::
* Notes about Generics::
* Two Type Parameters::
* Generic Class General Form::
* Bounded Types::
* Wildcard Arguments::
* Generic Methods::
* Generic Constructors::


File: JavaSE9.info,  Node: Motivation,  Next: What are Generics,  Up: Generics

7.1 Motivation for Generics
===========================

Code Fragment Without Generics
------------------------------

Here is a typical code fragment abstracting over types by using
'Object' and type casting.

     List myIntList = new LinkedList(); // 1
     myIntList.add(new Integer(0)); // 2
     Integer x = (Integer) myIntList.iterator().next(); // 3

   The cast on line 3 is annoying, although essential.  The compiler
can guarantee only that an 'Object' will be returned by the iterator.
This therefore adds both clutter and the possibility of a run-time
error.

Code Fragment with Generics
---------------------------

Generics allow a programmer to mark their intent to restrict a list to
a particular data type.  Here is a version of the same code that uses
generics.

     List<Integer> myIntList = new LinkedList<Integer>(); // 1'
     myIntList.add(new Integer(0)); // 2'
     Integer x = myIntList.iterator().next(); // 3'

   In line 1, the type declaration for the variable 'myIntList'
specifies that it is to hold a 'List' of 'Integer's: 'List<Integer>'.
'List' is a "generic interface" that takes a "type parameter"
('Integer').  The type parameter is also specified when creating the
'List' object ('new LinkedList<Integer>()').  Also, the cast on line 3
is gone.

   So has this just moved the clutter around, from a type cast to a
type parameter?  No, because this has given the compiler the ability
to check the type correctness of the program _at compile-time_.  When
we say that 'myIntList' is declared with type 'List<Integer>', this
tells us something about the variable 'myIntList', which holds true
wherever and whenever it is used, and the compiler will guarantee it.
In contrast, the cast tells us something the programmer thinks is true
at a single point in the code.

   The net effect, especially in large programs, is improved
readability and robustness.


File: JavaSE9.info,  Node: What are Generics,  Next: Simple Generics Example,  Prev: Motivation,  Up: Generics

7.2 What Are Generics
=====================

The term "generics" means parameterized types.  Parameterized types
are important because they enable you to create classes, interfaces,
and methods in whicht the type of data upon which they operate is
specified as a parameter.  Using generics, it is possible to create a
single class, for example, that automatically works with different
types of data.  A class, interface, or method that operates on a
parameterized type is called "generic", as in generic class or generic
method.

   Java has always given the ability to create generalized classes,
interfaces, and methods by operating through references of type
'Object'.  Generics added the type safety that was lacking.  They also
streamlined the process, because it is no longer necessary to
explicitly employ casts to translate between 'Object' and the type of
data that is being operate upon.  Wtih generics, all casts are
automatic and implicit.


File: JavaSE9.info,  Node: Simple Generics Example,  Next: Notes about Generics,  Prev: What are Generics,  Up: Generics

7.3 A Simple Generics Example
=============================

The following program defines two classes.  The first is the generic
class 'Gen', and the second is 'GenDemo', which uses 'Gen'.

{'SimpleGenerics.java'} ==
     <Class Gen>
     <Class GenDemo>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class Gen>               See *note Class-Gen::.
<Class GenDemo>           See *note Class-GenDemo::.

* Menu:

* Class Gen<T>::
* Class GenDemo::


File: JavaSE9.info,  Node: Class Gen<T>,  Next: Class GenDemo,  Up: Simple Generics Example

7.3.1 Class Gen<T>
------------------

This is a simple generic class.  The class 'Gen' is declared with a
parameter of '<T>':

     class Gen<T> {

   'T' is the name of a "type parameter".  This name is used as a
placeholder for the actual type that will be passed to 'Gen' when an
object is created.  Thus, 'T' is used within 'Gen' whenever the type
parameter is needed.

   Notice that 'T' is contained within '< >'.  This syntax can be
generalized.  Whenever a type parameter is being declared, it is
specified within angle brackets.

   Because 'Gen' uses a type parameter, 'Gen' is a _generic class_,
which is also called a _parameterized type_.

Outline of Class Gen<T>
.......................

Class 'Gen' contains four parts:

   * an instance variable declaration
   * a constructor
   * a method returning the instance variable
   * a method describing the type of the instance variable

<Class Gen> ==
     class Gen<T> {
       <Instance Variable ob of Type T>
       <Constructor taking parameter of Type T>
       <Method returning object of type T>
       <Method showing type of T>
     }

This chunk is called by {'SimpleGenerics.java'}; see its first
definition at *note SimpleGenerics-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Constructor taking       See
parameter of Type T>      *note Constructor-taking-parameter-of-Type-T::.
<Instance Variable ob     See *note Instance-Variable-ob-of-Type-T::.
of Type T>
<Method returning         See
object of type T>         *note Method-returning-object-of-type-T::.
<Method showing type of   See *note Method-showing-type-of-T::.
T>

Implementation of Class Gen<T>
..............................

'T' is used to declare an object called 'ob'.  'T' is a placeholder
for the actual type that will be specified when a 'Gen' object is
created.  Thus, 'ob' will be an object of the type passed to 'T'.

<Instance Variable ob of Type T> ==
     T ob;   // declare an object of type T


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

The Constructor
...............

Here is the constructor for 'Gen'.  Notice that its parameter, 'o', is
of type 'T'.  This means that the actual type of 'o' is determined by
the type passed to 'T' when a 'Gen' object is created.  Because both
the parameter 'o' and the member variable 'ob' are of type 'T', they
will both be the same actual type when a 'Gen' object is created.

<Constructor taking parameter of Type T> ==
     // Pass the constructor a reference to
     // an object of type T
     Gen (T o) {
       ob = o;
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

Instance Methods 'getob()' and 'showType()'
...........................................

The type parameter 'T' can also be used to specify the return type of
a method, as here in 'getob()'.  Because 'ob' is also of type 'T', its
type is compatible wih the return type specified by 'getob()'.

<Method returning object of type T> ==
     // Return ob
     T getob() {
       return ob;
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

   The method 'showType()' displays the type of 'T' by calling
'getName()' on the 'Class' object return by the call to 'getClass()'
on 'ob'.  The 'getClass()' method is defined by 'Object' and is thus a
member of _all_ class types.  It returns a 'Class' object that
corresponds to the type of the class of the object on which it is
called.  'Class' defines the 'getName()' method, which returns a
string representation of the class name.

<Method showing type of T> ==
     // Show type of T
     void showType() {
       System.out.println("Type of T is " + ob.getClass().getName();
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.


File: JavaSE9.info,  Node: Class GenDemo,  Prev: Class Gen<T>,  Up: Simple Generics Example

7.3.2 Class GenDemo
-------------------

The 'GenDemo' class demonstrates the generic 'Gen' class.

   But first, take note: The Java compiler does not actually create
different versions of 'Gen', or of any other generic class.  The
compiler removes all generic type information, substituting the
necessary casts, to make your code *behave as if* a specific version
of 'Gen' were created.  There is really only one version of 'Gen' that
actually exists.

   The process of removing generic type information is called "type
erasure".

   'GenDemo' first creates a version of 'Gen' for integers and calls
the methods defined in 'Gen' on it.  It then does the same for a
String object.

<Class GenDemo> ==
     // Demonstrate the generic class
     class GenDemo {
       public static void main(String args[]) {
         <Create a Gen object for Integers>
         <Create a Gen object for Strings>
       }
     }


This chunk is called by {'SimpleGenerics.java'}; see its first
definition at *note SimpleGenerics-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Create a Gen object      See
for Integers>             *note Create-a-Gen-object-for-Integers::.
<Create a Gen object      See *note Create-a-Gen-object-for-Strings::.
for Strings>

* Menu:

* GenDemo as Integer::
* GenDemo as String::


File: JavaSE9.info,  Node: GenDemo as Integer,  Next: GenDemo as String,  Up: Class GenDemo

7.3.2.1 Implementation of Class GenDemo with Type Integer
.........................................................

<Create a Gen object for Integers> ==
     <Integer Type Parameter>
     <Reference to Integer Instance>
     <Show Type>
     <Get Value>

This chunk is called by <Class GenDemo>; see its first definition at
*note Class-GenDemo::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Get Value>               See *note Get-Value::.
<Integer Type             See *note Integer-Type-Parameter::.
Parameter>
<Reference to Integer     See *note Reference-to-Integer-Instance::.
Instance>
<Show Type>               See *note Show-Type::.

Integer Type Declaration
........................

A reference to an Integer is declared in 'iOb'.  Here, the type
'Integer' is specified within the angle brackets after 'Gen'.
'Integer' is a "type argument" that is passed to 'Gen''s type
parameter, 'T'.  This effectively creates a version of 'Gen' in which
all references to 'T' are translated into references to 'Integer'.
Thus, 'ob' is of type 'Integer', and the return type of 'getob()' is
of type 'Integer'.

<Integer Type Parameter> ==
     Gen<Integer> iOb;


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

Reference Assignment
....................

The next line assigns to 'iOb' a reference to an instance of an
'Integer' version of the 'Gen' class.  When the 'Gen' constructor is
called, the type argument 'Integer' is also specified.  This is
because the type of the object (in this case 'iOb' to which the
reference is being assigned is of type 'Gen<Integer>'.  Thus, the
reference returned by 'new' must also be of type 'Gen<Integer>'.  If
it isn't, a compile-time error will result.  This type checking is one
of the main benefits of generics because it ensures type safety.

   Notice the use of autoboxing to encapsulate the value 88 within an
Integer object.

<Reference to Integer Instance> ==
     iOb = new Gen<Integer>(88);


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

   The automatic autoboxing could have been written explicitly, like
so:
     iOb = new Gen<Integer>(Integer.valueOf(88));
but there would be no value to doing it that way.

Showing the Reference's Type
............................

The program then uses 'Gen''s instance method to show the type of
'ob', which is an 'Integer' in this case.

<Show Type> ==
     iOb.showType();


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

Showing the Reference's Value
.............................

The program now obtains the value of 'ob' by assiging 'ob' to an 'int'
variable.  The return type of 'getob()' is 'Integer', which unboxes
into 'int' when assigned to an 'int' variable ('v').  There is no need
to cast the return type of 'getob()' to 'Integer'.

<Get Value> ==
     int v = iOb.getob();
     System.out.println("value: " + v);
     System.out.println();


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.


File: JavaSE9.info,  Node: GenDemo as String,  Prev: GenDemo as Integer,  Up: Class GenDemo

7.3.2.2 Implementation of Class GenDemo with Type String
........................................................

<Create a Gen object for Strings> ==
     // Create a Gen object for Strings.
     Gen<String> strOb = new Gen<String>("Generics Test");

     // Show the type of data used by strOb
     strOb.showType();

     // Get the value of strOb.  Again, notice
     // that no cast is needed.
     String str = strOb.getob();
     System.out.println("value: " + str);


This chunk is called by <Class GenDemo>; see its first definition at
*note Class-GenDemo::.


File: JavaSE9.info,  Node: Notes about Generics,  Next: Two Type Parameters,  Prev: Simple Generics Example,  Up: Generics

7.4 Notes About Generics
========================

* Menu:

* Reference Types::
* Type Arguments::
* Subtyping::
* Type Safety::


File: JavaSE9.info,  Node: Reference Types,  Next: Type Arguments,  Up: Notes about Generics

7.4.1 Generics Work Only with Reference Types
---------------------------------------------

When declaring an instance of a generic type, the type argument passed
to the type parameter must be a reference type.  It cannot be a
primitive type, such as 'int' or 'char'.

   You can use the type wrappers to encapsulate a primitive type.
Java's autoboxing and auto-unboxing mechanism makes the use of the
type wrapper transparent.


File: JavaSE9.info,  Node: Type Arguments,  Next: Subtyping,  Prev: Reference Types,  Up: Notes about Generics

7.4.2 Generic Types Differ Based on their Type Arguments
--------------------------------------------------------

A reference of one specific version of a generic type is not
type-compatible with another version of the same generic type.  In
other words, the following line of code is an error and will not
compile:

     iOb = strOb; // Gen<Integer> != Gen<String>

   These are references to different types because their type
arguments differ.


File: JavaSE9.info,  Node: Subtyping,  Next: Type Safety,  Prev: Type Arguments,  Up: Notes about Generics

7.4.3 Generics and Subtyping
----------------------------

Is the following legal?

     List<String> ls = new ArrayList<String>(); // 1
     List<Object> lo = ls; // 2

   Line 1 is legal.  What about line 2?  This boils down to the
question: "is a List of String a List of Object."  Most people
instinctively answer, "Sure!"

   Now look at these lines:

     lo.add(new Object()); // 3
     String s = ls.get(0); // 4: Attempts to assign an Object to a String!

   Here we've aliased 'ls' and 'lo'.  Accessing 'ls', a list of
'String', through the alias 'lo', we can insert arbitrary objects into
it.  As a result 'ls' does not hold just 'Strings' anymore, and when
we try and get something out of it, we get a rude surprise.

   The Java compiler will prevent this from happening of course.  Line
2 will cause a compile time error.

   The take-away is that, if 'Foo' is a subtype (subclass or
subinterface) of 'Bar', and 'G' is some generic type declaration, it
is not the case that 'G<Foo>' is a subtype of 'G<Bar>'.


File: JavaSE9.info,  Node: Type Safety,  Prev: Subtyping,  Up: Notes about Generics

7.4.4 How Generics Improve Type Safety
--------------------------------------

Generics automatically ensure the type safety of all operations
involving a generic class, such as 'Gen'.  They eliminate the need for
the coder to enter cases and to type-check code by hand.


File: JavaSE9.info,  Node: Two Type Parameters,  Next: Generic Class General Form,  Prev: Notes about Generics,  Up: Generics

7.5 A Generic Class with Two Type Parameters
============================================

You can declare more than one type parameter in a generic type.  To
specify two or more type parameters, use a comma-separated list.  When
an object is created, the same number of type arguments must be passed
as there are type parameters.  The type arguments can be the same or
different.

* Menu:

* Two Types Example Code::


File: JavaSE9.info,  Node: Two Types Example Code,  Up: Two Type Parameters

7.5.1 Example of Code with Two Type Parameters
----------------------------------------------

{'TwoTypeParameters.java'} ==
     <Class TwoGen>
     <Class SimpGen>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class SimpGen>           See *note Class-SimpGen::.
<Class TwoGen>            See *note Class-TwoGen::.

* Menu:

* Class TwoGen::
* Class SimpGen::


File: JavaSE9.info,  Node: Class TwoGen,  Next: Class SimpGen,  Up: Two Types Example Code

7.5.1.1 Class TwoGen
....................

<Class TwoGen> ==
     <Class Declaration>
       <Two Instance Variables Declarations>
       <Constructor of Two Parameters>
       <Instance Methods Show and Get>

This chunk is called by {'TwoTypeParameters.java'}; see its first
definition at *note TwoTypeParameters-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class Declaration>       See *note Class-Declaration::.
<Constructor of Two       See *note Constructor-of-Two-Parameters::.
Parameters>
<Instance Methods Show    See *note Instance-Methods-Show-and-Get::.
and Get>
<Two Instance Variables   See
Declarations>             *note Two-Instance-Variables-Declarations::.

Class Declaration
.................

Notice how 'TwoGen' is declared.  It specifies two type parameters:
'T' and 'V', separated by a comma.  Because it has two type
parameters, two type arguments must be passed to 'TwoGen' when an
object is created.

<Class Declaration> ==
     class TwoGen<T, V> {

This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Instance Variables Declarations
...............................

<Two Instance Variables Declarations> ==
     T ob1;
     V ob2;


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Constructor
...........

<Constructor of Two Parameters> ==
     TwoGen(T o1, V 02) {
       ob1 = o1;
       ob2 = o2;
     }


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Instance Methods Show and Get
.............................

<Instance Methods Show and Get> ==
     void showTypes() {
       System.out.println("Type of T is " + ob1.getClass().getName());
       System.out.println("Type of V is " + ob2.getClass().getName());
     }

     T getob1() {
       return ob1;
     }

     V getob2() {
       return ob2;
     }


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.


File: JavaSE9.info,  Node: Class SimpGen,  Prev: Class TwoGen,  Up: Two Types Example Code

7.5.1.2 Class SimpGen
.....................

Two type arguments must be supplied to the constructor.  In this case,
the two type parameters are 'Integer' and 'String'.

<Class SimpGen> ==
     class SimpGen {
       public static void main(String args[]) {
         TwoGen<Integer, String> tgObj =
           new TwoGen<Integer, String>(88, "Generics");

         // Show the types
         tgObj.showTypes();

         // Obtain and show values
         int v = tgObj.getob1();
         System.out.println("value: " + v);

         String str = thObj.getob2();
         System.out.println("value: " + str);
       }
     }

This chunk is called by {'TwoTypeParameters.java'}; see its first
definition at *note TwoTypeParameters-java::.


File: JavaSE9.info,  Node: Generic Class General Form,  Next: Bounded Types,  Prev: Two Type Parameters,  Up: Generics

7.6 The General Form of a Generic Class
=======================================

The generics syntax shown above can be generalized.  Here is the
syntax for declaring a generic class:

     class class-name<type-param-list> { ...

Here is the full syntax for declaring a reference to a generic class
and instance creation:

     class-name<type-arg-list> var-name =
       new class-name<type-arg-list>(cons-arg-list);

GeneralForm 7.1: General Form for Declaring and Creating a Reference
to a Generic Class


File: JavaSE9.info,  Node: Bounded Types,  Next: Wildcard Arguments,  Prev: Generic Class General Form,  Up: Generics

7.7 Bounded Types
=================

Sometimes it can be useful to limit the types that can be passed to a
type parameter.  Java provides "bounded types".  When specifying a
type parameter, you can create an upper bound that declares the
superclass from which all type arguments must be derived.  This is
accomplished through the use of an 'extends' clause when specifying
the type parameter:

      <T extends superclass>

   This specifies that T can only be replaced by superclass or
subclasses of superclass.  Thus, superclass defines an inclusive,
upper limit.

Interface Type as a Bound
-------------------------

In addition to using a class type as a bound, you can also use an
interface type.  In fact, youi can specify multiple interfaces as
bounds.  Furthermore, a bound can include both a class type and one or
more interfaces.  In this case, the class type must be specified
first.  When a bound includes an interface type, only type arguments
that implement that interface are legal.

   When specifying a bound that has a class and an interface, or
multiple interfaces, use the '&' operator to connnect them.

     class Gen<T extends MyClass & MyInterface> { ...

   Any type argument passed to 'T' must be a subclass of 'MyClass' and
implement 'MyInterface'.


File: JavaSE9.info,  Node: Wildcard Arguments,  Next: Generic Methods,  Prev: Bounded Types,  Up: Generics

7.8 Using Wildcard Arguments
============================

* Menu:

* Wildcard Motivation::
* Wildcard Syntax::
* Bounded Wildcards::


File: JavaSE9.info,  Node: Wildcard Motivation,  Next: Wildcard Syntax,  Up: Wildcard Arguments

7.8.1 Wildcard Motivation
-------------------------

Consider the problem of writing a routine that prints out all the
elements in a collection.  Here's how you might write it in an older
version of the language (i.e., a pre-5.0 release):

     void printCollection(Collection c) {
         Iterator i = c.iterator();
         for (k = 0; k < c.size(); k++) {
             System.out.println(i.next());
         }
     }

   And here is a naive attempt at writing it using generics (and the
new 'for loop' syntax):

         for (Object e : c) {
             System.out.println(e);
         }
     }

   The problem is that this new version is much less useful than the
old one.  Whereas the old code could be called with any kind of
collection as a parameter, the new code only takes
'Collection<Object>', which, as we've just demonstrated, is _not_ a
supertype of all kinds of collections!

   So what is the supertype of all kinds of collections?  It's written
'Collection<?>' (pronounced "collection of unknown"), that is, a
collection whose element type matches anything.  It's called a
"wildcard type".  We can write:

     void printCollection(Collection<?> c) {
         for (Object e : c) {
             System.out.println(e);
         }
     }

   and now, we can call it with any type of collection.  Notice that
inside 'printCollection()', we can still read elements from 'c' and
give them type 'Object'.  This is always safe, since whatever the
actual type of the collection, it does contain objects.  It isn't safe
to add arbitrary objects to it however:

     Collection<?> c = new ArrayList<String>();
     c.add(new Object()); // Compile time error

   Since we don't know what the element type of 'c' stands for, we
cannot add objects to it.  The 'add()' method takes arguments of type
'E', the element type of the collection.  When the actual type
parameter is '?', it stands for some unknown type.  Any parameter we
pass to 'add' would have to be a subtype of this unknown type.  Since
we don't know what type that is, we cannot pass anything in.  The sole
exception is 'null', which is a member of every type.

   On the other hand, given a 'List<?>', we can call 'get()' and make
use of the result.  The result type is an unknown type, but we always
know that it is an object.  It is therefore safe to assign the result
of 'get()' to a variable of type 'Object' or pass it as a parameter
where the type 'Object' is expected.


File: JavaSE9.info,  Node: Wildcard Syntax,  Next: Bounded Wildcards,  Prev: Wildcard Motivation,  Up: Wildcard Arguments

7.8.2 Wildcard Syntax
---------------------

Sometimes type safety can get in the way of perfectly acceptable
constructs.  In such cases, there is a "wildcard" argument that can be
used.  The wildcard argument is specified by the '?', and it
represents an unknown type.  It would be used in place of a type
parameter, for example:

     boolean sameAvg(Stats<?> ob) {
       if(average() == ob.average())
         return true;

       return false;
     }

   Here, 'Stats<?>' matches any 'Stats' object ('Integer', 'Double'),
allowing any two 'Stats' objects to have their averages compared.  The
wildcard does not affect what type of 'Stats' object can be created.
That is governed by the 'extends' clause in the 'Stats' declaration.
The wildcard simply matches any _valid_ 'Stats' object.


File: JavaSE9.info,  Node: Bounded Wildcards,  Prev: Wildcard Syntax,  Up: Wildcard Arguments

7.8.3 Bounded Wildcards
-----------------------

Wildcard arguments can be bounded in much the same way that a type
parameter can be bounded (the "bounded wildcard argument".  A bounded
wildcard is especially important when you are creating a generic type
that will operate on a class hierarchy.

   A bounded wildcard specifies either an upper bound or a lower bound
for the type argument.  This enables you to restrict the types of
objects upon which a method will operate.

Upper Bounded Wildcard
......................

The most common bounded wildcard is the upper bound, which is created
using an 'extends' clause.In general, to establish an upper bound for
a wildcard, use the following type of wildcard expression:

     <? extends superclass>

GeneralForm 7.2: General Form of Upper Bounded Wildcard Syntax

   where superclass is the name of the class that serves as the upper
bound.  This is an inclusive clause.

Lower Bounded Wildcard
......................

You can also specify a lower bound for a wildcard by adding a 'super'
clause to a wildcard declaration.  Here is its general form:

     <? super subclass>

GeneralForm 7.3: General Form of Lower Bounded Wildcard Syntax

   Only classes that are superclasses of subclass are acceptable
arguments


File: JavaSE9.info,  Node: Generic Methods,  Next: Generic Constructors,  Prev: Wildcard Arguments,  Up: Generics

7.9 Creating a Generic Method
=============================

It is possible to declare a generic method that uses one or more type
parameters of its own.  It is also possible to create a generic method
that is enclosed within a non-generic class.

Generalized Form
----------------

     < type-param-list > ret-type meth-name ( param-list ) { ...

GeneralForm 7.4: General Form for Declaring a Generic Method

* Menu:

* Example of Generic Method::


File: JavaSE9.info,  Node: Example of Generic Method,  Up: Generic Methods

7.9.1 Example of Generic Method
-------------------------------

The following program declares a non-generic class called
'GenMethDemo' and a static *generic method* within that class called
'isIn()'.  The 'isIn()' method determines if an object is a member of
an array.  It can be used with any type of object and array as long as
the array contains objects that are compatible with the type of the
object being sought.

{'GenMethDemo.java'} ==
     class GenMethDemo {
       <Static Method isIn>
       <GenMethDemo Main>
     }

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<GenMethDemo Main>        See *note GenMethDemo-Main::.
<Static Method isIn>      See *note Static-Method-isIn::.

* Menu:

* Method isIn::
* GenMethDemo Main::


File: JavaSE9.info,  Node: Method isIn,  Next: GenMethDemo Main,  Up: Example of Generic Method

7.9.1.1 Method isIn()
.....................

The *type parameters* are declared _before_ the return type of the
method.

<Static Method isIn> ==
     static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {

       for (int i = 0; i < y.length; i++)
         if (x.equals(y[i]) return true;

       return false;
     }


This chunk is called by {'GenMethDemo.java'}; see its first definition
at *note GenMethDemo-java::.

   The type T is *upper-bounded* by the 'Comparable' interface, which
must be of the same type as T. Likewise, the second type, V, is also
*upper-bounded* by T. Thus, V must be either the same type as T or a
subclass of T. This relationship enforces that 'isIn()' can be called
only with arguments that are compatible with each other.

   While 'isIn()' is static in this case, generic methods can be
either static or non-static; there is no restriction in this regard.

Explicitly Including Type Arguments
...................................

There is generally no need to specify type arguments when calling this
method from within the 'main' routine.  This is because the type
arguments are automatically discerned, and the types of T and V are
adjusted accordingly.

   Although type inference will be sufficient for most generic method
calls, you can explicitly specify the type argument if needed.  For
example, here is how the first call to 'isIn()' looks when the type
argumetns are specified:

     GenMethDemo.<Integer, Integer>isIn(2, nums)


File: JavaSE9.info,  Node: GenMethDemo Main,  Prev: Method isIn,  Up: Example of Generic Method

7.9.1.2 GenMethDemo Main
........................

<GenMethDemo Main> ==
     public static void main(String args[]) {

       // call isIn() with Integer type
       Integer nums[] = { 1, 2, 3, 4, 5 };

       if ( isIn(2, nums) )
         System.out.println("2 is in nums");

       if ( @isIn(7, nums))
         System.out.println("7 is not in nums");

       System.out.println();

       // call isIn() with String type
       String strs[] = { "one", "two", "three", "four", "five" };

       if ( isIn("two", strs))
         System.out.println("two is in strs");

       if ( !isIn("seven", strs))
         System.out.println("seven is not in strs");

       // call isIn() with mixed types
       // WILL NOT COMPILE! TYPES MUST BE COMPATIBLE
       // if ( isIn("two", nums))
       //    System.out.println("two is in nums");
     }


This chunk is called by {'GenMethDemo.java'}; see its first definition
at *note GenMethDemo-java::.


File: JavaSE9.info,  Node: Generic Constructors,  Prev: Generic Methods,  Up: Generics

7.10 Generic Constructors
=========================

It is possible for constructors to be generic, even if their class is
not (*note generics-constructor::).  The syntax is the same (type
parameters come first).

     < type-param-list> constructor-name ( param-list ) { ...


File: JavaSE9.info,  Node: Enumerations,  Next: Strings,  Prev: Generics,  Up: Top

8 Enumerations
**************

Enumerations were added by JDK 5.  In earlier versions of Java,
enumerations were implemented using 'final' variables.

   An "enumeration" is a list of named constants that define a new
data type and its legal values.  In other words, an enumeration
defines a class type.  An "enumeration object" can only hold values
that were declared in the list.  Other values are not allowed.  An
enumeration allows the programmer to define a set of values that a
data type can legally have.

   By making enumerations classes, the capabilities of the enumeration
are greatly expanded.  An enumeration can have:

   * constructors
   * methods
   * instance variables

* Menu:

* Enumeration Basics::
* Enum Methods::
* Enumerations as Class Types::
* Inherit Enum::


File: JavaSE9.info,  Node: Enumeration Basics,  Next: Enum Methods,  Up: Enumerations

8.1 Enumeration Basics
======================

An enumeration is created using the 'enum' keyword.

     enum Apple {
          Jonathon, GoldenDel, RedDel, Winesap, Cortland
     }

enumeration constants
---------------------

The enum constants 'Jonathon', 'GoldenDel', etc.  are called
"enumeration constants".  The enumeration constants are declared as
'public static final' members of the enum.  Their type is the type of
the enumeration in which they are declared.  These constants are
called "self-typed", in which "self" refers to the enclosing
enumeration.

enumeration objects
-------------------

You can create a variable of an enumeration type.  You do not
instantiate an 'enum' using 'new'.  Rather, you declare an 'enum'
variable like you do for primitive types: 'Apple ap'.  Now, the
variable 'ap' can only hold values of type 'Apple'.

     Apple ap;
     ap = Apple.RedDel;

   The 'enum' type (i.e., 'Apple') must be part of the expression.

Comparing for Equality; Switch
------------------------------

Two enumeration constants can be compared for equality using the '=='
relational operator.  Furthermore, an enumneration value can be used
to control a 'switch' statement.  The 'enum' prefix (type) is not
required for 'switch'.

     switch(ap) {
       case Jonathon: ...
       case Winesap: ...
     }

Printing Enum Types
-------------------

When an enumeration object is printed, its name is output (without the
'enum' type): 'System.out.println(ap)' would produce 'RedDel'.


File: JavaSE9.info,  Node: Enum Methods,  Next: Enumerations as Class Types,  Prev: Enumeration Basics,  Up: Enumerations

8.2 Enum Methods 'values()' and 'valueOf()'
===========================================

All enumerations inherit two methods:

 -- Method on Enum:
          public static enum-type[]
          values ()
     The 'values()' method returns an array that contains a list of
     the enumeration constants.

 -- Method on Enum:
          public static enum-type
          valueOf (String STR)
     The 'valueOf()' method returns the enumeration constant whose
     value corresponds to the string passed in STR.

Examples using 'values()' and 'valueOf()' Methods
-------------------------------------------------

'Apple allapples[] = Apple.values();' is an example of using the
'values()' method to populate an array with enumeration constants.

     for(Apple a : Apple.values()) {
       System.out.println(a);
     }

is an example of iterating directly on the 'values()' method.

     Apple ap;
     ap = Apple.valueOf("Winesap");
     System.out.println("ap contains " + ap);

is an example of using the 'valueOf()' method to obtain the
enumeration constant corresponding to the value of a string.


File: JavaSE9.info,  Node: Enumerations as Class Types,  Next: Inherit Enum,  Prev: Enum Methods,  Up: Enumerations

8.3 Java Enumerations are Class Types
=====================================

A Java enumeration is a class type.  That is, 'enum' defines a class,
which has much the same capabilities as other classes.  An enumeration
can be given constructors, instance variables, and methods.  It can
even implement interfaces.  Each enumeration constant is an object of
its enumeration type.  When an enumeration is given a constructor, the
constructor is called when each enumeration constant is created.
Also, each enumeration constant has its own copy of any instance
variables defined by the enumeration.

     enum Apple {
       Jonathon(10), GoldenDel(9), RedDel(12), Winesap(15), Cortland(8);
       private int price;
       Apple(int p) { price = p; }
       int getPrice() { return price; }
     }

     class EnumDemo {
       public static void main (String[] args) {
         Apple ap;
       }
     }

   In this example, the enumeration 'Apple' is given an instance
variable 'price', a constructor, and an instance method 'getPrice()'.
When the variable 'ap' is declared in 'main()', the constructor for
'Apple' is called once for each constant that is specified.  The
arguments to the constructor are placed in parentheses after the name
of each constant.  Thereafter, each enumeration constant has its own
copy of 'price', which can be obtained by calling the instance method
'getPrice()'.  In addition, there can be multiple overloaded
constructors just as for any other class.

Restrictions on Enums
---------------------

   * An enumeration cannot inherit another class.
   * An 'enum' cannot be a superclass ('enum' cannot be extended).

   The key is to remember that each enumeration constant is an object
of the class in which it is defined.


File: JavaSE9.info,  Node: Inherit Enum,  Prev: Enumerations as Class Types,  Up: Enumerations

8.4 Enumerations Inherit 'Enum'
===============================

All enumerations automatically inherit from one superclass:
'java.lang.Enum'.  This class defines several methods that are
available for use by all enumerations.

'ordinal()' and 'compareTo()'
-----------------------------

 -- Method on Enum:
          final int
          ordinal ()
     The 'ordinal()' method returns a value that indicates an
     enumeration constant's position in the list of constants, called
     its "ordinal value".  In other words, calling 'ordinal()' returns
     the ordinal value of the invoking constant (zero indexed).

 -- Method on Enum:
          final int
          compareTo (enum-type E)
     The ordinal values of two constants can be compared using the
     'compareTo()' method.  Both the invoking constant and E must be
     of the same enumeration enum-type.  This method returns a
     negative value, a zero, or a positive value depending on whether
     the invoking constant's ordinal value is less than, equal to, or
     greater than the passed-in enumeration constant's ordinal value.

'equals()' and '=='
-------------------

 -- Method on Enum:
          boolean
          equals (enum-type E)
 -- Method on Enum:
          boolean
          == (enum-type E)
     Compare for equality an invoking enum constant with a referenced
     enum constant.

   An invoking enum constant can compare for equality itself with any
other object by using 'equals()' or, equivalently, '==', which
overrides the 'equals()' method defined in 'Object'.  'equals()' will
return true only if both objects refer to the same constant within the
same enumeration.  (In other words, 'equals' does not just compare
ordinal values in general.)


File: JavaSE9.info,  Node: Strings,  Next: java Lang,  Prev: Enumerations,  Up: Top

9 String Handling
*****************


File: JavaSE9.info,  Node: java Lang,  Next: java util Collections,  Prev: Strings,  Up: Top

10 'java.lang'
**************

Classes and interfaces defined by 'java.lang', which is automatically
imported into all programs.  Contains classes and interfaces that are
fundamental to all of Java programming.  Beginning with JDK 9, all of
'java.lang' is part of the 'java.base' module.

'java.lang' includes the following classes
------------------------------------------

   * Boolean
   * Byte
   * Character
        * Character.Subset
        * Character.UnicodeBlock
   * Class
   * ClassLoader
   * ClassValue
   * Compiler
   * Double
   * Enum
   * Float
   * InheritableThreadLocal
   * Integer
   * Long
   * Math
   * Module
        * ModuleLayer
        * ModuleLayer.Controller
   * Number
   * Object
   * Package
   * Process
        * ProcessBuilder
        * ProcessBuilder.Redirect
   * Runtime
        * RuntimePermission
        * Runtime.Version
   * SecurityManager
   * Short
   * StackFramePermission
   * StackTraceElement
   * StackWalker
   * StrictMath
   * String
        * StringBuffer
        * StringBuilder
   * System
        * System.LoggerFinder
   * Thread
        * ThreadGroup
        * ThreadLocal
   * Throwable
   * Void

'java.lang' includes the following interfaces
---------------------------------------------

   * Appendable
   * AutoClosable
   * CharSequence
   * Clonable
   * Comparable
   * Iterable
   * ProcessHandle
        * ProcessHandle.Info
   * Readable
   * Runnable
   * StackWalker.StackFrame
   * System.Logger
   * Thread.UncaughtExceptionHandler

* Menu:

* Primitive Wrappers::


File: JavaSE9.info,  Node: Primitive Wrappers,  Up: java Lang

10.1 Primitive Type Wrappers
============================

Java uses primitive types for 'int', 'char', etc.  for performance
reasons.  These primitives are not part of the object hierarchy; they
are passed by-value, not by reference.  Sometimes you may need to
create an object representation for a primitive type.  To store a
primitive in a class, you need to wrap the primitive type in a class.

   Java provides classes that correspond to each of the primitive
types.  These classes encapsulate or "wrap" the primitive types within
a class.  They are commonly referred to as "type wrappers".

* Menu:

* Number::
* Double and Float::
* isInfiinite() and isNaN()::
* Byte Short Integer Long::
* Numbers to from String::


File: JavaSE9.info,  Node: Number,  Next: Double and Float,  Up: Primitive Wrappers

10.1.1 Number
-------------


File: JavaSE9.info,  Node: Double and Float,  Next: isInfiinite() and isNaN(),  Prev: Number,  Up: Primitive Wrappers

10.1.2 Double and Float
-----------------------


File: JavaSE9.info,  Node: isInfiinite() and isNaN(),  Next: Byte Short Integer Long,  Prev: Double and Float,  Up: Primitive Wrappers

10.1.3 isInfinite() and isNaN()
-------------------------------


File: JavaSE9.info,  Node: Byte Short Integer Long,  Next: Numbers to from String,  Prev: isInfiinite() and isNaN(),  Up: Primitive Wrappers

10.1.4 Byte, Short, Integer, Long
---------------------------------


File: JavaSE9.info,  Node: Numbers to from String,  Prev: Byte Short Integer Long,  Up: Primitive Wrappers

10.1.5 Converting Numbers to and from String
--------------------------------------------


File: JavaSE9.info,  Node: java util Collections,  Next: java util Utility Classes,  Prev: java Lang,  Up: Top

11 'java.util' -- Part 1: The Collections Framework
***************************************************


File: JavaSE9.info,  Node: java util Utility Classes,  Next: java io Input Output,  Prev: java util Collections,  Up: Top

12 'java.util' -- Part 2: Utility Classes
*****************************************


File: JavaSE9.info,  Node: java io Input Output,  Next: NIO,  Prev: java util Utility Classes,  Up: Top

13 'java.io' -- Input/Output
****************************


File: JavaSE9.info,  Node: NIO,  Next: Networking,  Prev: java io Input Output,  Up: Top

14 NIO
******


File: JavaSE9.info,  Node: Networking,  Next: Event Handling,  Prev: NIO,  Up: Top

15 Networking
*************


File: JavaSE9.info,  Node: Event Handling,  Next: AWT,  Prev: Networking,  Up: Top

16 Event Handling
*****************


File: JavaSE9.info,  Node: AWT,  Next: AWT Controls,  Prev: Event Handling,  Up: Top

17 AWT: Working with Windows, Graphics, and Text
************************************************


File: JavaSE9.info,  Node: AWT Controls,  Next: Images,  Prev: AWT,  Up: Top

18 Using AWT Controls, Layout Managers, and Menus
*************************************************


File: JavaSE9.info,  Node: Images,  Next: Concurrency,  Prev: AWT Controls,  Up: Top

19 Images
*********


File: JavaSE9.info,  Node: Concurrency,  Next: Streams,  Prev: Images,  Up: Top

20 The Concurrency Utilities
****************************


File: JavaSE9.info,  Node: Streams,  Next: Regular Expressions,  Prev: Concurrency,  Up: Top

21 The Stream API
*****************


File: JavaSE9.info,  Node: Regular Expressions,  Next: Swing,  Prev: Streams,  Up: Top

22 Regular Expressions and Other Packages
*****************************************


File: JavaSE9.info,  Node: Swing,  Next: The Makefile,  Prev: Regular Expressions,  Up: Top

23 Introducinvg Swing
*********************


File: JavaSE9.info,  Node: The Makefile,  Next: Code Chunk Summaries,  Prev: Swing,  Up: Top

Appendix A The Makefile
***********************

{'Makefile'} ==
     <Makefile CONSTANTS>
     <Makefile DEFAULTS>
     <Makefile TANGLE WEAVE>
     <Makefile CLEAN>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Makefile CLEAN>          See *note Makefile-CLEAN::.
<Makefile CONSTANTS>      See *note Makefile-CONSTANTS::.
<Makefile DEFAULTS>       See *note Makefile-DEFAULTS::.
<Makefile TANGLE WEAVE>   See *note Makefile-TANGLE-WEAVE::.

* Menu:

* Makefile Constants::
* Makefile Defaults::
* Makefile Tangle Weave::
* Makefile Clean::


File: JavaSE9.info,  Node: Makefile Constants,  Next: Makefile Defaults,  Up: The Makefile

A.1 Makefile Constants
======================

<Makefile CONSTANTS> ==
     FILENAME := JavaSE9


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Makefile Defaults,  Next: Makefile Tangle Weave,  Prev: Makefile Constants,  Up: The Makefile

A.2 Makefile Default Targets
============================

<Makefile DEFAULTS> ==
     .PHONY: all
     all: tangle weave


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Makefile Tangle Weave,  Next: Makefile Clean,  Prev: Makefile Defaults,  Up: The Makefile

A.3 Makefile Tangle Weave Targets
=================================

<Makefile TANGLE WEAVE> ==
     .PHONY: tangle weave jrtangle jrweave
     tangle: jrtangle
     weave: jrweave

     jrtangle: $(FILENAME).twjr
         jrtangle $(FILENAME).twjr

     jrweave: $(FILENAME).texi

     $(FILENAME).texi: $(FILENAME).twjr
         jrweave $(FILENAME).twjr > $(FILENAME).texi

This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Makefile Clean,  Prev: Makefile Tangle Weave,  Up: The Makefile

A.4 Makefile Clean Targets
==========================

<Makefile CLEAN> ==
     .PHONY: clean
     clean:
         rm -f *~
         rm -f $(FILENAME).???


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: JavaSE9.info,  Node: Code Chunk Summaries,  Next: List of Tables,  Prev: The Makefile,  Up: Top

Appendix B Code Chunk Summaries
*******************************

This major node presents alphabetical lists of all the file
definitions, the code chunk definitions, and the code chunk
references.

* Menu:

* File Definitions::            Source files by definition.
* Code Chunk Definitions::      Code chunks by definition.
* Code Chunk References::       Code chunks by reference.


File: JavaSE9.info,  Node: File Definitions,  Next: Code Chunk Definitions,  Up: Code Chunk Summaries

B.1 Source File Definitions
===========================

{'GenMethDemo.java'}
     This chunk is defined in *note GenMethDemo-java::.
{'Makefile'}
     This chunk is defined in *note Makefile::.
{'SimpleGenerics.java'}
     This chunk is defined in *note SimpleGenerics-java::.
{'Stack.java'}
     This chunk is defined in *note Stack-java::.
{'StackImproved.java'}
     This chunk is defined in *note StackImproved-java::.
{'TestStack.java'}
     This chunk is defined in *note TestStack-java::.
{'TwoTypeParameters.java'}
     This chunk is defined in *note TwoTypeParameters-java::.


File: JavaSE9.info,  Node: Code Chunk Definitions,  Next: Code Chunk References,  Prev: File Definitions,  Up: Code Chunk Summaries

B.2 Code Chunk Definitions
==========================

<Class Declaration>
     This chunk is defined in *note Class-Declaration::.
<Class Gen>
     This chunk is defined in *note Class-Gen::.
<Class GenDemo>
     This chunk is defined in *note Class-GenDemo::.
<Class SimpGen>
     This chunk is defined in *note Class-SimpGen::.
<Class TwoGen>
     This chunk is defined in *note Class-TwoGen::.
<Constructor of Two Parameters>
     This chunk is defined in *note Constructor-of-Two-Parameters::.
<Constructor taking parameter of Type T>
     This chunk is defined in *note
     Constructor-taking-parameter-of-Type-T::.
<Create a Gen object for Integers>
     This chunk is defined in *note
     Create-a-Gen-object-for-Integers::.
<Create a Gen object for Strings>
     This chunk is defined in *note Create-a-Gen-object-for-Strings::.
<GenMethDemo Main>
     This chunk is defined in *note GenMethDemo-Main::.
<Get Value>
     This chunk is defined in *note Get-Value::.
<Instance Methods Show and Get>
     This chunk is defined in *note Instance-Methods-Show-and-Get::.
<Instance Variable ob of Type T>
     This chunk is defined in *note Instance-Variable-ob-of-Type-T::.
<Integer Type Parameter>
     This chunk is defined in *note Integer-Type-Parameter::.
<Makefile CLEAN>
     This chunk is defined in *note Makefile-CLEAN::.
<Makefile CONSTANTS>
     This chunk is defined in *note Makefile-CONSTANTS::.
<Makefile DEFAULTS>
     This chunk is defined in *note Makefile-DEFAULTS::.
<Makefile TANGLE WEAVE>
     This chunk is defined in *note Makefile-TANGLE-WEAVE::.
<Method returning object of type T>
     This chunk is defined in *note
     Method-returning-object-of-type-T::.
<Method showing type of T>
     This chunk is defined in *note Method-showing-type-of-T::.
<Reference to Integer Instance>
     This chunk is defined in *note Reference-to-Integer-Instance::.
<Show Type>
     This chunk is defined in *note Show-Type::.
<Stack Constructor>
     This chunk is defined in *note Stack-Constructor::.
<Stack Instance Methods>
     This chunk is defined in *note Stack-Instance-Methods::.
<Stack Instance Variables>
     This chunk is defined in *note Stack-Instance-Variables::.
<Stack Pop>
     This chunk is defined in *note Stack-Pop::.
<Stack Private Instance Variables>
     This chunk is defined in *note
     Stack-Private-Instance-Variables::.
<Stack Push>
     This chunk is defined in *note Stack-Push::.
<Static Method isIn>
     This chunk is defined in *note Static-Method-isIn::.
<TestStack Main Method>
     This chunk is defined in *note TestStack-Main-Method::.
<Two Instance Variables Declarations>
     This chunk is defined in *note
     Two-Instance-Variables-Declarations::.


File: JavaSE9.info,  Node: Code Chunk References,  Prev: Code Chunk Definitions,  Up: Code Chunk Summaries

B.3 Code Chunk References
=========================

<Class Declaration>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.
<Class Gen>

     This chunk is called by {'SimpleGenerics.java'}; see its first
     definition at *note SimpleGenerics-java::.
<Class GenDemo>

     This chunk is called by {'SimpleGenerics.java'}; see its first
     definition at *note SimpleGenerics-java::.
<Class SimpGen>

     This chunk is called by {'TwoTypeParameters.java'}; see its first
     definition at *note TwoTypeParameters-java::.
<Class TwoGen>

     This chunk is called by {'TwoTypeParameters.java'}; see its first
     definition at *note TwoTypeParameters-java::.
<Constructor of Two Parameters>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.
<Constructor taking parameter of Type T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Create a Gen object for Integers>

     This chunk is called by <Class GenDemo>; see its first definition
     at *note Class-GenDemo::.
<Create a Gen object for Strings>

     This chunk is called by <Class GenDemo>; see its first definition
     at *note Class-GenDemo::.
<GenMethDemo Main>

     This chunk is called by {'GenMethDemo.java'}; see its first
     definition at *note GenMethDemo-java::.
<Get Value>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Instance Methods Show and Get>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.
<Instance Variable ob of Type T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Integer Type Parameter>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Makefile CLEAN>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile CONSTANTS>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile DEFAULTS>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile TANGLE WEAVE>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Method returning object of type T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Method showing type of T>

     This chunk is called by <Class Gen>; see its first definition at
     *note Class-Gen::.
<Reference to Integer Instance>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Show Type>

     This chunk is called by <Create a Gen object for Integers>; see
     its first definition at *note Create-a-Gen-object-for-Integers::.
<Stack Constructor>

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     {'Stack.java'}            See *note Stack-java::.
     {'StackImproved.java'}    See *note StackImproved-java::.
<Stack Instance Methods>

     This chunk is called by the following chunks:

     Chunk name                First definition point
     -------------------------------------------------------------------------
     {'Stack.java'}            See *note Stack-java::.
     {'StackImproved.java'}    See *note StackImproved-java::.
<Stack Instance Variables>

     This chunk is called by {'Stack.java'}; see its first definition
     at *note Stack-java::.
<Stack Pop>

     This chunk is called by <Stack Instance Methods>; see its first
     definition at *note Stack-Instance-Methods::.
<Stack Private Instance Variables>

     This chunk is called by {'StackImproved.java'}; see its first
     definition at *note StackImproved-java::.
<Stack Push>

     This chunk is called by <Stack Instance Methods>; see its first
     definition at *note Stack-Instance-Methods::.
<Static Method isIn>

     This chunk is called by {'GenMethDemo.java'}; see its first
     definition at *note GenMethDemo-java::.
<TestStack Main Method>

     This chunk is called by {'TestStack.java'}; see its first
     definition at *note TestStack-java::.
<Two Instance Variables Declarations>

     This chunk is called by <Class TwoGen>; see its first definition
     at *note Class-TwoGen::.


File: JavaSE9.info,  Node: List of Tables,  Next: List of General Forms,  Prev: Code Chunk Summaries,  Up: Top

List of Tables
**************

* Menu:

* Table 5.1: PackageAccess.              Package Access Table


File: JavaSE9.info,  Node: List of General Forms,  Next: Bibliography,  Prev: List of Tables,  Up: Top

List of General Forms
*********************

* Menu:

* GeneralForm 2.1: ClassDeclaration.     Class Declaration -- ...
* GeneralForm 2.2: MethodDeclaration.    Method Declaration -- ...
* GeneralForm 5.1: PackageStatement.     Package Statement -- ...
* GeneralForm 5.2: PackageStatementMulti.Package Statement -- ...
* GeneralForm 5.3: Import.               Import Statement -- ...
* GeneralForm 6.1: InterfaceSimple.      Interface Definition -- ...
* GeneralForm 6.2: ClassImplementsInterface.
                                         Class Implementing ...
* GeneralForm 6.3: InterfaceStaticMethod.Interface Static Method, ...
* GeneralForm 7.1: GenericClass.         General Form Generic Class
* GeneralForm 7.2: UpperBoundedWildcard. Upper Bounded Wildcard
* GeneralForm 7.3: LowerBoundedWildcard. Lower Bounded Wildcard
* GeneralForm 7.4: GenericMethod.        Generic Method Declaration


File: JavaSE9.info,  Node: Bibliography,  Next: Concept Index,  Prev: List of General Forms,  Up: Top

Bibliography
************


File: JavaSE9.info,  Node: Concept Index,  Next: Function Index,  Prev: Bibliography,  Up: Top

Index
*****

 [index ]
* Menu:

* <Class Declaration>, definition:       Class TwoGen.      (line  34)
* <Class Declaration>, use:              Class TwoGen.      (line   6)
* <Class Gen>, definition:               Class Gen<T>.      (line  33)
* <Class Gen>, use:                      Simple Generics Example.
                                                            (line   9)
* <Class GenDemo>, definition:           Class GenDemo.     (line  22)
* <Class GenDemo>, use:                  Simple Generics Example.
                                                            (line   9)
* <Class SimpGen>, definition:           Class SimpGen.     (line   9)
* <Class SimpGen>, use:                  Two Types Example Code.
                                                            (line   6)
* <Class TwoGen>, definition:            Class TwoGen.      (line   6)
* <Class TwoGen>, use:                   Two Types Example Code.
                                                            (line   6)
* <Constructor of Two Parameters>, definition: Class TwoGen.
                                                            (line  54)
* <Constructor of Two Parameters>, use:  Class TwoGen.      (line   6)
* <Constructor taking parameter of Type T>, definition: Class Gen<T>.
                                                            (line  79)
* <Constructor taking parameter of Type T>, use: Class Gen<T>.
                                                            (line  33)
* <Create a Gen object for Integers>, definition: GenDemo as Integer.
                                                            (line   6)
* <Create a Gen object for Integers>, use: Class GenDemo.   (line  22)
* <Create a Gen object for Strings>, definition: GenDemo as String.
                                                            (line   6)
* <Create a Gen object for Strings>, use: Class GenDemo.    (line  22)
* <GenMethDemo Main>, definition:        GenMethDemo Main.  (line   6)
* <GenMethDemo Main>, use:               Example of Generic Method.
                                                            (line  13)
* <Get Value>, definition:               GenDemo as Integer.
                                                            (line  91)
* <Get Value>, use:                      GenDemo as Integer.
                                                            (line   6)
* <Instance Methods Show and Get>, definition: Class TwoGen.
                                                            (line  67)
* <Instance Methods Show and Get>, use:  Class TwoGen.      (line   6)
* <Instance Variable ob of Type T>, definition: Class Gen<T>.
                                                            (line  63)
* <Instance Variable ob of Type T>, use: Class Gen<T>.      (line  33)
* <Integer Type Parameter>, definition:  GenDemo as Integer.
                                                            (line  36)
* <Integer Type Parameter>, use:         GenDemo as Integer.
                                                            (line   6)
* <Makefile CLEAN>, definition:          Makefile Clean.    (line   6)
* <Makefile CLEAN>, use:                 The Makefile.      (line   6)
* <Makefile CONSTANTS>, definition:      Makefile Constants.
                                                            (line   6)
* <Makefile CONSTANTS>, use:             The Makefile.      (line   6)
* <Makefile DEFAULTS>, definition:       Makefile Defaults. (line   6)
* <Makefile DEFAULTS>, use:              The Makefile.      (line   6)
* <Makefile TANGLE WEAVE>, definition:   Makefile Tangle Weave.
                                                            (line   6)
* <Makefile TANGLE WEAVE>, use:          The Makefile.      (line   6)
* <Method returning object of type T>, definition: Class Gen<T>.
                                                            (line  97)
* <Method returning object of type T>, use: Class Gen<T>.   (line  33)
* <Method showing type of T>, definition: Class Gen<T>.     (line 115)
* <Method showing type of T>, use:       Class Gen<T>.      (line  33)
* <Reference to Integer Instance>, definition: GenDemo as Integer.
                                                            (line  58)
* <Reference to Integer Instance>, use:  GenDemo as Integer.
                                                            (line   6)
* <Show Type>, definition:               GenDemo as Integer.
                                                            (line  76)
* <Show Type>, use:                      GenDemo as Integer.
                                                            (line   6)
* <Stack Constructor>, definition:       Stack Constructor Node.
                                                            (line   6)
* <Stack Constructor>, use:              Stack Class.       (line  22)
* <Stack Constructor>, use <1>:          Improved Stack Class.
                                                            (line  11)
* <Stack Instance Methods>, definition:  Stack Instance Methods Node.
                                                            (line   6)
* <Stack Instance Methods>, use:         Stack Class.       (line  22)
* <Stack Instance Methods>, use <1>:     Improved Stack Class.
                                                            (line  11)
* <Stack Instance Variables>, definition: Stack Instance Variables.
                                                            (line   6)
* <Stack Instance Variables>, use:       Stack Class.       (line  22)
* <Stack Pop>, definition:               Stack Push and Pop Node.
                                                            (line  19)
* <Stack Pop>, use:                      Stack Instance Methods Node.
                                                            (line   6)
* <Stack Private Instance Variables>, definition: Improved Stack Class.
                                                            (line  31)
* <Stack Private Instance Variables>, use: Improved Stack Class.
                                                            (line  11)
* <Stack Push>, definition:              Stack Push and Pop Node.
                                                            (line   6)
* <Stack Push>, use:                     Stack Instance Methods Node.
                                                            (line   6)
* <Static Method isIn>, definition:      Method isIn.       (line   9)
* <Static Method isIn>, use:             Example of Generic Method.
                                                            (line  13)
* <TestStack Main Method>, definition:   Stack TestStack Node.
                                                            (line   6)
* <TestStack Main Method>, use:          Stack Class.       (line  42)
* <Two Instance Variables Declarations>, definition: Class TwoGen.
                                                            (line  43)
* <Two Instance Variables Declarations>, use: Class TwoGen. (line   6)
* ==:                                    Enumeration Basics.
                                                            (line  38)
* {GenMethDemo.java}, definition:        Example of Generic Method.
                                                            (line  13)
* {Makefile}, definition:                The Makefile.      (line   6)
* {SimpleGenerics.java}, definition:     Simple Generics Example.
                                                            (line   9)
* {Stack.java}, definition:              Stack Class.       (line  22)
* {StackImproved.java}, definition:      Improved Stack Class.
                                                            (line  11)
* {TestStack.java}, definition:          Stack Class.       (line  42)
* {TwoTypeParameters.java}, definition:  Two Types Example Code.
                                                            (line   6)
* abstract class:                        Interfaces.        (line   6)
* abstract methods, interface:           Defining Interfaces.
                                                            (line  22)
* abstract methods, interface <1>:       Default Interface Methods.
                                                            (line   6)
* abstract over types:                   Generics.          (line   6)
* access control table:                  Member Access.     (line  27)
* access control, packages:              Member Access.     (line   6)
* access control, single class:          Access Control.    (line   6)
* access modifiers:                      Access Control.    (line   6)
* access, member:                        Member Access.     (line   6)
* accessibility:                         Packages Intro.    (line   6)
* API, Stream:                           Streams.           (line   5)
* argument passing:                      Argument Passing.  (line   6)
* arguments, command-line:               Command-Line Arguments.
                                                            (line   5)
* arguments, varargs:                    Varargs.           (line   5)
* Arrays:                                Arrays 2.          (line   6)
* arrays as objects:                     Arrays 2.          (line   6)
* auto-boxing, generics:                 Reference Types.   (line   6)
* auto-unboxing, generics:               Reference Types.   (line   6)
* autoboxing in generic reference:       GenDemo as Integer.
                                                            (line  46)
* AWT:                                   AWT.               (line   6)
* AWT Controls:                          AWT Controls.      (line   6)
* AWT Layout Managers, Menus:            AWT Controls.      (line   5)
* bounded types:                         Bounded Types.     (line   6)
* bounded wildcards:                     Bounded Wildcards. (line   6)
* bounded wildcards, lower bound:        Bounded Wildcards. (line  32)
* bounded wildcards, upper bound:        Bounded Wildcards. (line  18)
* bounded wildcards, upper bound <1>:    Bounded Wildcards. (line  20)
* casts, eliminated in generics:         Type Safety.       (line   6)
* casts, generics, automatic, implicit:  What are Generics. (line   6)
* Class:                                 Class Gen<T>.      (line 107)
* Class fundamentals:                    Class Fundamentals.
                                                            (line   6)
* class name, from getName():            Class Gen<T>.      (line 107)
* class namespace, compartmentalize:     Packages.          (line   6)
* Class object, from getClass():         Class Gen<T>.      (line 107)
* class String:                          The String Class.  (line   5)
* class, general form:                   General Form.      (line   6)
* class, new data type:                  Class Fundamentals.
                                                            (line   6)
* classed in java.lang:                  java Lang.         (line  14)
* Classes:                               Classes.           (line   6)
* classes, nested and inner:             Nested and Inner Classes.
                                                            (line   5)
* CLASSPATH -classpath:                  Classpath.         (line   6)
* Collections Framework:                 Generics.          (line   6)
* collections, generics:                 Generics.          (line   6)
* collisions, prevention:                Packages.          (line   6)
* command-line arguments:                Command-Line Arguments.
                                                            (line   6)
* compartmentalized:                     Packages.          (line   6)
* compile time:                          Interfaces.        (line  19)
* compile-time type check:               Motivation.        (line  31)
* Concurrency Utilities:                 Concurrency.       (line   5)
* constant, final variable:              final Keyword.     (line   6)
* Constants:                             Makefile Constants.
                                                            (line   6)
* constructor:                           Declaring Objects. (line   6)
* Constructors:                          Constructors.      (line   6)
* constructors, overloading:             Overloading Constructors.
                                                            (line   6)
* containers, packages as:               Packages.          (line   6)
* creating generic method:               Generic Methods.   (line   6)
* data type, enumeration:                Enumerations.      (line   6)
* default access level:                  Access Control.    (line  28)
* default method, interface, motivation: Default Interface Methods.
                                                            (line  15)
* default methods, interface:            Default Interface Methods.
                                                            (line   6)
* default package:                       Defining Packages. (line   6)
* difference between class and interface: Default Interface Methods.
                                                            (line  32)
* dispatch through an interface:         Interface References.
                                                            (line   6)
* dot operator:                          General Form.      (line  48)
* dynamic allocation, run time:          Declaring Objects. (line   6)
* dynamic dispatch, interface method look-ups: Interface References.
                                                            (line   6)
* dynamic method resolution:             Interfaces.        (line  19)
* encapsulation, access control:         Access Control.    (line   6)
* enum valueOf():                        Enum Methods.      (line   6)
* enum values():                         Enum Methods.      (line   6)
* enum variable, declare:                Enumeration Basics.
                                                            (line  25)
* enumeration capabilities:              Enumerations.      (line   6)
* enumeration comparison:                Enumeration Basics.
                                                            (line  38)
* enumeration constants:                 Enumeration Basics.
                                                            (line  15)
* enumeration constants <1>:             Enumerations as Class Types.
                                                            (line   6)
* enumeration constructor:               Enumerations as Class Types.
                                                            (line   6)
* enumeration instance variables:        Enumerations as Class Types.
                                                            (line   6)
* enumeration methods:                   Enum Methods.      (line   6)
* enumeration methods <1>:               Enumerations as Class Types.
                                                            (line   6)
* enumeration object:                    Enumerations.      (line   6)
* enumeration restrictions:              Enumerations as Class Types.
                                                            (line  41)
* enumeration variable:                  Enumeration Basics.
                                                            (line  25)
* Enumeration, basics:                   Enumeration Basics.
                                                            (line   6)
* Enumerations:                          Enumerations.      (line   6)
* enumerations as class types:           Enumerations as Class Types.
                                                            (line   6)
* enumerations inherit Enum:             Inherit Enum.      (line   6)
* enums, printing:                       Enumeration Basics.
                                                            (line  51)
* equality, enum types:                  Enumeration Basics.
                                                            (line  38)
* erasure:                               Class GenDemo.     (line   6)
* Event Handling:                        Event Handling.    (line   5)
* example generic method:                Example of Generic Method.
                                                            (line   6)
* example, generics:                     Simple Generics Example.
                                                            (line   6)
* exposure of code:                      Packages Intro.    (line   6)
* extending interfaces:                  Extending Interfaces.
                                                            (line   6)
* extends clause:                        Bounded Types.     (line   6)
* extents, with interfaces:              Extending Interfaces.
                                                            (line   6)
* final Keyword:                         final Keyword.     (line   6)
* final, traditional enums:              Enumerations.      (line   6)
* finding packages:                      Classpath.         (line   6)
* fully qualified name:                  Importing.         (line  39)
* generic class:                         Simple Generics Example.
                                                            (line   6)
* generic class <1>:                     Class Gen<T>.      (line   6)
* generic class, general form:           Generic Class General Form.
                                                            (line   6)
* generic class, method:                 What are Generics. (line   6)
* generic class, two type parameters:    Two Type Parameters.
                                                            (line   6)
* generic code, demonstrating an implementation: Class GenDemo.
                                                            (line   6)
* generic constructors:                  Generic Constructors.
                                                            (line   6)
* generic interface:                     Motivation.        (line  31)
* generic method, creating:              Generic Methods.   (line   6)
* generic method, example:               Example of Generic Method.
                                                            (line   6)
* generic method, static:                Method isIn.       (line  28)
* generic methods, including type arguments: Method isIn.   (line  34)
* generic reference assignment to Integer: GenDemo as Integer.
                                                            (line  46)
* generic reference to Integer:          GenDemo as Integer.
                                                            (line  28)
* generic reference, creating:           GenDemo as Integer.
                                                            (line   6)
* generic type argument, reference type: Reference Types.   (line   6)
* generic type checking:                 GenDemo as Integer.
                                                            (line  46)
* generic types differ, type arguments:  Type Arguments.    (line   6)
* Generics (chapter):                    Generics.          (line   6)
* generics eliminate casts:              Type Safety.       (line   6)
* generics ensure type safety:           Type Safety.       (line   6)
* generics example:                      Simple Generics Example.
                                                            (line   6)
* generics improve type safety:          Type Safety.       (line   6)
* generics, bounded types:               Bounded Types.     (line   6)
* generics, casts:                       What are Generics. (line   6)
* generics, compile-time error, mismatched types: GenDemo as Integer.
                                                            (line  46)
* generics, generic constructors:        Generic Constructors.
                                                            (line   6)
* generics, interface as bound:          Bounded Types.     (line  22)
* generics, introduction:                Generics.          (line   6)
* generics, motivation:                  Motivation.        (line   6)
* generics, motivation, readability and robustness: Motivation.
                                                            (line  31)
* generics, only reference types:        Reference Types.   (line   6)
* generics, subtyping:                   Subtyping.         (line   6)
* generics, two type arguments:          Class TwoGen.      (line  29)
* generics, two type parameters, declaration: Class TwoGen. (line  29)
* generics, type safety benefit:         GenDemo as Integer.
                                                            (line  46)
* generics, what they are:               What are Generics. (line   6)
* generics, wildcard arguments:          Wildcard Arguments.
                                                            (line   6)
* getClass(), defined in Object:         Class Gen<T>.      (line 107)
* getName(), defined in Class:           Class Gen<T>.      (line 107)
* global members:                        static Keyword.    (line  55)
* Graphics:                              AWT.               (line   6)
* hiding, instance variables:            Instance Variable Hiding.
                                                            (line   6)
* hierarchical structure, packages:      Packages.          (line   6)
* hierarchy of packages:                 Defining Packages. (line  41)
* Images:                                Images.            (line   5)
* implements clause:                     Implementing Interfaces.
                                                            (line   6)
* import is optional:                    Importing.         (line  39)
* import packages:                       Packages.          (line   6)
* import statement, general form and example: Importing.    (line  14)
* imported packages must be public:      Importing.         (line  43)
* importing packages:                    Importing.         (line   6)
* index interface, default methods:      Default Interface Methods.
                                                            (line   6)
* Inheritance:                           Inheritance.       (line   6)
* inheriting interfaces:                 Extending Interfaces.
                                                            (line   6)
* inner classes:                         Nested and Inner Classes.
                                                            (line   6)
* instance variables:                    General Form.      (line  32)
* instance, class:                       Class Fundamentals.
                                                            (line   6)
* intefaces, applying:                   Applying Interfaces.
                                                            (line   6)
* interface as bound, generics:          Bounded Types.     (line  22)
* interface default access, no modified: Defining Interfaces.
                                                            (line  22)
* interface definition, simplified general form: Defining Interfaces.
                                                            (line   7)
* interface method defintion, declared public: Implementing Interfaces.
                                                            (line  18)
* interface methods, abstract methods:   Defining Interfaces.
                                                            (line  22)
* interface methods, private:            Private Interface Methods.
                                                            (line   6)
* interface public access:               Defining Interfaces.
                                                            (line  22)
* interface references, accessing implementations: Interface References.
                                                            (line   6)
* interface variable declarations:       Defining Interfaces.
                                                            (line  35)
* interface, implement:                  Interfaces.        (line   6)
* interface, partial implementation:     Partial Implementations.
                                                            (line   6)
* interface, static method:              Interface Static Methods.
                                                            (line   6)
* interface, traditional form:           Default Interface Methods.
                                                            (line   6)
* Interfaces (chapter):                  Interfaces.        (line   6)
* interfaces in java.lang:               java Lang.         (line  62)
* interfaces, defining:                  Defining Interfaces.
                                                            (line   6)
* interfaces, extending:                 Extending Interfaces.
                                                            (line   6)
* interfaces, final variables in:        Variables in Interfaces.
                                                            (line   6)
* interfaces, implementing:              Implementing Interfaces.
                                                            (line   6)
* interfaces, inheriting:                Extending Interfaces.
                                                            (line   6)
* interfaces, introduction:              Interfaces.        (line   6)
* interfaces, key aspect, no state:      Default Interface Methods.
                                                            (line  32)
* interfaces, key feature, reference look-ups: Interface References.
                                                            (line   6)
* interfaces, nested:                    Nested Interfaces. (line   6)
* interfaces, shared constants:          Variables in Interfaces.
                                                            (line   6)
* introduction to Java SE 9:             Java SE 9 Introduction.
                                                            (line   5)
* Introduction to Packages (section):    Packages Intro.    (line   6)
* iteration, iterative:                  Recursion.         (line   6)
* J2SE 5.0:                              Generics.          (line   6)
* Java SE 9 introduction:                Java SE 9 Introduction.
                                                            (line   6)
* java.io:                               java io Input Output.
                                                            (line   5)
* java.lang:                             Importing.         (line  29)
* java.lang <1>:                         java Lang.         (line   6)
* java.util Collections Framework:       java util Collections.
                                                            (line   5)
* java.util Utility Classes:             java util Utility Classes.
                                                            (line   5)
* JDK 5:                                 Enumerations.      (line   6)
* JDK 8, default method in interface:    Default Interface Methods.
                                                            (line   6)
* JDK 8, static interface method:        Interface Static Methods.
                                                            (line   6)
* JDK 9, package part of module:         Classpath.         (line   6)
* JDK 9, private interface method:       Private Interface Methods.
                                                            (line   6)
* keyword final:                         final Keyword.     (line   6)
* keyword interface:                     Interfaces.        (line   6)
* keyword static:                        static Keyword.    (line   6)
* keyword, enum:                         Enumeration Basics.
                                                            (line   6)
* length instance variable:              Arrays 2.          (line   6)
* lower bounded wildcard:                Bounded Wildcards. (line  32)
* main() method, class:                  General Form.      (line  45)
* Makefiel Weave:                        Makefile Tangle Weave.
                                                            (line   6)
* Makefile Clean targets:                Makefile Clean.    (line   6)
* Makefile defaults:                     Makefile Defaults. (line   6)
* Makefile Tangle:                       Makefile Tangle Weave.
                                                            (line   6)
* Makefile, The (appendix):              The Makefile.      (line   6)
* member access:                         Member Access.     (line   6)
* member interfaces:                     Nested Interfaces. (line   6)
* members:                               General Form.      (line  32)
* method signatures compatible:          Interfaces.        (line  19)
* method, static, interface:             Interface Static Methods.
                                                            (line   6)
* methods:                               General Form.      (line  32)
* Methods:                               Methods.           (line   6)
* Methods and Classes:                   Methods and Classes.
                                                            (line   6)
* methods, enumeration:                  Enum Methods.      (line   6)
* methods, overloading:                  Overloading Methods.
                                                            (line   6)
* module path:                           Classpath.         (line   6)
* modules, packages:                     Classpath.         (line   6)
* name, method:                          Methods.           (line  15)
* naming mechanism:                      Packages Intro.    (line   6)
* nested classes:                        Nested and Inner Classes.
                                                            (line   6)
* nested interfaces:                     Nested Interfaces. (line   6)
* Networking:                            Networking.        (line   5)
* new operator:                          Declaring Objects. (line   6)
* NIO:                                   NIO.               (line   5)
* Object:                                Class Gen<T>.      (line 107)
* object references, interfaces:         Interface References.
                                                            (line   6)
* Object type:                           What are Generics. (line   6)
* object, class:                         Class Fundamentals.
                                                            (line   6)
* objects as parameters:                 Objects as Parameters.
                                                            (line   6)
* objects, declaring:                    Declaring Objects. (line   6)
* objects, dynamical allocation:         Returning Objects. (line   6)
* objects, references to:                Returning Objects. (line   6)
* objects, returning from methods:       Returning Objects. (line   6)
* _one interface, multiple methods_:     Overloading Methods.
                                                            (line   6)
* overload, overloaded:                  Overloading Methods.
                                                            (line   6)
* overloading constructors:              Overloading Constructors.
                                                            (line   6)
* overloading methods:                   Overloading Methods.
                                                            (line   6)
* overloading, automatic type conversion: Overloading Methods.
                                                            (line   6)
* package command:                       Defining Packages. (line   6)
* package namespace:                     Defining Packages. (line   6)
* package renaming:                      Defining Packages. (line  56)
* package statement:                     Defining Packages. (line   6)
* package statement, example:            Defining Packages. (line  20)
* package statement, general form:       Defining Packages. (line  16)
* package statement, multilevel form:    Defining Packages. (line  43)
* Packages (chapter):                    Packages.          (line   6)
* packages hierarchy:                    Defining Packages. (line  41)
* packages stored in file system:        Defining Packages. (line  27)
* packages, access control:              Member Access.     (line   6)
* Packages, Defining (section):          Defining Packages. (line   6)
* packages, finding, example:            Classpath.         (line  26)
* packages, how stored:                  Packages.          (line   6)
* packages, import:                      Packages.          (line   6)
* packages, importing:                   Importing.         (line   6)
* packages, purposes, prevent collisions: Packages.         (line   6)
* parameter list, method:                Methods.           (line  15)
* parameter, generic class:              Class Gen<T>.      (line   6)
* parameterized type:                    Class Gen<T>.      (line   6)
* parameterized types:                   What are Generics. (line   6)
* parameters, as objects:                Objects as Parameters.
                                                            (line   6)
* partitioning mechanism:                Packages Intro.    (line   6)
* polymorphism, one interface multiple methods: Interfaces. (line   6)
* polymorphism, overloading of methods:  Overloading Methods.
                                                            (line   6)
* preexisting code, default method, interface: Default Interface Methods.
                                                            (line  15)
* Primitive Wrappers:                    Primitive Wrappers.
                                                            (line   6)
* private access modifier:               Access Control.    (line  28)
* protected access modifier:             Access Control.    (line  28)
* public access modifier:                Access Control.    (line  28)
* recursion, recursive:                  Recursion.         (line   6)
* Regular Expressions:                   Regular Expressions.
                                                            (line   5)
* run time, dynamic allocation:          Declaring Objects. (line   6)
* run-time:                              Interfaces.        (line  19)
* run-time system, finding packages:     Classpath.         (line   6)
* self-typed constants:                  Enumeration Basics.
                                                            (line  15)
* Stack Class:                           Stack Class.       (line   6)
* Stack class, improved:                 Improved Stack Class.
                                                            (line   6)
* stack exhaustion, recursion:           Recursion.         (line   6)
* stack overun, recursion:               Recursion.         (line   6)
* standard Java classes, imported implicitly: Importing.    (line  29)
* static environment:                    Interfaces.        (line  19)
* static generic method:                 Method isIn.       (line  28)
* static initialization block:           static Keyword.    (line  34)
* static Keyword:                        static Keyword.    (line   6)
* static members:                        static Keyword.    (line   6)
* static method, interface:              Interface Static Methods.
                                                            (line   6)
* static restrictions on methods:        static Keyword.    (line  24)
* Stream API:                            Streams.           (line   6)
* String Class:                          The String Class.  (line   6)
* String Handling:                       Strings.           (line   5)
* Strings:                               Strings.           (line   6)
* subclass:                              Inheritance.       (line   6)
* superclass:                            Inheritance.       (line   6)
* Swing:                                 Swing.             (line   5)
* switch statement, enum types:          Enumeration Basics.
                                                            (line  38)
* template, class:                       Class Fundamentals.
                                                            (line   6)
* Text:                                  AWT.               (line   5)
* this Keyword:                          this Keyword.      (line   6)
* type abstraction, generics:            Generics.          (line   6)
* type argument, passed to type parameter: GenDemo as Integer.
                                                            (line   6)
* type correctness:                      Motivation.        (line  31)
* type erasure:                          Class GenDemo.     (line   6)
* type parameter:                        Motivation.        (line  31)
* type parameter, generic class:         Class Gen<T>.      (line   6)
* type safety, generics:                 What are Generics. (line   6)
* type wrappers:                         Primitive Wrappers.
                                                            (line   6)
* type wrappers, generics:               Reference Types.   (line   6)
* type, method:                          Methods.           (line  15)
* upper bound:                           Bounded Types.     (line   6)
* upper bound wildcard argument:         Bounded Wildcards. (line  20)
* upper bounded wildcard:                Bounded Wildcards. (line  18)
* varargs:                               Varargs.           (line   6)
* variable, enum type:                   Enumeration Basics.
                                                            (line  25)
* variable-length arguments:             Varargs.           (line   6)
* visibility mechanism:                  Packages Intro.    (line   6)
* wildcard arguments, generics:          Wildcard Arguments.
                                                            (line   6)
* wildcard syntax:                       Wildcard Syntax.   (line   6)
* wildcards, bounded:                    Bounded Wildcards. (line   6)
* wildcards, motivation:                 Wildcard Motivation.
                                                            (line   6)
* Windows:                               AWT.               (line   6)
* Wrappers, Primitives:                  Primitive Wrappers.
                                                            (line   6)


File: JavaSE9.info,  Node: Function Index,  Prev: Concept Index,  Up: Top

Function Index
**************

 [index ]
* Menu:

* == on Enum:                            Inherit Enum.       (line 37)
* compareTo on Enum:                     Inherit Enum.       (line 21)
* equals on Enum:                        Inherit Enum.       (line 34)
* ordinal on Enum:                       Inherit Enum.       (line 13)
* valueOf on Enum:                       Enum Methods.       (line 14)
* values on Enum:                        Enum Methods.       (line  8)



Tag Table:
Node: Top75
Node: Java SE 9 Introduction3449
Node: Classes3591
Node: Class Fundamentals4035
Node: General Form4451
Ref: ClassDeclaration4791
Node: Declaring Objects6306
Node: Methods7700
Ref: MethodDeclaration7899
Node: Constructors8742
Node: this Keyword9506
Node: Instance Variable Hiding10059
Node: Stack Class10863
Ref: Stack-java11687
Ref: TestStack-java12242
Node: Stack Instance Variables12543
Ref: Stack-Instance-Variables12710
Node: Stack Constructor Node12876
Ref: Stack-Constructor13087
Node: Stack Instance Methods Node13466
Ref: Stack-Instance-Methods13683
Node: Stack Push and Pop Node14345
Ref: Stack-Push14516
Ref: Stack-Pop14824
Node: Stack TestStack Node15153
Ref: TestStack-Main-Method15325
Node: Methods and Classes16053
Node: Overloading Methods16763
Node: Overloading Constructors19073
Node: Objects as Parameters19261
Node: Argument Passing19937
Node: Returning Objects21279
Node: Recursion21906
Node: Access Control23418
Node: Improved Stack Class26363
Ref: StackImproved-java26597
Ref: Stack-Private-Instance-Variables27235
Ref: Improved Stack Class-Footnote-128259
Node: static Keyword28378
Node: final Keyword30817
Node: Arrays 231720
Node: Nested and Inner Classes32417
Node: The String Class32601
Node: Command-Line Arguments32787
Node: Varargs32976
Node: Inheritance33152
Node: Packages33886
Node: Packages Intro34344
Node: Defining Packages34888
Ref: PackageStatement35490
Ref: PackageStatementMulti36460
Node: Classpath36883
Node: Member Access38423
Ref: PackageAccess39398
Node: Importing39999
Ref: Import40623
Node: Interfaces41898
Node: Defining Interfaces44006
Ref: InterfaceSimple44261
Node: Implementing Interfaces45591
Ref: ClassImplementsInterface46085
Node: Interface References46570
Node: Partial Implementations47561
Node: Nested Interfaces47995
Node: Applying Interfaces48769
Node: Variables in Interfaces48969
Node: Extending Interfaces49699
Node: Default Interface Methods50178
Node: Interface Static Methods52282
Ref: InterfaceStaticMethod53014
Node: Private Interface Methods53296
Node: Generics54052
Node: Motivation55892
Node: What are Generics57868
Node: Simple Generics Example58935
Ref: SimpleGenerics-java59250
Node: Class Gen<T>59645
Ref: Class-Gen60640
Ref: Instance-Variable-ob-of-Type-T61752
Ref: generics-constructor61952
Ref: Constructor-taking-parameter-of-Type-T62298
Ref: Method-returning-object-of-type-T62834
Ref: Method-showing-type-of-T63459
Node: Class GenDemo63698
Ref: Class-GenDemo64477
Node: GenDemo as Integer65234
Ref: Create-a-Gen-object-for-Integers65446
Ref: Integer-Type-Parameter66576
Ref: Reference-to-Integer-Instance67423
Ref: Show-Type67966
Ref: Get-Value68458
Node: GenDemo as String68699
Ref: Create-a-Gen-object-for-Strings68909
Node: Notes about Generics69364
Node: Reference Types69620
Node: Type Arguments70146
Node: Subtyping70709
Node: Type Safety71843
Node: Two Type Parameters72202
Node: Two Types Example Code72750
Ref: TwoTypeParameters-java72924
Node: Class TwoGen73328
Ref: Class-TwoGen73465
Ref: Class-Declaration74495
Ref: Two-Instance-Variables-Declarations74701
Ref: Constructor-of-Two-Parameters74884
Ref: Instance-Methods-Show-and-Get75140
Node: Class SimpGen75531
Ref: Class-SimpGen75794
Node: Generic Class General Form76363
Ref: GenericClass76670
Node: Bounded Types76994
Node: Wildcard Arguments78392
Node: Wildcard Motivation78637
Node: Wildcard Syntax81184
Node: Bounded Wildcards82102
Ref: UpperBoundedWildcard82923
Ref: LowerBoundedWildcard83303
Node: Generic Methods83468
Ref: GenericMethod83868
Node: Example of Generic Method84036
Ref: GenMethDemo-java84537
Node: Method isIn84991
Ref: Static-Method-isIn85211
Node: GenMethDemo Main86582
Ref: GenMethDemo-Main86732
Node: Generic Constructors87627
Node: Enumerations87994
Node: Enumeration Basics88868
Node: Enum Methods90463
Node: Enumerations as Class Types91690
Node: Inherit Enum93564
Node: Strings95400
Node: java Lang95524
Node: Primitive Wrappers97169
Node: Number97958
Node: Double and Float98074
Node: isInfiinite() and isNaN()98244
Node: Byte Short Integer Long98447
Node: Numbers to from String98660
Node: java util Collections98861
Node: java util Utility Classes99080
Node: java io Input Output99290
Node: NIO99456
Node: Networking99563
Node: Event Handling99678
Node: AWT99801
Node: AWT Controls99988
Node: Images100169
Node: Concurrency100278
Node: Streams100420
Node: Regular Expressions100553
Node: Swing100728
Node: The Makefile100868
Ref: Makefile101013
Node: Makefile Constants101644
Ref: Makefile-CONSTANTS101785
Node: Makefile Defaults101921
Ref: Makefile-DEFAULTS102104
Node: Makefile Tangle Weave102254
Ref: Makefile-TANGLE-WEAVE102443
Node: Makefile Clean102835
Ref: Makefile-CLEAN102984
Node: Code Chunk Summaries103171
Node: File Definitions103661
Node: Code Chunk Definitions104353
Node: Code Chunk References107208
Node: List of Tables111925
Node: List of General Forms112142
Node: Bibliography113145
Node: Concept Index113277
Node: Function Index151694

End Tag Table
