This is JavaSE9.info, produced by makeinfo version 6.5 from
JavaSE9.texi.


File: JavaSE9.info,  Node: Top,  Next: Java SE 9 Introduction,  Up: (dir)

General Introduction
********************

This file documents Outline Covering Java SE 9.

* Menu:

* Java SE 9 Introduction::
* Classes::
* Methods and Classes::
* Inheritance::
* Packages::
* Interfaces::
* I/O::
* Miscellaneous Java Keywords::
* Generics::
* Enumerations::
* Strings::
* Exploring java-lang::
* java util Collections::
* java util Utility Classes::
* Input/Output java.io::
* NIO::
* Networking::
* Event Handling::
* AWT::
* AWT Controls::
* Images::
* Concurrency::
* Streams API::
* Regular Expressions::
* Reflection::
* Swing::
* The Makefile::
* Code Chunk Summaries::
* List of Tables::
* List of General Forms::
* Bibliography::
* Concept Index::
* Function Index::

 -- The Detailed Node Listing --

Classes

* Class Fundamentals::
* Declaring Objects::
* Methods::
* Constructors::
* this Keyword::
* Stack Class::

Class Fundamentals

* General Form::

The 'this' Keyword

* Instance Variable Hiding::

TestStack.java

* Stack Instance Variables::
* Stack Constructor Node::
* Stack Instance Methods Node::
* Stack TestStack Node::

Stack Instance Methods Subsection

* Stack Push and Pop Node::

Methods and Classes

* Overloading Methods::
* Objects as Parameters::
* Argument Passing::
* Returning Objects::
* Recursion::
* Access Control::
* static Keyword::
* final Keyword::
* Arrays 2::
* Nested and Inner Classes::
* String Class::
* Command-Line Arguments::
* Varargs::

Overloading Methods

* Overloading Constructors::

Access Control and Inheritance

* Improved Stack Class::

Inheritance

* Inheritance Basics::
* Using super::
* Multilevel Hierarchy::
* Constructors Executed::
* Method Overriding::
* Dynamic Method Dispatch::
* Using Abstract Classes::
* final with Inheritance::
* Object Class::

General Form of a Subclass Inheriting a Superclass

* Member Access and Inheritance::
* Superclass Referencing Subclass::

Using 'super'

* super Calling Superclass Constructor::
* super Referencing Superclass::

Dynamic Method Dispatch

* Why Overridden Methods::
* Applying Method Overriding::

Output

* FindAreas SuperClass Figure Node::
* FindAreas SubClass Rectangle Node::
* FindAreas SubClass Triangle Node::
* FindAreas Main Class Node::

Abstract Classes Can Be Reference Variables

* Improved Figure Class::

Improved Figure Class

* AbstractAreas Abstract Class Figure Node::
* AbstractAreas Main Class::

Using 'final' with Inheritance

* final to Prevent Overriding::
* final to Prevent Inheritance::

Packages

* Packages Intro::
* Defining Packages::
* Classpath::
* Member Access::
* Importing::

Interfaces

* Defining Interfaces::
* Implementing Interfaces::
* Interface References::
* Partial Implementations::
* Nested Interfaces::
* Applying Interfaces::
* Variables in Interfaces::
* Extending Interfaces::
* Default Interface Methods::
* Interface Static Methods::
* Private Interface Methods::

I/O

* I/O Basics::
* Reading Console Input::
* Writing Console Output::
* PrintWriter Class::
* Reading and Writing Files::
* Automatically Closing Files::

I/O Basics

* Streams::
* Byte Streams Character Streams::

Byte Streams and Character Streams

* Byte Stream Class::
* Character Stream Class::
* Predefined Streams::

'System.in' Wrapped in 'BufferedReader'

* Reading Characters::
* Reading Strings::

Program Demonstrating Reading Characters from Console

* Import java.io::
* BRRead BufferedReader Constructor Node::
* BRRead Enter Characters Node::

Program Demonstrating Reading a String from Console

* BRReadLines BufferedReader Constructor::
* BRReadLines Enter Lines::

The PrintWriter Class

* PrinterWriter Constructors::
* Demonstration Using PrintWriter::
* PrintWriter Concluding Comments::

Demonstration Using a 'PrintWriter' for Console Output

* PrintWriterDemo PrintWriter Constructor::
* PrintWriterDemo Printing To Console::

Reading and Writing Files

* FileInputStream and FileOutputStream::
* Demonstration Reading From a File::
* Demonstration Reading From File with Single try::
* Demonstration Writing to a File::

Demonstration Reading From a File

* ShowFile Initial Comments::
* ShowFile Instance Variable Declarations::
* ShowFile Open a File::
* ShowFile Read a File::
* ShowFile Close a File::
* close() Within finally::

Demonstration Reading From a File with a Single 'try' Block

* ShowFileSingleTry Additional Initial Comment::
* ShowFileSingleTry Read a File::

Demonstration Writing to a File

* CopyFile Initial Comments::
* CopyFile Instance Variable Declarations::
* CopyFile Check for 2 Files::
* CopyFile Copy a File::

Multiple Resources

* Demonstration of Automatically Closing a File::
* Demonstration of Multiple Resources::

Demonstration of Automatically Closing a File

* ShowFileTryWR Initial Comments::
* ShowFileTryWR Instance Variable Declarations::
* ShowFileTryWR Check CL Args::
* ShowFileTryWR Open a File TryWR::

Demonstration of Multiple Resources

* CopyFileMultTryWR Initial Comments::
* CopyFileMultTryWR Manage Two Files::

Miscellaneous Java Keywords

* transient and volatile Modifiers::
* Using instanceof::
* strictfp::
* Native Methods::
* Using assert::
* Static Import::
* Overloaded Constructors with this::
* Compact API Profiles::

Generics

* Motivation::
* What are Generics::
* Simple Generics Example::
* Notes about Generics::
* Two Type Parameters::
* Generic Class General Form::
* Bounded Types::
* Wildcard Arguments::
* Generic Methods::
* Generic Constructors::

A Simple Generics Example

* Class Gen<T>::
* Class GenDemo::

Class GenDemo

* GenDemo as Integer::
* GenDemo as String::

Notes About Generics

* Reference Types::
* Type Arguments::
* Subtyping::
* Type Safety::

A Generic Class with Two Type Parameters

* Two Types Example Code::

Example of Code with Two Type Parameters

* Class TwoGen::
* Class SimpGen::

Using Wildcard Arguments

* Wildcard Motivation::
* Wildcard Syntax::
* Bounded Wildcards::

Generalized Form

* Example of Generic Method::

Example of Generic Method

* Method isIn::
* GenMethDemo Main::

Enumerations

* Enumeration Basics::
* Enum Methods::
* Enumerations as Class Types::
* Inherit Enum::

'java.lang' includes the following interfaces

* Primitive Wrappers::
* Iterable Interface::

Primitive Type Wrappers

* Number::
* Double and Float::
* isInfinite() and isNaN()::
* Byte Short Integer Long::
* Numbers to from String::

Collections Framework

* Collections Overview::
* Collection Interfaces::
* Collection Classes::
* Accessing a Collection via Iterator::
* Spliterators::
* Storing User-Defined Classes::
* RandomAccess Interface::
* Working with Maps::
* Comparators::
* Collection Algorithms::
* Arrays Class::
* Legacy Classes and Interfaces::

Optional Interface Methods -- Modifiable Collections

* Collection Interface::
* List Interface::
* Set Interface::
* SortedSed Interface::
* NavigableSet Interface::
* Queue Interface::
* Dequeue Interface::

Input/Output -- 'java.io'

* I/O Classes and Interfaces::
* File::
* AutoCloseable Closeable Flushable Interfaces::
* I/O Exceptions::
* Closing a Stream::
* Stream Classes::
* Byte Streams::
* Character Streams::
* Console Class::
* Serialization::
* Stream Benefits::

I/O Classes and Interfaces

* I/O Classes::
* I/O Interfaces::

Examples Creating Files and Directories

* File Methods::
* File Utility Methods::
* Directories::
* Examine Directory Contents::
* FilenameFilter::
* Example Using FilenameFilter Interface::
* listFiles() Alternative::
* Creating Directories::

Using 'list()' to Examine Directory Contents

* Import java.io.File::
* DirList Instance Variable Declarations::
* DirList Examine Directory Contents::
* Examine Directory Contents For-Loop::
* DirList Obtain Directory From Command-Line Args::

DirListOnly Class

* DirListOnly FilenameFilter Object::
* DirListOnly FilenameFilter Object List::
* DirListOnly Print List::
* OnlyExt Instance Variable Declarations::
* OnlyExt Constructor::
* OnlyExt Accept Method Implementation::

The Byte Streams

* InputStream::
* OutputStream::
* FileInputStream::
* FileOutputStream::
* ByteArrayInputStream::
* ByteArrayOutputStream::
* Filtered Byte Streams::
* Buffered Byte Streams::
* SequenceInputStream::
* PrintStream::
* DataOutputStream DataInputStream::
* RandomAccessFile::

'InputStream'

* InputStream Methods::

'OutputStream'

* OutputStream Methods::

Buffered Byte Streams

* BufferedInputStream::
* Buffered Input Example::
* BufferedInputStreamDemo Instance Variables::
* BufferedInputStreamDemo TryWithResources BufferedInputStream::
* BufferedInputStreamDemo While Loop::
* BufferedInputStreamDemo Switch on Character::
* BufferedInputStreamDemo String Into Buffer::
* BufferedInputStreamDemo Buffer::
* BufferedInputStreamDemo ByteArrayInputStream::
* BufferedInputStreamDemo Utility Variables::
* BufferedOutputStream::
* PushbackInputStream::

The Character Streams

* Reader::
* Writer::
* FileReader::
* FileWriter::
* CharArrayReader::
* CharArrayWriter::
* BufferedReader::
* Buffered Reader Demo::
* BufferedWriter::
* PushbackReader::
* PrintWriter::

Example Reading Lines From a File

* FileReaderDemo TryWithResources FileReader::
* Catch IOException::

Buffered Reader Demo

* BufferedReaderDemo Instance Variables::
* BufferedReaderDemo Buffer::
* BufferedReaderDemo TryWithResources BufferedReader::

Serialization

* Serializable::
* Externalizable::
* ObjectOutput::
* ObjectOutputStream::
* ObjectInput::
* ObjectInputStream::
* Serializable Example::

Drawbacks of Reflection

* java.lang.reflect Package::
* Classes and Reflection::
* Members and Reflection::
* Arays and Enumerated Types and Reflection::

'java.lang.reflect' Package

* Classes Defined in java-lang-reflect::
* Interfaces Defined in java-lang-reflect::
* Reflection Demonstration::

ReflectionDemo1.java

* ReflectionDemo1 Class forName Call::
* ReflectionDemo1 getConstructors Call::
* ReflectionDem1 getFields Call::
* ReflectionDemo1 getMethods Call::
* Catch Exception::
* Import java.lang.reflect::

Classes and Reflection

* java.lang.Class::
* Retrieving Class Objects::
* Examining Class Modifiers::
* Discovering Class Members::

'java.lang.Class'

* Class Constructor::

Retrieving Class Objects

* Object.getClass::
* .class Syntax::
* Class.forName() and Class.getName() Methods::
* TYPE Field for Primitive Wrappers::
* Methods that Return Classes::

Note about Members and the Specification

* reflect Fields::
* reflect Methods::
* reflect Constructors::

'reflect.Constructors'

* Finding Constructors::
* Constructor Modifiers::
* Creating New Class Instances::

Arrays and Enumerate Types and Reflection

* Arrays and Reflection::
* Enumerate Types and Reflection::

Arrays and Reflection

* Identifying Array Types::
* Creating New Arrays::
* Getting and Setting Arrays::

Enumerated Types and Reflection

* Enumerated Types Reflection::

The Makefile

* Makefile Constants::
* Makefile Defaults::
* Make the Makefile::
* Makefile Tangle Weave::
* Makefile PDF::
* Makefile HTML::
* Makefile Clean Targets::

Makefile PDF

* Makefile MAKEPDF::

Makefile MAKEPDF

* Makefile OPENPDF::

Makefile Clean Targets

* Makefile Clean ::
* Makefile DistClean::
* Makefile WorldClean::

Code Chunk Summaries

* File Definitions::            Source files by definition.
* Code Chunk Definitions::      Code chunks by definition.
* Code Chunk References::       Code chunks by reference.



File: JavaSE9.info,  Node: Java SE 9 Introduction,  Next: Classes,  Prev: Top,  Up: Top

1 Java SE 9 Introduction
************************


File: JavaSE9.info,  Node: Classes,  Next: Methods and Classes,  Prev: Java SE 9 Introduction,  Up: Top

2 Classes
*********

The class is the logical construct upon which the Java language is
built because it defines the shape and nature of an object, and
therefore forms the basis for object-oriented programming in Java.

* Menu:

* Class Fundamentals::
* Declaring Objects::
* Methods::
* Constructors::
* this Keyword::
* Stack Class::


File: JavaSE9.info,  Node: Class Fundamentals,  Next: Declaring Objects,  Up: Classes

2.1 Class Fundamentals
======================

A "class" defines a new data type.  Once defined, this new type can be
used to create objects of that type.  A class is therefore a template
for an object, and an "object" is an instance of a class.  Object and
instance are often used interchangeably.

* Menu:

* General Form::


File: JavaSE9.info,  Node: General Form,  Up: Class Fundamentals

2.1.1 General Form of a Class
-----------------------------

When you define a class, you declare its exact form and nature.  You
do this by specifying the data that it contains and the code that
operates on that data.  A class is declared by use of the 'class'
keyword.

     class classname {
       type instance-variable1;
       type instance-variable2;
       ...
       type instance-variableN;

       type method-name1 (parameter-list {
         body of method
       }

       type method-name2 (parameter-list {
         body of method
       }
       ...
       type method-nameN (parameter-list {
         body of method
       }
     }

GeneralForm 2.1: Class Declaration -- General Form

   The data, or variables, defined within a class are called "instance
variables".  The code is contained within "methods".  Collectively,
the methods and variables defined within a class are called "members"
of the class.  In most cases, the instance variables are acted upon
and accessed by the methods defined for that class.  As a general
rule, it is the methods that determine how a class' data can be used.

   Each instance of the class (that is, each object of the class)
contains its own copy of the instance variables.  The data for one
object is separate and unique from the data for another.  Changes to
the instance variables of one object have no effect on the instance
variables of another.

   Java classes do not need to have a 'main()' method; you only need
to specify one if that class is the starting point for the program.

   In general, you use the "dot operator" to access both the instance
variables and the methods within an object.  Although commonly
referred to as the dot _operator_, the formal specification for Java
categorizes the . as a _separator_.


File: JavaSE9.info,  Node: Declaring Objects,  Next: Methods,  Prev: Class Fundamentals,  Up: Classes

2.2 Declaring Objects
=====================

Because a class creates a new data type, you can use this type to
declare objects of that type.  Obtaining objects of a class is a
two-step process.

  1. Declare a variable of the class type; this variable does not
     define an object.  Instead, it is simply a variable that can
     _refer_ to an object.
  2. Acquire an actual, physical copy of the object and assign it to
     the variable; you can do this using the 'new' operator.  The
     'new' operator dynamically allocates (at run time) memory for an
     object, and returns a reference to to.  This reference is
     (essentially) the address in memory of the object allocated by
     'new'.  This reference is then stored in the variable.  In Java,
     all class objects must be dynamically allocated.

Example Declaration, Allocation, and Assignment
===============================================

     Box mybox; // 1. declare a variable
     mybox = new Box(); // 2. allocate a Box object

   These two declarations can be combined into a single declaration,
and usually are:

     Box mybox = new Box();

   The 'mybox' variable simply holds the memory address of the actual
'Box' object.  The class name followed by parenthese specifies the
"constructor" for the class.


File: JavaSE9.info,  Node: Methods,  Next: Constructors,  Prev: Declaring Objects,  Up: Classes

2.3 Methods
===========

General Form of a Method Declaration
====================================

     type name (parameter-list) {
       body of method
     }

GeneralForm 2.2: Method Declaration -- General Form

type specifies the type of data returned by the method.  This can be
any valid type, including class types that you create.  If the method
does not return a value, its return type must be 'void'.

   "name" is the name of the method.  This can be any legal
identifier.

   "parameter-list" is a sequence of type and identifier pairs
separated by commas.  "Parameters" are essentially variables that
receive the value of the arguments passed to the method when it is
called.  If the method has no parameters, then the parameter list will
be empty.

   Methods that have a return type other than 'void' return a value to
the calling routine using a "return statement":

     return value

   where value is the value returned.


File: JavaSE9.info,  Node: Constructors,  Next: this Keyword,  Prev: Methods,  Up: Classes

2.4 Constructors
================

Java allows objects to initialize themselves when they are created.
This automatic initialization is performed through the use of a
constructor.

   A "constructor" initializes an object immediately upon creation.
It has the same name as the class in which it resides and is
syntactically similar to a method.  Once defined, the constructor is
automatically called when the object is created, before the 'new'
operator completes.  Constructors have no return type.  It is the
constructor's job to initialize the internal state of an object so
that the code creating an instance will have fully initialized, usable
object immediately.


File: JavaSE9.info,  Node: this Keyword,  Next: Stack Class,  Prev: Constructors,  Up: Classes

2.5 The 'this' Keyword
======================

Sometimes a method will need to refer to the object that invoked it.
To allow this, Java defines the 'this' keyword.  'this' can be used
inside any method to refer to the _current_ object.  That is, 'this'
is always a refernce to the object on which the method was invoked.
You can use 'this' anywhere a reference to an object of the current
class' type is permitted.

* Menu:

* Instance Variable Hiding::


File: JavaSE9.info,  Node: Instance Variable Hiding,  Up: this Keyword

2.5.1 Instance Variable Hiding
------------------------------

It is illegal to declare two local variables with the same name inside
the same or enclosing scope.  However, you can have local variables,
including formal parameters to methods, which overlap with the names
of the class' instance variables.  For these cases, the local
variables _hide_ the instance variables of the same name.

   Because 'this' lets you refer directly to the object, you can use
it to resolve any namespace collisions that might occur between
instance variables and local variables.  So, 'this.width = width' is
an example of a local variable ('width') hiding an instance variable
(also 'width'), with 'this' allowing an assignment between them.


File: JavaSE9.info,  Node: Stack Class,  Prev: this Keyword,  Up: Classes

2.6 A Stack Class
=================

To see a practical application of object-oriented programming, here is
one of the archetypal examples of encapsulation: the stack.  A "stack"
stores data using _first-in, last-out_ ordering.  That is, a stack is
like a stack of plates on a table -- the first plate put down on the
table is the last plate to be used.  Stacks are controlled through two
operations traditionally called "push" and "pop".  To put an item on
top of the stack, you will use 'push'.  To take an item off the stack,
you will use 'pop'.  It is easy to encapsulate the entire stack
mechanism.

   Here is a class called 'Stack' that implements a stack for up to
ten integers, plus test class called 'TestStack':

Stack.java
==========

{'Stack.java'} ==
     class Stack {
       <Stack Instance Variables>
       <Stack Constructor>
       <Stack Instance Methods>
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Constructor>       See *note Stack-Constructor::.
<Stack Instance           See *note Stack-Instance-Methods::.
Methods>
<Stack Instance           See *note Stack-Instance-Variables::.
Variables>

TestStack.java
==============

{'TestStack.java'} ==
     class TestStack {
       <TestStack Main Method>
     }


The called chunk <TestStack Main Method> is first defined at *note
TestStack-Main-Method::.

* Menu:

* Stack Instance Variables::
* Stack Constructor Node::
* Stack Instance Methods Node::
* Stack TestStack Node::


File: JavaSE9.info,  Node: Stack Instance Variables,  Next: Stack Constructor Node,  Up: Stack Class

2.6.1 Stack Instance Variables
------------------------------

<Stack Instance Variables> ==
     int[] stck = new int[10];
     int tos;


This chunk is called by {'Stack.java'}; see its first definition at
*note Stack-java::.


File: JavaSE9.info,  Node: Stack Constructor Node,  Next: Stack Instance Methods Node,  Prev: Stack Instance Variables,  Up: Stack Class

2.6.2 Stack Constructor Subsection
----------------------------------

<Stack Constructor> ==
     // initialize top-of-stack tos
     Stack() {
       tos = -1;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'Stack.java'}            See *note Stack-java::.
{'StackImproved.java'}    See *note StackImproved-java::.


File: JavaSE9.info,  Node: Stack Instance Methods Node,  Next: Stack TestStack Node,  Prev: Stack Constructor Node,  Up: Stack Class

2.6.3 Stack Instance Methods Subsection
---------------------------------------

<Stack Instance Methods> ==
     <Stack Push>
     <Stack Pop>

This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'Stack.java'}            See *note Stack-java::.
{'StackImproved.java'}    See *note StackImproved-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Pop>               See *note Stack-Pop::.
<Stack Push>              See *note Stack-Push::.

* Menu:

* Stack Push and Pop Node::


File: JavaSE9.info,  Node: Stack Push and Pop Node,  Up: Stack Instance Methods Node

2.6.3.1 Stack Push and Pop Subsubsection
........................................

<Stack Push> ==
     // Push an item onto the stack
     void push(int item) {
       if (tos == 9)
         System.out.println("Stack is full.");
       else
         stck[++tos] = item;
     }


This chunk is called by <Stack Instance Methods>; see its first
definition at *note Stack-Instance-Methods::.

<Stack Pop> ==
     // Pop an item from the stack
     int pop() {
       if (tos < 0) {
         System.out.println("Stack underflow.");
         return 0;
       } else
         return stck[tos--];
       }
     }


This chunk is called by <Stack Instance Methods>; see its first
definition at *note Stack-Instance-Methods::.


File: JavaSE9.info,  Node: Stack TestStack Node,  Prev: Stack Instance Methods Node,  Up: Stack Class

2.6.4 Stack TestStack Subsection
--------------------------------

<TestStack Main Method> ==
     public static void main(String[] args) {
       Stack mystack1 = new Stack();
       Stack mystack2 = new Stack();

       // push some numbers onto the stack
       for (int i = 0; i < 10; i++)
         mystack1.push(i);
       for (int i = 10; i < 20; i++)
         mystack2.push(i);

       // pop those numbers off the stack
       System.out.println("Stack in mystack1:");
       for (int i = 0; i < 10; i++)
         System.out.println(mystack1.pop());

       System.out.println("Stack in mystack2:");
       for (int i + 0; i < 10; i++)
         System.out.println(mystack2.pop());
     }


This chunk is called by {'TestStack.java'}; see its first definition
at *note TestStack-java::.


File: JavaSE9.info,  Node: Methods and Classes,  Next: Inheritance,  Prev: Classes,  Up: Top

3 Methods and Classes
*********************

This chapter examines several topics relating to methods and classes,
including

   * overloading
   * parameter passing
   * recursion
   * access control
   * keywords 'static' and 'final'
   * 'String' class
   * Arrays
   * nested and inner classes
   * command-line arguments and varargs

* Menu:

* Overloading Methods::
* Objects as Parameters::
* Argument Passing::
* Returning Objects::
* Recursion::
* Access Control::
* static Keyword::
* final Keyword::
* Arrays 2::
* Nested and Inner Classes::
* String Class::
* Command-Line Arguments::
* Varargs::


File: JavaSE9.info,  Node: Overloading Methods,  Next: Objects as Parameters,  Up: Methods and Classes

3.1 Overloading Methods
=======================

It is possible to define two or more methods within the same class
that share the same name as long as their parameter declarations are
different.  When this is the case, the methods are said to be
"overloaded", and the process is referred to as "method overloading".
Method overloading is one of the ways that Java supports polymorphism.

   When an overloaded method is invoked, Java uses the type and number
of arguments as its guid to determine which version of the overloaded
method to actually call.  Thus, overloaded methods must differ in the
type or number of their parameters.  While overloaded methods may have
different return types, thei return type alone is inusfficient to
distinguish two versions of a method.  When Java encounters a call to
an overloaded method, it simply executes the version of the method
whose parameters match the arguments used in the call.

   The match between arguments and parameters need not always be
exact.  In some cases,Java's automatic type conversions can play a
role in overload resolution.  For example, if there is a method with
one 'double' parameter, and that method is invoked with a single 'int'
argument, then, when no exact match is found, Java will automatically
convert the integer into a 'double', and this conversion will be used
to resolve the call.  Java will employ automatic type conversion only
if no exact match is found.

   Method overloading supports polymorphism because it is one way that
Java implements the _one interface, multiple methods_ paradigm.  That
is, Java does not need to rename each similar method just because it
has a slightly different parameter requirements.  The value of
overloading is that it allows related methods to be accessed by use of
a common name, representing the _general action_ that is being
performed, and leaves to the compiler the choice of the right
_specific_ version for a particular circumstance.  The programmer need
only remember the general operation being performed.  Through the
application of polymorphism, several names have been reduced to one.
Overloading can help manage greater complexity.

* Menu:

* Overloading Constructors::


File: JavaSE9.info,  Node: Overloading Constructors,  Up: Overloading Methods

3.1.1 Overloading Constructors
------------------------------

You can also overload constructor methods.


File: JavaSE9.info,  Node: Objects as Parameters,  Next: Argument Passing,  Prev: Overloading Methods,  Up: Methods and Classes

3.2 Objects as Parameters
=========================

It is both correct and common to pass objects to methods as well as
primitive types.  One of the most common uses of object parameters
involves constructors.  Frequently you will want to construct a new
object so that it is initially the same as some existing object.  To
do this, you must define a constructor that takes an object of its
class as a parameter.  Providng many forms of constructors is usually
required to allow objects to be constructed in a convenient and
efficient manner.


File: JavaSE9.info,  Node: Argument Passing,  Next: Returning Objects,  Prev: Objects as Parameters,  Up: Methods and Classes

3.3 Argument Passing
====================

In general, there are two ways that a computer language can pass an
argument to a subroutine:

  1. call-by-value
  2. call-by-reference

   Java uses call-by-value to pass all arguments, although the precise
effect differs between whether a primitive type or a reference type is
passed.

   When you pass a primitive type to a method, it is passed by value.
Thus, a copy of the argument is made, and what occurs to the parameter
that receives the argument has no effect outside the method.

   When you pass an object to a method, the situation changes; objects
are passed by what is effectively call-by-reference.  When you pass a
variable of a class type, you pass a reference to the method and the
parameter receiving it will refer to the same object.  This
effectively means that objects act as if they are passed to methods by
use of call-by-reference.  Changes to the object inside the method
_do_ affect the object used as an argument.  However, when an object
reference is passed to a method, the reference itself is passed by use
of call-by-value; therefore, that reference will continue to refer to
the object, even though the object itself may be modified.


File: JavaSE9.info,  Node: Returning Objects,  Next: Recursion,  Prev: Argument Passing,  Up: Methods and Classes

3.4 Returning Objects
=====================

A method can return any type of data, including class types that you
create.

   Since all objects are dynamically allocated using 'new', you don't
need to worry about an object going out-of-scope because the method in
which it was created terminates.  The object will continue to exist as
long as there is a reference to it somewhere in your program.  When
there are no references to it, the object will be reclaimed the next
time garbage collection takes place.


File: JavaSE9.info,  Node: Recursion,  Next: Access Control,  Prev: Returning Objects,  Up: Methods and Classes

3.5 Recursion
=============

"Recursion" is the process of defining something in terms of itself.
In programming, it is also what allows a method to call itself.  A
method that calls itself is said to be "recursive".

   When a method calls itself, new local variables and parameters are
allocated storage on the stack, and the method code is executed with
these new variables from the start.  As each recursive call returns,
the old local variables and parameters are removed from the stack, and
execution resumes at the point of the call inside the method.

   Recursive versions of many routines may execute a bit slower than
the iterative equivalent because of the added overhead of the
additional method calls.  A large number of recursive calls to a
method could cause a stack overrun.  Because storage for parameters
and local varibles is on the stack and each new call creates a new
copy of these variables, it is possible that the stack could be
exhausted.  If this occurs, the Java run-time system will cause an
exception.

   The main advantage to recursive methods is that they can be used to
create clearer and simpler versions of several algorithms than can
their iterative relatives.  For example, the QuickSort sorting
algorithm is quite difficult to implement in an iterative way.  Also,
some types of AI-related algorithms are most easily implemented using
recursive solutions.


File: JavaSE9.info,  Node: Access Control,  Next: static Keyword,  Prev: Recursion,  Up: Methods and Classes

3.6 Access Control
==================

Encapsulation provides another important attribute besides linking
data with code: "access control".  Through encapsulation, you can
control what parts of a program can access the members of a class.  By
controlling access, you can prevent misuse.  Thus, when correctly
implemented, a class creates a _black box_ which may be used, but the
inner workings of which are not open to tampering.  The classes
introduced earlier do not completely meet this goal.  For example, the
'Stack' class provides the methods 'push()' and 'pop()' as a
controlled interface to the stack, this interface is not enforced --
it is possible for another part of the program to bypass these methods
and access the stack directly.  This could lead to trouble.

   How a member can be accessed is determined by the "access modifier"
attached to its declaration.  Java supplies a rich set of access
modifiers.  Some aspects of access control are related mostly to
inheritance or packages (and now modules).  Those ideas will be
discussed later.  Here, let's examine access control as it relates to
a single class.

Access Modifiers
----------------

Java's access modifiers are:

   * public
   * private
   * protected (applies only to inheritance)
   * default access level

'public' vs 'private' Access
............................

When a member of a class is modified by 'public', then that member can
be accessed by any other code.  When a member of a class is specified
as 'private', then that member can only be accessed by other members
of its class.  Thus, the method 'main()' is always preceded by the
'public' modifier.  It must be called by code that is outside the
program -- the Java run-time system.

Default Access -- No Access Modifier
------------------------------------

When no access modifier is used, then by default the member of a class
is public within its own package, but cannot be accessed outside of
its package.  In the classes developed so far, all members of a class
have used the 'default' access mode.  However, this is typically not
what you will want to be the case.  Usually, you will want to restrict
access to the data members of a class -- allowing access only through
methods.  There will also be times when you will want to define
methods that are private to a class.

Access Modifier Syntax
----------------------

An access modifier precedes the rest of a member's type specification.
That is, it must begin a member's declaration statement.  As an
example:

     public int i;
     private double j;

     private int myMethod(int a, char b) {
       ...
     }

Access Control and Inheritance
------------------------------

Consult the chapter on *note Inheritance:: for more on the topic of
access control in relation to inheritance.

* Menu:

* Improved Stack Class::


File: JavaSE9.info,  Node: Improved Stack Class,  Up: Access Control

3.6.1 An Improved 'Stack' Class
-------------------------------

StackImproved.java
------------------

Compare this code with that of *note Stack Class::.  (1)

{'StackImproved.java'} ==
     class StackImproved {
       <Stack Private Instance Variables>
       <Stack Constructor>
       <Stack Instance Methods>
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Stack Constructor>       See *note Stack-Constructor::.
<Stack Instance           See *note Stack-Instance-Methods::.
Methods>
<Stack Private Instance   See
Variables>                *note Stack-Private-Instance-Variables::.

Stack Private Instance Variables
--------------------------------

<Stack Private Instance Variables> ==
     /* Now, both stck and tos are private.  This means
        that they cannot be accidentally or maliciously
        altered in a way that would be harmful to the stack.
      */

     private int[] stck = new int[10];
     private int tos;


This chunk is called by {'StackImproved.java'}; see its first
definition at *note StackImproved-java::.

   Now both 'stck', which holds the stack, and 'tos', which is the
index of the top of the stack, are specified as 'private'.  This means
that they cannot be accessed or altered except through 'push()' and
'pop()'.  Making 'tos' private, for example, prevents other parts of
your program from inadvertently setting it to a value that is beyond
the end of the 'stck' array.  In other words, the following code,
added to the end of the 'TestStack.java' program (*note
TestStack-Main-Method::), would be illegal and the program would not
compile:

     mystack1.tos = -2;
     mystack2.stck[3] = 100;

   ---------- Footnotes ----------

   (1) Notice how all of the prior code except what is changed can
easily be reused using TexiWebJr's modular system.


File: JavaSE9.info,  Node: static Keyword,  Next: final Keyword,  Prev: Access Control,  Up: Methods and Classes

3.7 'static' Keyword
====================

There will be times when you want to define a class member that will
be used independently of any object of that class.  Normally, a class
member must be accessed in conjunction with an object of its class.
However, it is possible to create a member that can be used by itself
without reference to a specific instance.  To create such a member,
precede its declaration with the keyword 'static'.  When a member is
declared 'static', it can be accessed before any objects of its class
are created, and without reference to any object.

   You can declare both methods and variables to be 'static'.
Instance variables declared as 'static' are essentially global
variables.  When objects of its class are declared, no copy of a
'static' variable is made.  Instead, all instances of the class share
the same 'static' variable.

Restrictions on 'static' Methods
--------------------------------

Methods declared as 'static' have several restrictions:

   * they can only directly call other 'static' methods of their
     class;
   * they can only directly access 'static' variables of their class;
   * they cannot refer to 'this' or 'super' in any way;

'static' Block
--------------

If you need to do computation in order to initialize your 'static'
variables, you can declare a 'static' block that gets executed exactly
once, when the class is first loaded ("static initialization block").

     class UseStatic {
       static int a = 3;
       static int b;

       static {
         b = a * 4;
       }
     }

   As soon as the 'UseStatic' class is loaded, all of the 'static'
statements are run.  First, 'a' is set to '3', then the 'static' block
executes and initializes 'b' to 'a * 4' or '12'.  Then 'main()' is
called (not shown).

Use of 'static' Members Outside Their Class
-------------------------------------------

Outside of the class in which they are defined, 'static' methods and
variables can be used independently of any object.  To do so, you need
only specify the name of their class followed by the dot operator:
classname.method().  classname is the name of the class in which the
'static' method is declared.  A 'static' variable can be accessed in
the same way.  This is how Java implements a controlled version of
global methods and global variables.


File: JavaSE9.info,  Node: final Keyword,  Next: Arrays 2,  Prev: static Keyword,  Up: Methods and Classes

3.8 'final' Keyword
===================

A field can be declared as 'final'.  Doing so prevents its contents
from being modified, making it, esentially, a constant.  This means
that you must initialize a 'final' field when it is declared.  You can
do this in one of two ways: when it is declared, or within a
constructor.

   In addition to fields, both method parameters and local variables
can be declared as 'final'.  Declaring a parameter as 'final' prevents
it from being changed within the method.  Declaring a local variable
'final' prevents it from being assigned a value more than once.

   The keyword 'final' can also be applied to methods, but its meaning
is different than when applied to variables.  This usage of 'final' is
described in the next chapter (*note Inheritance::).


File: JavaSE9.info,  Node: Arrays 2,  Next: Nested and Inner Classes,  Prev: final Keyword,  Up: Methods and Classes

3.9 Arrays Revisited
====================

Arrays are implemented as objects.  Because of this, there is a
special array attribute that you will want to take advantage of.
Specifically, the size of an array--that is, the number of elements
that an array can hold--is found in its 'length' instance variable.
All arrays have this variable, and it will always hold the size of the
array.  Keep in mind that the value of 'length' has nothing to do with
the number of elements that are actually in use.  It only reflects the
number of elements taht the array is designed to hold.


File: JavaSE9.info,  Node: Nested and Inner Classes,  Next: String Class,  Prev: Arrays 2,  Up: Methods and Classes

3.10 Nested and Inner Classes
=============================

It is possible to define a class within another class; such classes
are known as "nested classes".  The scope of a nested class is bounded
by the scope of its enclosing class.  A nested class does not exist
independently of its enclosing class.  A nested class has access to
the members, including private members, of the enclosing class.
However,the enclosing class does not have access to the members of the
nested class.  A nested class that is declared directly within its
enclosing class scope is a member of its enclosing class.  It is also
possible to declare a nested class that is local to a block.

Static Nested Class
===================

There are two types of nested class: "static" and "inner".  A static
nested class is one that has the 'static' modifer applied.  Because it
is static, it must access the non-static members of its enclosing
class through an object.  That is, it cannot refer to non-static
members of its enclosing class directly.  Static nested classes are
seldom used.

Inner Class
===========

The most important type of nested class is the "inner" class.  An
inner class is a non-static nested class.  It has access to all of the
variables and methods of its outer class and may refer to them
directly in the same way that other non-static members of the outer
class do.

   An instance of an inner class can be created only in the context of
its enclosing class.  The Java compiler will report an error
otherwise.  In general, an inner class instance is often creaed by
code within its enclosing scope.

   It is possible to define inner classes within any block scope,
including within the block defined by a method or even within the body
of a 'for' loop.

Handling Events
===============

While nested classes are not applicable to all situations, they are
particularly helpful when handling events.  *Note Event Handling::.
There are also "anonymous inner classes", inner classes that don't
have a name.


File: JavaSE9.info,  Node: String Class,  Next: Command-Line Arguments,  Prev: Nested and Inner Classes,  Up: Methods and Classes

3.11 The 'String' Class
=======================

Every string you create is an object of type 'String'.  Even string
constants are 'String' objects.  For example, in the statement
'System.out.println("This is a String, too");', the quote is a
'String' object.

   Objects of type 'String' are immutable; once a 'String' object is
created, its contents cannot be altered.  Java defines peer classes of
'String', called 'StringBuffer' and 'StringBuilder', which allow
strings to be altered, so all of the normal string manipulations are
still available.

Constructing 'String' Objects and Concatenating 'Strings'
=========================================================

Strings can be constructed in a variable of ways.  The easiest is to
use a statement:

     String myString = "this is a test";

   Java defines one operator for 'String' objects: '+'.  It is used to
concatenate two strings.

     String myString = "I" + " like " + "Java.";

'String' Methods
================

The 'String' class contains several methods that you can use.

   * boolean 'equals(secondStr)'
   * int 'length()'
   * char 'charAt(index)'


File: JavaSE9.info,  Node: Command-Line Arguments,  Next: Varargs,  Prev: String Class,  Up: Methods and Classes

3.12 Using Command-Line Arguments
=================================

Sometimes you will want to pass information into a program when you
run it.  This is accomplished by passing "command-line arguments" to
'main()'.  A command-line argument is the informatino that directly
follows the program's name on the command line when it is executed.
To access the command-line arguments inside a Java program, access the
'String' arguments passed to the 'args' parameter of 'main()'.  The
first command-line argument is stored at 'args[0]', the second at
'args[1]', and so on.  All command-line arguments are passed as
strings.  You must convert numeric values to their internal forms
manually.  *Note Exploring java-lang::.


File: JavaSE9.info,  Node: Varargs,  Prev: Command-Line Arguments,  Up: Methods and Classes

3.13 Varargs: Variable-Length Arguments
=======================================

Beginning with JDK 5, Java has included a feature that simplifies the
creation of methods that need to take a variable number of arguments.
This feature is called "varargs" and it is short for "variable-length
arguments".  A method that takes a variable number of arguments is
called a "variable-arity method", or simply "varargs method".

   A variable-length argument is specified by three period (...).  For
example: 'static void vaTest (int ... v) {'.  This syntax tells the
compiler that 'vaTest()' can be called with zero or more arguments.
As a result, 'v' is implicitly declared as an array of type 'int[]'.
Thus, inside 'vaTest()', 'v' is accessed using the normal array
syntax.

   A method can have _normal_ parameters along with a variable-length
parameter, but the variable-length parameter must be the final
parameter declared by the method.  Further, there can be only one
varargs parameter.

     int doIt(int a, int b, double c, int ... vals) {

   After the first three arguments, any remaining arguments are passed
to 'vals'.

Overloading Vararg Methods
==========================

You can overload a method that takes a variable-length argument (i.e.,
it can be given a different type, or additional parameters can be
included, or a non varargs parameter).

   Note that unexpected errors can result when overloading a method
that takes a variable-length argument.  These errors involve ambiguity
because it is possible to create an ambiguous call to an overloaded
varargs method.  In such a case, the program will not compile.  While
each individual method declaration might be valid, the call might yet
be ambiguous.


File: JavaSE9.info,  Node: Inheritance,  Next: Packages,  Prev: Methods and Classes,  Up: Top

4 Inheritance
*************

Inheritance is a cornerstone of object-oriented programming because it
allows the creation of hierarchical classifications.  Using
inheritance, you can create a general class that defines traits common
to a set of related items.  This class can then be inherited by other,
more specific classes, each adding those things that are unique to
them.

   A class that is inherited is called a "superclass".  The class that
does the inheriting is called a "subclass".  A subclass is a
specialized version of a subclass.  It inherits all of the members
defined by the superclass and adds its own, unique elements.

* Menu:

* Inheritance Basics::
* Using super::
* Multilevel Hierarchy::
* Constructors Executed::
* Method Overriding::
* Dynamic Method Dispatch::
* Using Abstract Classes::
* final with Inheritance::
* Object Class::


File: JavaSE9.info,  Node: Inheritance Basics,  Next: Using super,  Up: Inheritance

4.1 Inheritance Basics
======================

To _inherit_ a class, incorporate the definition of one class into
another by using the 'extends' keyword.

     class A {...}
     class B extends A {...}

   A subclass will include all of the members of its superclass.  The
subclass can directly reference all of the members of the superclass
as well.  Subclasses can be superclasses of other subclasses.

General Form of a Subclass Inheriting a Superclass
==================================================

     class subclass-name extends superclass-name {
       body of class
     }

GeneralForm 4.1: Subclass General Form

A subclass can have only one superclass.  Java does not support the
inheritance of multiple superclasses into a single subclass.

* Menu:

* Member Access and Inheritance::
* Superclass Referencing Subclass::


File: JavaSE9.info,  Node: Member Access and Inheritance,  Next: Superclass Referencing Subclass,  Up: Inheritance Basics

4.1.1 Member Access and Inheritance
-----------------------------------

Although a subclass includes all of the members of its superclass, it
cannot access those members of the superclass that have been declared
as 'private'.  A class member that has been declared as 'private' will
remain private to its class.  It is not accessible by any code outside
its class, including subclasses.

   A major advantage of inheritance is that once you have created a
superclass that defines the attributes commoin to a set of objects, it
can be used to create any number of more specific subclasses.  Each
subclass can precisely tailor its own classification.


File: JavaSE9.info,  Node: Superclass Referencing Subclass,  Prev: Member Access and Inheritance,  Up: Inheritance Basics

4.1.2 A Superclass Variable Can Reference a Subclass Object
-----------------------------------------------------------

A reference variable of a superclass can be assigned a reference to
any subclass derived from that superclass.

   It is important to understand that itis the _type of the reference
variable_ -- not the type of the object that it refers to -- that
determines what members can be accessed.  That is, when a reference to
a subclass object is assigned to a superclass reference variable, you
will have access _only_ to those parts of the object defined by the
superclass.  The superclass has no knowledge of what a subclass adds
to it.


File: JavaSE9.info,  Node: Using super,  Next: Multilevel Hierarchy,  Prev: Inheritance Basics,  Up: Inheritance

4.2 Using 'super'
=================

Whenever a subclass needs to refer to its immediate superclass, it can
do so by use of the keyword 'super'.  'super' has two general forms.
The first calls the superclass' constructor.  The second is used to
access a member of the superclass that has been hidden by a member of
a subclass.

* Menu:

* super Calling Superclass Constructor::
* super Referencing Superclass::


File: JavaSE9.info,  Node: super Calling Superclass Constructor,  Next: super Referencing Superclass,  Up: Using super

4.2.1 Using 'super' to Call Superclass Constructors
---------------------------------------------------

A subclass can call a constructor defined by its superclass by use of
the following form of 'super':

     super(arg-list);

GeneralForm 4.2: 'super' Calling a Constructor

   arg-list specifies any arguments needed by the constructor in the
superclass.  'super()' must always be the first statement executed
inside a subclass' constructor.  'super()' can be called using any
form defined by the superclass.


File: JavaSE9.info,  Node: super Referencing Superclass,  Prev: super Calling Superclass Constructor,  Up: Using super

4.2.2 'super' Referencing Superclass
------------------------------------

The second form of 'super' acts somewhat like 'this', except that it
always refers to the superclass of the subclass in which it is used.

     super.member

GeneralForm 4.3: 'super' Referencing its Superclass

   member can be either a method or an instance variable.  This form
of 'super' is most applicable to situations in which member names of a
subclass hide members by the same name in the superclass.

     i = super.i;

   'super' allows access to the 'i' defined in the superclass.
'super' can also be used to call methods that are hidden by a
subclass.


File: JavaSE9.info,  Node: Multilevel Hierarchy,  Next: Constructors Executed,  Prev: Using super,  Up: Inheritance

4.3 Creating a Multilevel Hierarchy
===================================

You can buidl hierarchies that contain as many layers of inheritance
as you like.  It is acceptable to use a subclass as a superclass of
antoher.  Each subclass inherits all of tghe traits found in all of
its superclasses.

   'super' always refers to the constructor in the closest superclass.

   While an entire class hierarchy can be created in a single file,
the individual classes (superclasses and subclasses) can be placed
into their own files and compiled separately.  Using separate files is
the norm, not the exception, in creating class hierarchies.


File: JavaSE9.info,  Node: Constructors Executed,  Next: Method Overriding,  Prev: Multilevel Hierarchy,  Up: Inheritance

4.4 When Constructors are Executed
==================================

In a class hierarchy, constructors complete their execution in order
of derivation, from superclass to subclass.


File: JavaSE9.info,  Node: Method Overriding,  Next: Dynamic Method Dispatch,  Prev: Constructors Executed,  Up: Inheritance

4.5 Method Overriding
=====================

In a class hierarchy, when a method in a subclass has the same name
and type signature as a method in its superclass, then the method in
the subclass is said to "override" the method in the superclass.  When
an overriden method is called from within its subclass, it will always
refer to the version of that method defined by the subclass.  The
version of the method defined by the superclass will be hidden.

   If you wish to access the superclass version of an overridden
method, you can so by using 'super'.

   Method overriding occurs _only_ when the names and the type
signatures of the two methods are identical.  If they are not, then
the two methods are simply overloaded (no name hiding takes place).


File: JavaSE9.info,  Node: Dynamic Method Dispatch,  Next: Using Abstract Classes,  Prev: Method Overriding,  Up: Inheritance

4.6 Dynamic Method Dispatch
===========================

Method overriding forms the basis for one of Java's most powerful
concepts: "dynamic method dispatch".  This is a meachanism by which a
call to an overrident method is resolved at run time, rather than
compile time.  This is important because this is how Java implements
run-time polymorphism.

   A superclass reference variable can refer to a subclass object.
Java uses this fact to resolve calls to overriden methods at run time.
When an overriden method is called through a superclass reference,
Java determines which version of that method to execute based upon the
type of the object being referred to at the time the call occurs.
Thus, this determination is made at run time.  When different types of
objects are referred to, different versions of an overridden method
will be called.  In other words, _it is the type of the object being
referred to_ (not the type of the reference variable) that determines
which version of an overridden method will be executed.  Therefore, if
a superclass contains a method that is overridden by a subclass, then
when different types of objects are referred to through a superclass
reference variable, different versions of the method are executed.

* Menu:

* Why Overridden Methods::
* Applying Method Overriding::


File: JavaSE9.info,  Node: Why Overridden Methods,  Next: Applying Method Overriding,  Up: Dynamic Method Dispatch

4.6.1 Why Overridden Methods?
-----------------------------

Overridden methods allow Java to support run-time polymorphism.
Polymorphism is essential to object-oriented programming for one
reason: it allows a general class to specify methods that will be
common to all of its derivatives, while allowing subclasses to define
the specific implementation of some or all of those methods.
Overridden methods are another way that Java implements the "one
interface, multiple methods" aspect of polymorphism.

   Successfully applying polymorphism is understanding that the
superclasses and subclasses form a hierarchy which moves from lesser
to greater specialization.  Used correctly, the superclass provides
all elements that a subclass can use directly.  It also defines those
methods that the derived class must implement on its own.  This allows
the subclass the flexibility to define its own methods, yet still
enforces a consistent interface.  Thus, by combining inheritance with
overridden methods, a superclass can define the general form of the
methods that will be used by all of its subclasses.

   Dynamic, run-time polymorphism is one of the most powerful
mechanisms that object-oriented design brings to bear on code reuse
and robustness.  The ability of existing code libraries to call
methods on instances of new classes without recompiling while
maintaining a clean abstract interface is a profoundly powerful tool.


File: JavaSE9.info,  Node: Applying Method Overriding,  Prev: Why Overridden Methods,  Up: Dynamic Method Dispatch

4.6.2 Applying
--------------

Let's look at a practical example that uses method overriding.  The
following program creates a superclass called 'Figure' that stores the
dimensions of a two-dimensional object.  It also defines a method
called 'area()' that computes the area of an object.  The program
derives two subclasses from 'Figure'.  The first is 'Rectangle' and
the second is 'Triangle'.  Each of these subclasses overrides 'area()'
so that it returns the area of a rectangle and a triangle
respectively.

{'FindAreas.java '} ==
     <FindAreas SuperClass Figure >
     <FindAreas SubClass Rectangle >
     <FindAreas SubClass Triangle >
     <FindAreas Main Class >


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<FindAreas Main Class >   See *note FindAreas-Main-Class-::.
<FindAreas SubClass       See *note FindAreas-SubClass-Rectangle-::.
Rectangle >
<FindAreas SubClass       See *note FindAreas-SubClass-Triangle-::.
Triangle >
<FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
Figure >

Output
......

The output from the program should be:

     Inside Area for Rectangle.
     Area is 45
     Inside Area for Triangle.
     Area is 40
     Area for Figure is undefined.
     Area is 0

   Through the dual mechanisms of inheritance and run-time
polymorphism, it is possible to define one consistent interface that
is used by several different, yet related, types of objects.  In this
case, if an object is derived from 'Figure', then its area can be
obtained by calling 'area()'.  The interface to this operation is the
same no matter what type is being used.

* Menu:

* FindAreas SuperClass Figure Node::
* FindAreas SubClass Rectangle Node::
* FindAreas SubClass Triangle Node::
* FindAreas Main Class Node::


File: JavaSE9.info,  Node: FindAreas SuperClass Figure Node,  Next: FindAreas SubClass Rectangle Node,  Up: Applying Method Overriding

4.6.2.1 FindAreas Superclass Figure Section
...........................................

<FindAreas SuperClass Figure > ==
     class Figure {
       <Figure Instance Variable Declarations >
       <Figure Constructor >
       <Figure Area Method Declaration >
     }


This chunk is called by {'FindAreas.java '}; see its first definition
at *note FindAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Figure Area Method       See *note Figure-Area-Method-Declaration-::.
Declaration >
<Figure Constructor >     See *note Figure-Constructor-::.
<Figure Instance          See
Variable Declarations >   *note Figure-Instance-Variable-Declarations-::.

Figure Instance Variable Declarations
.....................................

<Figure Instance Variable Declarations > ==
     double dim1;
     double dim2;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
<FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
Figure >

Figure Constructor
..................

<Figure Constructor > ==
     Figure (double 1, double b) {
       dim1 = a;
       dim2 = b;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
<FindAreas SuperClass     See *note FindAreas-SuperClass-Figure-::.
Figure >

Figure Area Method Declaration
..............................

It will be this method that will be overridden by the two subclasses;
while this method will not produce any output, each of the subclasses
will provide a formula for their own area and output that number, even
though the same method ('area()') is being called in each case from
the same variable.

<Figure Area Method Declaration > ==
     double area() {
       System.out.println("Area for Figure is undefined.");
       return 0;
     }


This chunk is called by <FindAreas SuperClass Figure >; see its first
definition at *note FindAreas-SuperClass-Figure-::.


File: JavaSE9.info,  Node: FindAreas SubClass Rectangle Node,  Next: FindAreas SubClass Triangle Node,  Prev: FindAreas SuperClass Figure Node,  Up: Applying Method Overriding

4.6.2.2 FindAreas SubClass Rectangle Section
............................................

<FindAreas SubClass Rectangle > ==
     class Rectangle extends Figure {
       <Rectangle Constructor >
       <Rectangle Area Method Declaration >
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'AbstractAreas.java '}   See *note AbstractAreas-java-::.
{'FindAreas.java '}       See *note FindAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Rectangle Area Method    See
Declaration >             *note Rectangle-Area-Method-Declaration-::.
<Rectangle Constructor    See *note Rectangle-Constructor-::.
>

Rectangle Constructor
.....................

<Rectangle Constructor > ==
     Rectangle (double a, double b) {
       super(a, b);
     }


This chunk is called by <FindAreas SubClass Rectangle >; see its first
definition at *note FindAreas-SubClass-Rectangle-::.

Rectangle Area Method Declaration
.................................

<Rectangle Area Method Declaration > ==
     // override area for rectangle
     double area() {
       System.out.println("Inside Area for Rectangle.";
       return dim1 * dim2;
     }


This chunk is called by <FindAreas SubClass Rectangle >; see its first
definition at *note FindAreas-SubClass-Rectangle-::.


File: JavaSE9.info,  Node: FindAreas SubClass Triangle Node,  Next: FindAreas Main Class Node,  Prev: FindAreas SubClass Rectangle Node,  Up: Applying Method Overriding

4.6.2.3 FindAreas SubClass Triangle Section
...........................................

<FindAreas SubClass Triangle > ==
     class Triangle extends Figure {
       <Triangle Constructor >
       <Triangle Area Method Declaration >
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'AbstractAreas.java '}   See *note AbstractAreas-java-::.
{'FindAreas.java '}       See *note FindAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Triangle Area Method     See
Declaration >             *note Triangle-Area-Method-Declaration-::.
<Triangle Constructor >   See *note Triangle-Constructor-::.

Triangle Constructor
....................

<Triangle Constructor > ==
     Triangle (double a, double b) {
       super(a, b);
     }


This chunk is called by <FindAreas SubClass Triangle >; see its first
definition at *note FindAreas-SubClass-Triangle-::.

Triangle Area Method Declaration
................................

<Triangle Area Method Declaration > ==
     // override area for right triangle
     double area () {
       System.out.println("Inside Area for Triangle.");
       return dim1 * dim2 / 2;
     }


This chunk is called by <FindAreas SubClass Triangle >; see its first
definition at *note FindAreas-SubClass-Triangle-::.


File: JavaSE9.info,  Node: FindAreas Main Class Node,  Prev: FindAreas SubClass Triangle Node,  Up: Applying Method Overriding

4.6.2.4 FindAreas Main Class Section
....................................

<FindAreas Main Class > ==
     class FindAreas {
       <FindAreas Main Method Declaration >
     }


This chunk is called by {'FindAreas.java '}; see its first definition
at *note FindAreas-java-::.

The called chunk <FindAreas Main Method Declaration > is first defined
at *note FindAreas-Main-Method-Declaration-::.

FindAreas Main Method Declaration
.................................

<FindAreas Main Method Declaration > ==
     public static void main (String[] args[]) {
       <Create Basic Figure Objects >
       <Create Basic Figure Reference Variable >
       <Call Overridden Methods One By One >
     }


This chunk is called by <FindAreas Main Class >; see its first
definition at *note FindAreas-Main-Class-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Call Overridden          See
Methods One By One >      *note Call-Overridden-Methods-One-By-One-::.
<Create Basic Figure      See *note Create-Basic-Figure-Objects-::.
Objects >
<Create Basic Figure      See
Reference Variable >      *note Create-Basic-Figure-Reference-Variable-::.

Create Basic Figure Objects
...........................

<Create Basic Figure Objects > ==
     Figure f = new Figure(10, 10);
     Rectangle r = new Rectangle(9, 5);
     Triangle t = new Triangle(10, 8);


This chunk is called by <FindAreas Main Method Declaration >; see its
first definition at *note FindAreas-Main-Method-Declaration-::.

Create Basic Figure Reference Variable
......................................

This superclass reference variable 'Figure figref' will hold,
alternately, references to each of the classes and will call the
method 'area()' on each, producing a different result each time.  This
is the essence of method overriding and dynamic method dispatch.

<Create Basic Figure Reference Variable > ==
     Figure figref;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Main       See
Method Declaration >      *note AbstractAreas-Main-Method-Declaration-::.
<FindAreas Main Method    See
Declaration >             *note FindAreas-Main-Method-Declaration-::.

Call Overridden Methods One By One
..................................

<Call Overridden Methods One By One > ==
     figref = r;
     System.out.println("Area is " + figref.area());

     figref = t;
     System.out.println("Area is " + figref.area());

     figref = f;
     System.out.println("Area is " + figref.area());


This chunk is called by <FindAreas Main Method Declaration >; see its
first definition at *note FindAreas-Main-Method-Declaration-::.


File: JavaSE9.info,  Node: Using Abstract Classes,  Next: final with Inheritance,  Prev: Dynamic Method Dispatch,  Up: Inheritance

4.7 Using Abstract Classes
==========================

There are situations in which you will want to define a superclass
that declares the structure of a given abstraction without providing a
complete implementation of every method.  That is, sometimes you will
wnat to create a superclass that only defines a generalized form that
will be shared by all of its subclasses, leaving it to each subclass
to fill in the details.  Such a class determines the nature of the
methods that the subclasses must implement.  One way this situation
can occur is when a superclass is unable to create a meaningful
implementation for a method.  This is the case with 'Figure' in the
preceding example.  The definition of 'area()' is simply a
placeholder.  It will not compute and display the area of any type of
object.

   It is not uncommon for a method to have no meaningful definition in
the context of its superclass.  Java's solution to this problem is the
"abstract method".

   You can require that certain methods be overridden by subclasses by
specifying the 'abstract' type modifier.  These methods are sometimes
referred to as "subclasser responsibility" because they have no
implementation specified in the superclass.  Thus, a subclass must
override them -- it cannot simply use the version defined in the
superclass.

   To declare an abstract method, use the general form:

     abstract type name (parameter-list);

GeneralForm 4.4: Abstract Method Declaration--General Form

No method body is present.

   Any class that contains one or more abstract methods must also be
declared abstract.  To declare a class abstract, simply use the
'abstract' keyword in front of the 'class' keyword at the beginning of
the class declaration.  There can be no objects of an abstract class.
That is, an abstract class cannot be directlyi instantiated with the
'new' operator.  You cannot declare abstract constructors or abstract
static methods.  Any subclass of an abstract class must either
implement all of the abstract methods in the superclass, or be
declared 'abstract' itself.  Abstract classes can include fully
implemented methods.

Abstract Classes Can Be Reference Variables
===========================================

Although abstract classes cannot be used to instantiate objects, they
can be used to create object references, because Java's approach to
run-time polymorphism is implemented thruogh the use of superclass
references.  Thus, it must be possible to create a reference to an
asbtract class so that it can be used to point to a subclass object.

* Menu:

* Improved Figure Class::


File: JavaSE9.info,  Node: Improved Figure Class,  Up: Using Abstract Classes

4.7.1 Improved Figure Class
---------------------------

Using the abstract class, you can improve the 'Figure' class.  Since
there is no meaningful concept of area for an undefined
two-dimensional figure, the following version of the program declares
'area()' as abstract inside 'Figure'.  This means that all classes
derived from 'Figure' must override 'area()'.

{'AbstractAreas.java '} ==
     <AbstractAreas Abstract Class Figure >
     <FindAreas SubClass Rectangle >
     <FindAreas SubClass Triangle >
     <AbstractAreas Main Class >


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Class Figure >            *note AbstractAreas-Abstract-Class-Figure-::.
<AbstractAreas Main       See *note AbstractAreas-Main-Class-::.
Class >
<FindAreas SubClass       See *note FindAreas-SubClass-Rectangle-::.
Rectangle >
<FindAreas SubClass       See *note FindAreas-SubClass-Triangle-::.
Triangle >

* Menu:

* AbstractAreas Abstract Class Figure Node::
* AbstractAreas Main Class::


File: JavaSE9.info,  Node: AbstractAreas Abstract Class Figure Node,  Next: AbstractAreas Main Class,  Up: Improved Figure Class

4.7.1.1 AbstractAreas Abstract Class Figure Section
...................................................

Notice that much of this class stays the same as the original 'Figure'
code, but includes two 'abstract' declarations, one for the class, and
one for the 'area()' method declaration.

<AbstractAreas Abstract Class Figure > ==
     abstract class Figure {
       <Figure Instance Variable Declarations >
       <Figure Constructor >
       <AbstractAreas Abstract Area Method Declaration >
     }


This chunk is called by {'AbstractAreas.java '}; see its first
definition at *note AbstractAreas-java-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<AbstractAreas Abstract   See
Area Method Declaration   *note AbstractAreas-Abstract-Area-Method-Declaration-::.
>
<Figure Constructor >     See *note Figure-Constructor-::.
<Figure Instance          See
Variable Declarations >   *note Figure-Instance-Variable-Declarations-::.

AbstractAreas Abstract Area Method Declaration
..............................................

<AbstractAreas Abstract Area Method Declaration > ==
     // areas is now an abstract method
     abstract double area ();


This chunk is called by <AbstractAreas Abstract Class Figure >; see
its first definition at *note AbstractAreas-Abstract-Class-Figure-::.


File: JavaSE9.info,  Node: AbstractAreas Main Class,  Prev: AbstractAreas Abstract Class Figure Node,  Up: Improved Figure Class

4.7.1.2 Abstract Main Class
...........................

<AbstractAreas Main Class > ==
     class AbstractAreas {
       <AbstractAreas Main Method Declaration >
     }


This chunk is called by {'AbstractAreas.java '}; see its first
definition at *note AbstractAreas-java-::.

The called chunk <AbstractAreas Main Method Declaration > is first
defined at *note AbstractAreas-Main-Method-Declaration-::.

AbstractAreas Main Method Declaration
.....................................

<AbstractAreas Main Method Declaration > ==
     public static void main (String[] args) {
       <Create Basic Figure Objects Except Figure >
       <Create Basic Figure Reference Variable >
       <Call Overridden Methods One By One Except Figure >
     }


This chunk is called by <AbstractAreas Main Class >; see its first
definition at *note AbstractAreas-Main-Class-::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Call Overridden          See
Methods One By One        *note Call-Overridden-Methods-One-By-One-Except-Figure-::.
Except Figure >
<Create Basic Figure      See
Objects Except Figure >   *note Create-Basic-Figure-Objects-Except-Figure-::.
<Create Basic Figure      See
Reference Variable >      *note Create-Basic-Figure-Reference-Variable-::.

Create Basic Figure Objects Except Figure
.........................................

The only difference here is that because the superclass Figure is now
abstract, it cannot be instantiated using 'new'.  It can, however, be
used as a reference variable, and so the declaration 'Figure figref;'
is still valid and does not change from the prior implementation.
*This is the essence of run-time polymorphism and dynamic method
dispatch.*

<Create Basic Figure Objects Except Figure > ==
     // abstract class Figure cannot be instantiated
     // Figure f = new Figure (10, 10);
     Rectangle r = new Rectangle (9, 5);
     Triangle t = new Triangle (10, 8);


This chunk is called by <AbstractAreas Main Method Declaration >; see
its first definition at *note
AbstractAreas-Main-Method-Declaration-::.

Call Overridden Methods One By One Except Figure
................................................

The only difference here is that, because there is no 'Figure' object,
it cannot be referenced.

<Call Overridden Methods One By One Except Figure > ==
     figref = r;
     System.out.println("Area is " + figref.area());

     figref = t;
     System.out.println("Area is " + figref.aread());

     // there is no Figure object, so this will not work.
     // figref = f;


This chunk is called by <AbstractAreas Main Method Declaration >; see
its first definition at *note
AbstractAreas-Main-Method-Declaration-::.


File: JavaSE9.info,  Node: final with Inheritance,  Next: Object Class,  Prev: Using Abstract Classes,  Up: Inheritance

4.8 Using 'final' with Inheritance
==================================

The keyword 'final' has three uses.

  1. create the equivalent of a name constant.
  2. prevent overriding
  3. prevent inheritance

* Menu:

* final to Prevent Overriding::
* final to Prevent Inheritance::


File: JavaSE9.info,  Node: final to Prevent Overriding,  Next: final to Prevent Inheritance,  Up: final with Inheritance

4.8.1 Using 'final' to Prevent Overriding
-----------------------------------------

There will be times when you want to prevent overriding from
occurring.  To disallow a method from being overridden, specify
'final' as a modifier at the start of its declaration.  Methods
declared as 'final' cannot be overridden.

   Methods declared as 'final' can sometimes provide a performance
enhancement.  The compiler is free to "inline" calls to them because
it knows they will not be overridden by a subclass.  Inlining is an
option only with 'final' methods.  Normally, Java resolves calls to
methods dynamically, at run time.  This is called "late binding".
However, since 'final' methods cannot be overridden, a call to one can
be resolved at compile time.  This is called "early binding".


File: JavaSE9.info,  Node: final to Prevent Inheritance,  Prev: final to Prevent Overriding,  Up: final with Inheritance

4.8.2 Using 'final' to Prevent Inheritance
------------------------------------------

Sometimes you will want to prevent a class from being inherited.  To
do this, precede the class declaration with 'final'.  Declaring a
class as 'final' implicitly declares all of its methods as 'final'
also.


File: JavaSE9.info,  Node: Object Class,  Prev: final with Inheritance,  Up: Inheritance

4.9 The Object Class
====================

There is one special class, 'Object', defined by Java.  All other
classes are subclasses of 'Object'.  That is, 'Object' is a superclass
of all other classes.  This means that a reference variable of type
'Object' can refer to an object of any other class.  Also, since
arrays are implemented as classes, a variable of type 'Object' can
also refer to any array.

'Object' Methods
================

'Object' defines the following methods; this means they are available
in every object.

'Object clone()'
     Creates a new object that is the same as the object being cloned.
'boolean equals(Object object)'
     Determines whether one object is equal to another.
'void finalize()'
     Called before an unused object is recycled.  (Deprecated by JDK
     9).
'Class<?> getClass()'
     Obtains the class of an object at run time.
'int hashCode()'
     Returns the hash code associated with the invoking object.
'void notify()'
     Resumes execution of a thread waiting on the invoking object.
'void notifyAll()'
     Resumes execution of all threads waiting on the invoking object.
'String toString()'
     Returns a string that describes the object.
'void wait()'
'void wait(long milliseconds)'
'void wait(long millisconds, int nanoseconds)'
     Waits on another thread of execution

   The methods
   * 'getClass()'
   * 'notify()'
   * 'notifyAll()'
   * 'wait()'

are declared as 'final'.  You may override the others.

   However, notice two methods now:

'equals()'
     compares two objects; returns 'true' if the objects are equal,
     and 'false' if not; the precise definition of equality can vary,
     depending on the type of objects being compared.
'toString()'
     returns a string that contains a description of the object on
     which it is called; this method is automatically called when an
     object is output using 'println()'; many classes override this
     method; doing so allows them to tailor a description specifically
     for the types of objects that they create.


File: JavaSE9.info,  Node: Packages,  Next: Interfaces,  Prev: Inheritance,  Up: Top

5 Packages
**********

Packages are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file
names.  Packages are stored in a hierarchical manner and are
explicitly imported into new class definitions.

* Menu:

* Packages Intro::
* Defining Packages::
* Classpath::
* Member Access::
* Importing::


File: JavaSE9.info,  Node: Packages Intro,  Next: Defining Packages,  Up: Packages

5.1 Introduction to Packages
============================

Java provides a mechanism for partitioning the class namespace into
manageble chunks: the "PACKAGE". The package is both a naming and a
visibility control mechanism.  In other words, you can use the package
mechanism to define classes inside a package that are not accessible
by code outside the package; and you can define class members that are
exposed only to other members of the same package.


File: JavaSE9.info,  Node: Defining Packages,  Next: Classpath,  Prev: Packages Intro,  Up: Packages

5.2 Defining Packages
=====================

To create a package ("define" a package), include the 'package'
command as the first statement in a Java source file.  Thereafter, any
classes declared within that file will belong to the specified
package.  The 'package' statement defines a namespace in which classes
are stored.  Without the 'package' statement, classes are put into the
'default' package (which has no name).

General Form of 'package' statement
-----------------------------------

     package pkg

GeneralForm 5.1: Package Statement -- General Form

pkg is the name of the package.  For example:

     package mypackage;

File System Directories
-----------------------

Java uses the file system directories to store packages.  Therefore,
the '.class' files for any classes you declare to be part of
'mypackage' must be stored in a directory called 'mypackage'.  The
directory name must match the package name exactly.

   More than one file can include the same 'package' statement.  The
'package' statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other
files from being part of that same package.  Most real-world packages
are spread across many files.

Hierarchy of Packages
---------------------

You can create a hierarch of packages.  To do so, separate each
package name form the one above it by use of a period.  The general
form of a multileveled package statement is:

     package pkg1[.pkg2[.pkg3]]

GeneralForm 5.2: Package Statement -- Multilevel Form

   A package hierarchy must be reflected in the file system of your
Java development system.  For example a package declared as:

     package a.b.c;

   needs to be stored in directory 'a/b/c'.

   Be sure to choose package names carefully; you cannot rename a
package without renaming the directory in which the classes are
stored.


File: JavaSE9.info,  Node: Classpath,  Next: Member Access,  Prev: Defining Packages,  Up: Packages

5.3 Finding Packages and CLASSPATH
==================================

Packages are mirrored by directories.  How does the Java run-time
system know where to look for packages?

'cwd'
     By default, the Java run-time system uses the currect working
     directory as its starting point.  Thus, if your package is in a
     subdirectory of the current directory, it will be found.
'CLASSPATH'
     You can specify a directory path or paths by setting the
     'CLASSPATH' environment variable.
'-classpath'
     You can use the '-classpath' option with 'java' and 'javac' to
     specify the path to your classes.
module path
     Beginning with JDK 9, a package can be part of a module, and thus
     found on the 'module path'.

Example Finding a Package
-------------------------

Consider the following package specification:

     package mypack;

   In order for programs to find 'mypack', the program can be executed
from a directory *immediadely above* 'mypack', or the 'CLASSPATH' must
be set to include the path to 'mypack' or the '-classpath' option must
specify the path to 'mypack' when the program is run via 'java'.

   When the second or third of the above options is used, the 'class
path' *must not include* 'mypack' itself.  It must simply specify the
'path' to just above 'mypack'.  For example, if the path to 'mypack'
is

     /MyPrograms/Java/mypack

   then the class path to 'mypack' is

     /MyPrograms/Java


File: JavaSE9.info,  Node: Member Access,  Next: Importing,  Prev: Classpath,  Up: Packages

5.4 Packages and Member Access
==============================

Packages add another dimension to access control.  Classes and
packages are both means of encapsulating and containing the name space
and scope of variables and methods.  _Packages_ act as containiners
for classes and other subordinate packages.  _Classes_ act as
containers for data and code.  The class is Java's smallest unit of
abstraction.  As it relates to the interplay between classes and
packages, Java addresses four categories of visibility for class
members:

   * Subclasses in the same package
   * Non-subclasses in the same package
   * Subclasses in different packages
   * Classes that are neither in the same package nor subclasses

   The three access modifiers

   * private
   * public
   * protected

   provide a variaty of ways to produce many levels of access required
by these categories.

Category                     Private     None        Protected   public
-----------------------------------------------------------------------------
Same Class                   Yes         Yes         Yes         Yes
Same package subclass        No          Yes         Yes         Yes
Same package non-subclass    No          Yes         Yes         Yes
Different package subclass   No          No          Yes         Yes
Different package            No          No          No          Yes
noni-subclass

Table 5.1: Package Access Table -- Shows all combinations of the
access control modifiers


File: JavaSE9.info,  Node: Importing,  Prev: Member Access,  Up: Packages

5.5 Importing Packages
======================

Java includes the 'import' statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be
referred to directly, using only its name.  The 'import' statement is
a convenience to the programmer and is not technically needed to write
a complete Java program.

   In a Java source file, 'import' statements occur immediately
following the 'package' statement (if one exists) and before any class
definitions.  This is the general form of the 'import' statement:

     import pkg1[.pkg2].(classname | *);

GeneralForm 5.3: Import Statement -- General Form

   Here, pkg1 is the name of a top-level package, and pkg2 is the name
of a subordinate package inside the outerpackage separated by a dot
(.).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit 'classname' or a star (*), which
indicates that the Java compiler should import the entire package.

     import java.util.Date;
     imort java.io.*;

   All of the standard Java SE classes included with Java begin with
the name 'java'.  The basic language functions are stored in a package
called 'java.lang'.  Normally, you have to import every package or
class that you want to use, but since Java is useless without much of
the functionality in 'java.lang', it is implicitly imported by the
compiler for all programs.  This is equivalent to the following line
being at the top of all your programs:

     import java.lang.*;

   The 'import' statement is _optional_.  Any place you use a class
name, you can use its _fully qualified name_, which includes its full
package hierarchy.

   When a package is imported, only those items within the package
declared as 'public' will be available to non-subclasses in the
importing code.


File: JavaSE9.info,  Node: Interfaces,  Next: I/O,  Prev: Packages,  Up: Top

6 Interfaces
************

Using the keyword 'interface', you can fully abstract a class'
interface from its implementation.  That is, using 'interface', you
can specify what a class must do, but not how to do it.  Interfaces
are syntactically similar to classes, but they lack instance
variables, and, as a general rule, their methods are declared without
any body.  Once it is defined, any number of classes can implement an
'interface'.  Also, one class can implement any number of interfaces.
To implement an interfce, a class must provide the complete set of
methods required by the interface.  Each class is free to determine
the details of its own implementation.  By providing the 'interface'
keyword, Java allws you to fully utilize the "one interface, multiple
methods" aspect of polymorphism.

   Interfaces are designed to support "dynamic method resolution" at
run time.  Normally, in order for a method to be called from one class
to another, both classes need to be present at compile time so the
Java compiler can check to ensure that the method signatures are
compatible.  This requirement by itself makes for a static and
nonextensible classing environment.  Inevitably in a system like this,
functionality gets pushed up higher and higher in the class hierarchy
so that the mechanisms will be available to more and more subclasses.
Interfaces are designed to avoid this problem.  _They disconnect the
definition of a method or set of methods from the inheritance
hierarchy._  Since interfaces are in a different hierarchy from
classes, it is possible for classes that are unrelated in terms of
class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.

* Menu:

* Defining Interfaces::
* Implementing Interfaces::
* Interface References::
* Partial Implementations::
* Nested Interfaces::
* Applying Interfaces::
* Variables in Interfaces::
* Extending Interfaces::
* Default Interface Methods::
* Interface Static Methods::
* Private Interface Methods::


File: JavaSE9.info,  Node: Defining Interfaces,  Next: Implementing Interfaces,  Up: Interfaces

6.1 Defining Interfaces
=======================

An interface is defined much like a class.  Here is a simplified
general form of an interface definition:

     access interface name {
       return-type method-name1(parameter-list);
       return-type method-name2(parameter-list);

       type final-varname1 = value
       type final-varname2 = value
       ...
       return-type method-nameN(parameter-list);
       type final-varnameN = value
     }

GeneralForm 6.1: Interface Definition -- Simplified General Form

   When no access modifier is included, then default access results,
and the interface is only available to other members of the package in
which it is declared.  When it is declared as 'public', the interface
can be used by code outside its package.  In this case, the interface
mst be the only public interface declared in the file, and the file
must have the same name as the interface.  The methods that are
declared have no bodies.  They end with a semicolon after the
parameter list.  They are, essentially, abstract methods.  Each class
that includes such an interface must implement all of the methods.

Variable Declarations inside Interfaces
---------------------------------------

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly 'final' and 'static', meaning they
cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly 'public'.


File: JavaSE9.info,  Node: Implementing Interfaces,  Next: Interface References,  Prev: Defining Interfaces,  Up: Interfaces

6.2 Implementing Interfaces
===========================

Once an interface has been defined, one or more classes can implement
that interface.  To implement an interface, include the 'implements'
clause in a class definition, and then create the methods required by
the interface.  The general form of a class that includes the
'implements' clause looks like this:

     class clasname [extends superclass] [implements interface [,interface...] {
       class-body
     }

GeneralForm 6.2: Class Implementing Interface -- General Form

   The methods that implement an interface must be declared 'public'.
The type signature of the implementing method must match exactly the
type signature specified in the 'interface' definition.

   It is both permissible and common for classes that implement
interfaces to define additional members of their own.


File: JavaSE9.info,  Node: Interface References,  Next: Partial Implementations,  Prev: Implementing Interfaces,  Up: Interfaces

6.3 Accessing Implementations Through Interface References
==========================================================

You can declare variables as object references that use an interface
rather than a class type.  Any instance of any class that implements
the declared interface can be referred to by such a variable.  When
you call a method through one of these references, the correct version
will be called based on the actual instance of the interface being
referred to.  This is one of the key features of interfaces.  The
method to be executed is looked up dynamically at run-time, allowing
classes to be created later than the code which calls methods on them.
The calling code can dispatch through an interface without having to
know anything about the "callee."  This process is similar to using a
superclass reference to access a subclass object.


File: JavaSE9.info,  Node: Partial Implementations,  Next: Nested Interfaces,  Prev: Interface References,  Up: Interfaces

6.4 Partial Implementations
===========================

If a class includes an interface but does not implement the methds
required by that interface, then that class must be declared as
'abstract'.  Any class that inherits the abstract class must implement
the interface or be declared 'abstract' itself.


File: JavaSE9.info,  Node: Nested Interfaces,  Next: Applying Interfaces,  Prev: Partial Implementations,  Up: Interfaces

6.5 Nested Interfaces
=====================

An interface can be declared a member of a class or another interface.
Such an interface is called a "member interface" or a "nested
interface".  A nested interface can be declared as 'public',
'private', or 'protected'.  This differs from a top-level interface,
which must either be declared as 'public' or use the default access
level.  When a nexted interface is used outside of its enclosing
scope, it must be qualified by the name of the class or interface of
which it is a member.  Thus, outside of the class or interface in
which a nested interface is declared, its name must be fully
qualified.


File: JavaSE9.info,  Node: Applying Interfaces,  Next: Variables in Interfaces,  Prev: Nested Interfaces,  Up: Interfaces

6.6 Applying Interfaces
=======================

See detailed example ...


File: JavaSE9.info,  Node: Variables in Interfaces,  Next: Extending Interfaces,  Prev: Applying Interfaces,  Up: Interfaces

6.7 Variables in Interfaces
===========================

You can use interfaces to import shared constants into multiple
classes by simply declaring an interface that contains variables that
are initialized to the desired values.  When you include that
interface in a class (when you "implement" the interface), all of
those variable names will be in scope as constants.  If an interface
contains no methods, then any class that includes such an interface
doesn't actually implement anything.  It is as if that class were
importing this constant fields into the class name space as 'final'
variables.


File: JavaSE9.info,  Node: Extending Interfaces,  Next: Default Interface Methods,  Prev: Variables in Interfaces,  Up: Interfaces

6.8 Interfaces Can Be Extended
==============================

One interface can inherit another by use of the keyword 'extends'.
The syntax is the same as for inheriting classes.  When a class
implements an interface that inherits another interface, it must
provide implementations for all methods required by the interface
inheritance chain.


File: JavaSE9.info,  Node: Default Interface Methods,  Next: Interface Static Methods,  Prev: Extending Interfaces,  Up: Interfaces

6.9 Default Interface Methods
=============================

Prior to JDK 8, an interface could not define any implementation
whatsoever.  This meant that for all previous versions of Java, the
methods specified by an interface were abstract, constaining no body.
This is the traditional form of an interface.  The release of JDK 8
changed this by adding a new capability to 'interface' called the
"default method".  A default method lets you define a default
implementation for an interface method.  It is possible for an
interface method to provide a body, rather than being abstract.

   A primary motivation for the default method was to provide a means
by which interfaces could be expanded without breaking existing code.
There must be implementations for all methods defined by an interface.
If a new method were added to a popular, widely used interface, then
the addition of that method would break existing code because no
implementation would be found for that new method.  The default method
solves this problem by supplying an implementation that willbe used if
no other implementation is explicitly provided.  Thus, the addition of
a default method will not cause preexisting code to break.

   Another motivation for the default method was the desire to specify
methods in an interface that are, essentially, optional, depending on
how the interface is used.

Interfaces Do No Maintain State and Cannot Be Created
-----------------------------------------------------

It is important to point out that the addition of default methods does
not change a key aspect of 'interface': its inability to maintain
state information.  An interface still cannot have instance variables,
for example.  Thus, *the defining difference between an interface and
a class is that a class can maintain state information, but an
interface cannot.*  Furthermore, it is still not possible to create an
instance of an interface by itself.  It must be implemented by a
class.


File: JavaSE9.info,  Node: Interface Static Methods,  Next: Private Interface Methods,  Prev: Default Interface Methods,  Up: Interfaces

6.10 Use Static Methods in an Interface
=======================================

Another capability added to interface by JDK 8 is the ability to
define one or more 'static' methods.  Like 'static' methods in a
class, a 'static' method defined by an interface can be called
independently of any object.  Thus, no implementation of the interface
is necessary, and no instance of the interface is required, in order
to call a 'static' method.  Instead, a 'static' method is called by
specifying the interface name, followed by a period, followed by the
method name.  Here is the general form:

     InterfaceName.staticMethodName

GeneralForm 6.3: Interface Static Method, Calling

   Notice that this is similar to the way that a 'static' method in a
class is called.  However, 'static' interface methods are not
inherited by either an implementing class or a subinterface.


File: JavaSE9.info,  Node: Private Interface Methods,  Prev: Interface Static Methods,  Up: Interfaces

6.11 Private Interface Methods
==============================

Beginning with JDK 9, an interface can include a private method.  A
private interface method can be called only by a default method or
another private method defined by the same interface.  Because a
private interface method is specified 'private', it cannot be used by
code outside the interface in which it is defined.  This restriction
includes subinterfaces because a private inteface method is not
inherited by a subinterface.

   The key benefit of a private interface method is that it lets two
or more default methods use a common piece of code, thus avoiding code
duplication.


File: JavaSE9.info,  Node: I/O,  Next: Miscellaneous Java Keywords,  Prev: Interfaces,  Up: Top

7 I/O
*****

This chapter introduces 'java.io', which supports Java's basic
input/output system, including file I/O. Support for I/O comes from
Java's core API libraries, not from language keywords.  In this
chapter the foundation of this subsystem is introduced so that you can
see how it fits into the larger context of the Java programming and
execution environment.  This chapter also looks at the
'try-with-resources' statement.

* Menu:

* I/O Basics::
* Reading Console Input::
* Writing Console Output::
* PrintWriter Class::
* Reading and Writing Files::
* Automatically Closing Files::


File: JavaSE9.info,  Node: I/O Basics,  Next: Reading Console Input,  Up: I/O

7.1 I/O Basics
==============

Most real applications of Java are not text-based, console programs.
Rather, they are either graphically oriented programs that rely on one
of Java's graphical user interface (GUI) frameworks, such as Swing,
the AWT, or JavaFX, for user interaction, or they are Web
applications.  Text-based console programs do not constitute an
important use for Java in the real world.  Java's support for console
I/O is limited and somewhat awkword to use.  Text-based console I/O is
just not that useful in real-world Java programming.

   Java does, however, provide strong, flexible support for I/O as it
relates to files and networks.  Java's I/O system is cohesive and
consistent.  A general overview of I/O is presented here.  A detailed
description is found in chapters describing the Java Library: *Note
Input/Output java.io:: and *Note NIO::.

* Menu:

* Streams::
* Byte Streams Character Streams::


File: JavaSE9.info,  Node: Streams,  Next: Byte Streams Character Streams,  Up: I/O Basics

7.1.1 Streams
-------------

Java programs perform I/O through streams.  A "stream" is an
abstraction that either produces or consumes information.  A stream is
linked to a physical device by the Java I/O system.  All streams
behave in the same manner, even if the actual physical device to which
they are linked differ.  Thus, the same I/O classes and methods can be
applied to different types of devices.  This means that an input
stream can abstract many different kinds of input; from a disk file, a
keyboard, or a network socket.  Likewise, an output stream may refer
to the console, a disk file, or a network connection.  Java implements
streams within class hierarchies defined in the 'java.io' package.


File: JavaSE9.info,  Node: Byte Streams Character Streams,  Prev: Streams,  Up: I/O Basics

7.1.2 Byte Streams and Character Streams
----------------------------------------

Java defines two types of streams:

   * byte streams
   * character streams

   "Byte streams" provide a convenient means for handling input and
output of bytes.  Byte streams are used when reading or writing binary
data.  "Character streams" provide a convenient means for handling
input and output of characters.  They use Unicode and therefore can be
internationalized.  In some cases, character streams are more
efficient than byte streams.

   The original version of Java (Java 1.0) did not include character
streams and thus all I/O was byte-oriented.  Character streams were
added by Java 1.1 and certain byte-oriented classes and methods were
deprecated.

   At the lowest level, all I/O is still byte-oriented.  The
character-based streams simply provide a convenient and efficient
means for handling characters.

* Menu:

* Byte Stream Class::
* Character Stream Class::
* Predefined Streams::


File: JavaSE9.info,  Node: Byte Stream Class,  Next: Character Stream Class,  Up: Byte Streams Character Streams

7.1.2.1 The Byte Stream Class
.............................

Byte streams are defined by using two class hierarchies.  At the top
are two abstract classes:

   * 'InputStream'
   * 'OutputStream'

   Each of these abstract classes has several concrete subclasses that
handle the differences among various devices, such as disk files,
network connnections, and memory buffers.  The byte stream classes in
'java.io' are shown in *note Table 7.1: ByteStreamClasses.

   To use the stream classes, you must import 'java.io'.

'BufferedInputStream'
'BufferedOutputStream'
     Buffered input and output streams
'ByteArrayInputStream'
'ByteArrayOutputStream'
     Input and Output streams that read from and write to a byte array
'DataInputStream'
'DataOutputStream'
     Input and Output streams that contain methods for reading and
     writing the Java standard data types
'FileInputStream'
'FileOutputStream'
     Input and Output streams that read from and write to a file
'FilterInputStream'
'FilterOutputStream'
     Implements 'InputStream' and 'OutputStream'
'InputStream'
'OutputStream'
     Abstract classes that describe stream input and output
'ObjectInputStream'
'ObjectOutputStream'
     Input and Output streams for objects
'PipedInputStream'
'PipedOutputStream'
     Input and Output pipe
'PrintStream'
     Output stream that contains 'print()' and 'println()'
'PushbackInputStream'
     Input stream that allows bytes to be returned to the input stream
'SequenceInputStream'
     Input stream that is a combination of two or more input streams
     that will be read sequentially, one after the other

Table 7.1: The Byte Stream Classes in 'java.io'

   The abstract classes 'InputStream' and 'OutputStream' define
several key methods that the other stream classes implement.  Two of
the most important are:

   * 'read()'
   * 'write()'

which respectively read and write bytes of data.  Each has a form that
is abstract and must be overridden by derived stream classes.


File: JavaSE9.info,  Node: Character Stream Class,  Next: Predefined Streams,  Prev: Byte Stream Class,  Up: Byte Streams Character Streams

7.1.2.2 The Character Stream Class
..................................

Character streams are defined by using two class hierarchies.  At the
top are two abstract classes:

   * 'Reader'
   * 'Writer'.

   These abstract classes handle Unicode character streams.  Java has
several concrete subclasses of these.  The character stream classes in
'java.io' are shown in *note Table 7.2: CharacterStreamClasses.

'BufferedReader'
'BufferedWriter'
     Buffered input and output character streams
'CharArrayReader'
'CharArrayWriter'
     Input and Output streams that read and write to and from a
     character array
'FileReader'
'FileWriter'
     Input and Output streams that read from and write to a file
'FilterReader'
'FilterWriter'
     Filtered read and writer
'InputStreamReader'
'OutputStreamWriter'
     Input and Output streams that translate bytes to characters
'LineNumberReader'
     Input stream that counts lines
'PipedReader'
'PipedWriter'
     Input and Output pipes
'PrintWriter'
     Output stream that contains 'print()' and 'println()'
'PushbackReader'
     Input stream that allows characters to be return to the input
     stream
'Reader'
'Writer'
     Abstract clases tha describe character stream input and output
'StringReader'
'StringWriter'
     Input and output streams that read from and write to a string

Table 7.2: The Character Stream I/O Classes in 'java.io'

   The abstract classes 'Reader' and 'Writer' define several key
methods that the other stream classes implement.  Two of the most
important methods are:

   * 'read()'
   * 'write()'

which read and write characters of data, respectively.  Each has a
form that is abstract and must be overridden by derived stream
classes.


File: JavaSE9.info,  Node: Predefined Streams,  Prev: Character Stream Class,  Up: Byte Streams Character Streams

7.1.2.3 The Predefined Streams
..............................

The 'java.lang' package defines a class called 'System', which
encapsulates several aspects of the run-time environment.  System
contains three predefined stream variables:

  1. 'in' (standard input), an object of type 'InputStream'
  2. 'out' (standard output), an object of type 'PrintStream'
  3. 'err' (standard error), an object of type 'PrintStream'

These fields are declared as 'public', 'static', and 'final' within
'System'.  This means that they can be used by any other part of your
program and without reference to a specific 'System' object.  While
these are all byte streams, they can be wrapped within character-based
streams, if desired.


File: JavaSE9.info,  Node: Reading Console Input,  Next: Writing Console Output,  Prev: I/O Basics,  Up: I/O

7.2 Reading Console Input
=========================

For commercial applications, the preferred method of reading console
input is to use a character-oriented stream.  This makes your program
easier to internationalize and maintain.

'System.in' Wrapped in 'BufferedReader'
---------------------------------------

Console input is accomplished by reading from 'System.in' To obtain a
character-based stream that is attached to the console, wrap
'System.in' in a 'BufferedReader' object.  'BufferedReader' supports a
buffered input stream.  A commonly-used constructor is:

     BufferedReader(Reader inputReader)

Here, inputReader is the stream that is linked to the instance of
'BufferedReader' that is being created.  'Reader' is the abstract
class.  One of its concrete subclasses is 'InputStreamReader', which
converts bytes to characters.  To obtain a 'InputStreamReader' object
that is linked to 'System.in', use the following constructor:

     InputStreamReader(InputStream inputStream)

   Because 'System.in' refers to an object of type 'InputStream', it
can be used for inputStream.  Putting it all together, the following
line of code creates a 'BufferedReader' that is connected to the
keyboard:

     BufferedReader br = new BufferedReader(
       new InputStreamReader(System.in));

After this statement executes, 'br' is a character-based stream that
is linked to the console through 'System.in'.

* Menu:

* Reading Characters::
* Reading Strings::


File: JavaSE9.info,  Node: Reading Characters,  Next: Reading Strings,  Up: Reading Console Input

7.2.1 Reading Characters
------------------------

To read a character from a 'BufferedReader', use 'read()'.  The
version of 'read()' that we will be using is

     int read() throws IOException

Each time that 'read()' is called, it reads a character from the input
stream and returns it as an integer value.  (1) It returns -1 when an
attempt is made to read at the end of the stream.  It can throw an
'IOException'.

Program Demonstrating Reading Characters from Console
.....................................................

The following program demonstrates 'read()' by reading characters from
the console until the user types a "q".  Any I/O exceptions that might
be generated are simply thrown out of 'main()'.  In more sophisticated
applications, you can handle the exceptions explicitly.

{'BRRead.java'} ==
     <Import java.io>
     class BRRead {
       public static void main(String[] args[]) throws IOException {
         <BRRead BufferedReader Constructor>
         <BRRead Enter Characters>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BRRead BufferedReader    See
Constructor>              *note BRRead-BufferedReader-Constructor::.
<BRRead Enter             See *note BRRead-Enter-Characters::.
Characters>
<Import java.io>          See *note Import-java-io::.

* Menu:

* Import java.io::
* BRRead BufferedReader Constructor Node::
* BRRead Enter Characters Node::

   ---------- Footnotes ----------

   (1) Note that 'System.in' is line buffered by default; this means
that no input is actually passed to the program until the user presses
<enter>.  This does not make 'file' particularly valuable for
interactive console input.


File: JavaSE9.info,  Node: Import java.io,  Next: BRRead BufferedReader Constructor Node,  Up: Reading Characters

7.2.1.1 Import 'java.io'
........................

<Import java.io> ==
     import java.io.*;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'BRRead.java'}           See *note BRRead-java::.
{'BRReadLines.java'}      See *note BRReadLines-java::.
{'BufferedInputStreamDemo.java'}See *note BufferedInputStreamDemo-java::.
{'BufferedReaderDemo.java'}See *note BufferedReaderDemo-java::.
{'CopyFile.java'}         See *note CopyFile-java::.
{'CopyFileMultTryWR.java'}See *note CopyFileMultTryWR-java::.
{'DirListOnly'}           See *note DirListOnly::.
{'FileReaderDemo.java'}   See *note FileReaderDemo-java::.
{'OnlyExt.java'}          See *note OnlyExt-java::.
{'PrinterWriterDemo.java'}See *note PrinterWriterDemo-java::.
{'ShowFile.java'}         See *note ShowFile-java::.
{'ShowFileAlt.java'}      See *note ShowFileAlt-java::.
{'ShowFileSingleTry'}     See *note ShowFileSingleTry::.
{'ShowFileTryWR.java'}    See *note ShowFileTryWR-java::.


File: JavaSE9.info,  Node: BRRead BufferedReader Constructor Node,  Next: BRRead Enter Characters Node,  Prev: Import java.io,  Up: Reading Characters

7.2.1.2 BRRead BufferedReader Constructor Section
.................................................

<BRRead BufferedReader Constructor> ==
     BufferedReader br = new BufferedReader(
       new InputStreamReader(System.in));


This chunk is called by {'BRRead.java'}; see its first definition at
*note BRRead-java::.


File: JavaSE9.info,  Node: BRRead Enter Characters Node,  Prev: BRRead BufferedReader Constructor Node,  Up: Reading Characters

7.2.1.3 BRRead Enter Characters Section
.......................................

<BRRead Enter Characters> ==
     char c;
     do {
       c = (char) br.read();
       System.out.println(c);
     } while (c != 'q');


This chunk is called by {'BRRead.java'}; see its first definition at
*note BRRead-java::.


File: JavaSE9.info,  Node: Reading Strings,  Prev: Reading Characters,  Up: Reading Console Input

7.2.2 Reading Strings
---------------------

To read a string frmo the keyboard, use the version of 'readLine()'
that is a member of the 'BufferedReader' class.  Its general form is:

     String readLine() throws IOException

It returns a 'String' object.

Program Demonstrating Reading a String from Console
...................................................

The following program demonstrates 'BufferedReader' and the
'readLine()' method; the program reas and displays lines of text until
the word "stop" is entered.

{'BRReadLines.java'} ==
     <Import java.io>

     class BRReadLines {
       public static void main(String[] args) throws IOException {
         <BRReadLines BufferedReader Constructor>
         <BRReadLines Enter Lines>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BRReadLines              See
BufferedReader            *note BRReadLines-BufferedReader-Constructor::.
Constructor>
<BRReadLines Enter        See *note BRReadLines-Enter-Lines::.
Lines>
<Import java.io>          See *note Import-java-io::.

* Menu:

* BRReadLines BufferedReader Constructor::
* BRReadLines Enter Lines::


File: JavaSE9.info,  Node: BRReadLines BufferedReader Constructor,  Next: BRReadLines Enter Lines,  Up: Reading Strings

7.2.2.1 BRReadLines BufferedReader Constructor
..............................................

<BRReadLines BufferedReader Constructor> ==
     // create a BufferedReader using System.in
     BufferedReader br = new BufferedReader(
       new InputStreamReader(System.in))


This chunk is called by {'BRReadLines.java'}; see its first definition
at *note BRReadLines-java::.


File: JavaSE9.info,  Node: BRReadLines Enter Lines,  Prev: BRReadLines BufferedReader Constructor,  Up: Reading Strings

7.2.2.2 BRReadLines Enter Lines
...............................

<BRReadLines Enter Lines> ==
     String str;

     System.out.println("Enter lines of text.");
     System.out.println("Enter 'stop' to quit.");

     do {
       str = br.readLine();
       System.out.println(str);

     } while (!str.equals("stop"));


This chunk is called by {'BRReadLines.java'}; see its first definition
at *note BRReadLines-java::.


File: JavaSE9.info,  Node: Writing Console Output,  Next: PrintWriter Class,  Prev: Reading Console Input,  Up: I/O

7.3 Writing Console Output
==========================

The methods

   * 'print()'
   * 'println()'

are defined by the class 'PrintStream' (which is the type of object
referenced by 'System.out').  Remember, 'System.out' is a byte stream,
but is acceptable for simple program output.  A character-based
alternative is described in the next section.

   Because 'PrintStream' is an output stream (type byte) derived from
'OutputStream' (an abstract byte stream class), it also implements the
low-level method 'write()'.  Thus, 'write()' can be used to write to
the console.  The simplest form of 'write()' defined by 'PrintStream'
is here:

     void write(int byteval)

   This method writes the byte specified by byteval.  Although byteval
is declared as in integer, only the low-order eight bits are written.

   Here is a short example that uses 'write()' to output the character
"A" followed by a newline to the screen:

     //Demonstrate System.out.write()
     class WriteDemo {
       public static void main (String[] args) {
         int b;
         b = 'A';
         System.out.write(b);
         System.out.write('\n');
       }
     }


File: JavaSE9.info,  Node: PrintWriter Class,  Next: Reading and Writing Files,  Prev: Writing Console Output,  Up: I/O

7.4 The PrintWriter Class
=========================

Using 'System.out' to write to the console is probably best for
debugging purposes or for sample programs.  For real-world programs,
the recommended method of writing to the console when using Java is
through a 'PrintWriter' stream.  'PrintWriter' is one of the
character-based classes.  User a character-based class for console
output makes internationalizing your program easier.

* Menu:

* PrinterWriter Constructors::
* Demonstration Using PrintWriter::
* PrintWriter Concluding Comments::


File: JavaSE9.info,  Node: PrinterWriter Constructors,  Next: Demonstration Using PrintWriter,  Up: PrintWriter Class

7.4.1 'PrintWriter' Constructors
--------------------------------

'PrintWriter' defines several constructors.  Here is one:

     PrintWriter(OutputStream outStream, boolean flusingOn)

   outputStream is an object of type 'OutputStream', and flushingOn
controls whether Java flushes the output stream every time a 'println'
method is called.  If flushingOn is 'true', flushing automatically
takes place.  If 'false', flushing is not automatic.

   'PrintWriter' supports 'print()' and 'println()' methods.  You can
use these methods in the same way you used them with 'System.out'.  If
an argument is not a simple type, the 'PrintWriter' methods call the
object's 'toString()' method and then display the result.

Writing to the Console with a 'PrintWriter'
-------------------------------------------

To write to the console by using a 'PrintWriter', specify 'System.out'
for the output stream and automatic flushing.

     PrintWriter pw = new PrintWriter(System.out, true);


File: JavaSE9.info,  Node: Demonstration Using PrintWriter,  Next: PrintWriter Concluding Comments,  Prev: PrinterWriter Constructors,  Up: PrintWriter Class

7.4.2 Demonstration Using a 'PrintWriter' for Console Output
------------------------------------------------------------

{'PrinterWriterDemo.java'} ==
     <Import java.io>

     public class PrintWriterDemo {
       public static void main (String[] args) {
         <PrintWriterDemo PrintWriter Constructor>
         <PrintWriterDemo Printing To Console>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Import java.io>          See *note Import-java-io::.
<PrintWriterDemo          See
PrintWriter               *note PrintWriterDemo-PrintWriter-Constructor::.
Constructor>
<PrintWriterDemo          See
Printing To Console>      *note PrintWriterDemo-Printing-To-Console::.

* Menu:

* PrintWriterDemo PrintWriter Constructor::
* PrintWriterDemo Printing To Console::


File: JavaSE9.info,  Node: PrintWriterDemo PrintWriter Constructor,  Next: PrintWriterDemo Printing To Console,  Up: Demonstration Using PrintWriter

7.4.2.1 PrintWriterDemo PrintWriter Constructor
...............................................

<PrintWriterDemo PrintWriter Constructor> ==
     PrintWriter pw = new PrintWriter (System.out, true);


This chunk is called by {'PrinterWriterDemo.java'}; see its first
definition at *note PrinterWriterDemo-java::.


File: JavaSE9.info,  Node: PrintWriterDemo Printing To Console,  Prev: PrintWriterDemo PrintWriter Constructor,  Up: Demonstration Using PrintWriter

7.4.2.2 PrintWriterDemo Printing To Console
...........................................

<PrintWriterDemo Printing To Console> ==
     pw.println("This is a string");
     int i = -7;
     pw.println(i);
     double d = 4.5e-7;
     pw.println(d);


This chunk is called by {'PrinterWriterDemo.java'}; see its first
definition at *note PrinterWriterDemo-java::.


File: JavaSE9.info,  Node: PrintWriter Concluding Comments,  Prev: Demonstration Using PrintWriter,  Up: PrintWriter Class

7.4.3 'PrintWriter' Concluding Comments
---------------------------------------

There is nothing wrong with using 'System.out' to write simple text
output to the console.  Using a 'PrintWriter' makes your real-world
applications easier to internationalize.  There is no other adavantage
gained by using a 'PrintWriter' in the simple programs, however.


File: JavaSE9.info,  Node: Reading and Writing Files,  Next: Automatically Closing Files,  Prev: PrintWriter Class,  Up: I/O

7.5 Reading and Writing Files
=============================

Java provides a number of classes and methods that allow you to read
and write files.  The purpose of this section is to introduce the
basic techniques that read from and write to a file.  Although byte
streams are used, these techniques can be adapted to the
character-based streams.

   .....................................

* Menu:

* FileInputStream and FileOutputStream::
* Demonstration Reading From a File::
* Demonstration Reading From File with Single try::
* Demonstration Writing to a File::


File: JavaSE9.info,  Node: FileInputStream and FileOutputStream,  Next: Demonstration Reading From a File,  Up: Reading and Writing Files

7.5.1 'FileInputStream' and 'FileOutputStream'
----------------------------------------------

Two of the most often-used stream classes are:

   * 'FileInputStream'
   * 'FileOutputStream'

which create byte streams linked to files.

Open a File
-----------

To open a file, create an object of one of these clases, specifying
the name of the file as an argument to the constructor.  We will use
the following constructors:

     FileInputStream(String fileName) throws FileNotFoundException
     FileOutputStream(String fileName) throws FileNotFoundException

   Note that when an output file is opened, any preexisting file by
the same name is destroyed.

Close a File
------------

When you are done with a file, you must close it.  This is done by
calling the 'close()' method, which is implemented by both
'FileInputStream' and 'FileOutputStream'.

     void close() throws IOException

Closing a file releases the system resources allocated to the file.
Failure to close a file can result in "memory leaks" because of unused
resources remaining allocated.

'AutoClosable Interface'
------------------------

Beginning with JDK 7, the 'close()' method is specified by the
'AutoCloseable' interface in 'java.lang'.  'AutoCloseable' is
inherited by the 'Closable' interface in 'java.io'.  Both interfaces
are implemented by the stream classes, including 'FileInputStream' and
'FileOutputStream'.

Try With Resources
------------------

There are two basic approaches you can use to close a file.  The first
is the traditional approach, in which 'close()' is called explicitly
when the file is no longer needed.  This is the approach used by all
versions of Java prior to JDK 7.

   The second is to use the 'try-with-resources' statement added by
JDK 7, which automatically closes a file when it is no longer needed.
In this approach, no explicit call to 'close()' is executed.

Reading From A File
-------------------

To read from a file, you can use a version of 'read()' that is defined
within 'FileInputStream'.

     int read() throws IOException

Each time that it is called, it reads a single byte from the file and
returns the byte as an integer value.  'read()' returns -1 when an
attempt is made to read at the end of the stream.

Writing to a File
-----------------

To write to a file, you can use the 'write()' method defined by
'FileOutputStream'.  Its simplest form is:

     void write(int byteval throws IOException

   This method writes the byte specified by byteval to the file.
Although byteval is declared as an integer, only the low-order eight
bits are written to th file.


File: JavaSE9.info,  Node: Demonstration Reading From a File,  Next: Demonstration Reading From File with Single try,  Prev: FileInputStream and FileOutputStream,  Up: Reading and Writing Files

7.5.2 Demonstration Reading From a File
---------------------------------------

The following program uses 'read()' to input and display the contents
of a file that contains ASCII test.  The name of the file is specified
as a command-line argument.

{'ShowFile.java'} ==
     <ShowFile Initial Comments>
     <Import java.io>
     class ShowFile {
       public static void main (String[] args) {
         <ShowFile Instance Variable Declarations>
         <ShowFile Open a File>
         <ShowFile Read a File>
         <ShowFile Close a File>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Import java.io>          See *note Import-java-io::.
<ShowFile Close a File>   See *note ShowFile-Close-a-File::.
<ShowFile Initial         See *note ShowFile-Initial-Comments::.
Comments>
<ShowFile Instance        See
Variable Declarations>    *note ShowFile-Instance-Variable-Declarations::.
<ShowFile Open a File>    See *note ShowFile-Open-a-File::.
<ShowFile Read a File>    See *note ShowFile-Read-a-File::.

* Menu:

* ShowFile Initial Comments::
* ShowFile Instance Variable Declarations::
* ShowFile Open a File::
* ShowFile Read a File::
* ShowFile Close a File::
* close() Within finally::


File: JavaSE9.info,  Node: ShowFile Initial Comments,  Next: ShowFile Instance Variable Declarations,  Up: Demonstration Reading From a File

7.5.2.1 ShowFile Initial Comments
.................................

<ShowFile Initial Comments> ==
     /* Display a text file.
        To use this program, specify the name
        of the file that you want to see.
        For example, to see a file called TEST.TXT,
        use the following command line:

        java ShowFile TEST.TXT
      */


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'ShowFile.java'}         See *note ShowFile-java::.
{'ShowFileAlt.java'}      See *note ShowFileAlt-java::.
{'ShowFileSingleTry'}     See *note ShowFileSingleTry::.


File: JavaSE9.info,  Node: ShowFile Instance Variable Declarations,  Next: ShowFile Open a File,  Prev: ShowFile Initial Comments,  Up: Demonstration Reading From a File

7.5.2.2 ShowFile Instance Variable Declarations
...............................................

<ShowFile Instance Variable Declarations> ==
     int i;
     FileInputstream fin;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'ShowFile.java'}         See *note ShowFile-java::.
{'ShowFileAlt.java'}      See *note ShowFileAlt-java::.
{'ShowFileSingleTry'}     See *note ShowFileSingleTry::.


File: JavaSE9.info,  Node: ShowFile Open a File,  Next: ShowFile Read a File,  Prev: ShowFile Instance Variable Declarations,  Up: Demonstration Reading From a File

7.5.2.3 ShowFile Open a File
............................

Notice all of the 'try/catch' blocks that handle the I/O errors that
might occur.  Each I/O operation is monitored for exceptions, and if
an exception occurs, it is handled.

<ShowFile Open a File> ==
     // First, confirm that a filename has been specified.
     if (args.length != 1) {
       System.out.printli("Usage: ShowFile filename");
       return;
     }

     // Attempt to open the file
     try {
       fin = new FileInputStream(args[0]);
     } catch (FileNotFoundException e) {
       System.out.println("Cannot Open File");
       return;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'ShowFile.java'}         See *note ShowFile-java::.
{'ShowFileAlt.java'}      See *note ShowFileAlt-java::.
{'ShowFileSingleTry'}     See *note ShowFileSingleTry::.


File: JavaSE9.info,  Node: ShowFile Read a File,  Next: ShowFile Close a File,  Prev: ShowFile Open a File,  Up: Demonstration Reading From a File

7.5.2.4 ShowFile Read a File
............................

<ShowFile Read a File> ==
     // At this point, the file is open and can be read.
     // The following reads characters until EOF is encountered.
     try {
       do {
         i = fin.read();
         if (i != -1) System.out.print ((char) i);
       } while (i != -1);
     } catch (IOException e) {
       System.out.println("Error Reading File");
     }


This chunk is called by {'ShowFile.java'}; see its first definition at
*note ShowFile-java::.


File: JavaSE9.info,  Node: ShowFile Close a File,  Next: close() Within finally,  Prev: ShowFile Read a File,  Up: Demonstration Reading From a File

7.5.2.5 ShowFile Close a File
.............................

<ShowFile Close a File> ==
     // Close the file
     try {
       fin.close();
     } catch (IOException e) {
       System.out.println("Error Closing File");
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'ShowFile.java'}         See *note ShowFile-java::.
{'ShowFileAlt.java'}      See *note ShowFileAlt-java::.


File: JavaSE9.info,  Node: close() Within finally,  Prev: ShowFile Close a File,  Up: Demonstration Reading From a File

7.5.2.6 'close()' Within 'finally' Block
........................................

Although the preceding example closes the file stream after the file
is read, there is a variation that is often useful.  The variation is
to call 'close()' within a 'finally' block.  In this approach, all of
the methods that access the file are contained within a 'try' block,
and the 'finally' block is used to close the file.  This way, no
matter how the 'try' block terminates, the file is closed.

   One advantage tothis approach in general is that if the code that
accesses a file terminates because of some non-I/O related exception,
the file is still closed by the 'finally' block.

   Here is how the 'try' block that reads the file can be recode:

{'ShowFileAlt.java'} ==
     <ShowFile Initial Comments>
     <Import java.io>
     class ShowFileAlt {
       public static void main (String[] args) {
         <ShowFile Instance Variable Declarations>
         <ShowFile Open a File>
         <ShowFileAlt Read a File>
         <ShowFile Close a File>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Import java.io>          See *note Import-java-io::.
<ShowFile Close a File>   See *note ShowFile-Close-a-File::.
<ShowFile Initial         See *note ShowFile-Initial-Comments::.
Comments>
<ShowFile Instance        See
Variable Declarations>    *note ShowFile-Instance-Variable-Declarations::.
<ShowFile Open a File>    See *note ShowFile-Open-a-File::.
<ShowFileAlt Read a       See *note ShowFileAlt-Read-a-File::.
File>

ShowFileAlt Read a File
.......................

<ShowFileAlt Read a File> ==
     try {
       do {
         i = fin.read();
         if (i != -1) System.out.print ((char) i);
       } while (i != -1);
     } catch (IOException e) {
       System.out.println("Error Reading File.");
     } finally {
       // Close the file on the way out of the block.
       try {
         fin.close();
       } catch (IOException e) {
         System.out.println ("Error Closing File.");
       }
     }


This chunk is called by {'ShowFileAlt.java'}; see its first definition
at *note ShowFileAlt-java::.


File: JavaSE9.info,  Node: Demonstration Reading From File with Single try,  Next: Demonstration Writing to a File,  Prev: Demonstration Reading From a File,  Up: Reading and Writing Files

7.5.3 Demonstration Reading From a File with a Single 'try' Block
-----------------------------------------------------------------

Sometimes it's easier to wrap the portions of a program that open a
file and access the file within a single 'try' block (rather than
separating the two) and then use a 'finally' block to close the file.

   Here is another way to write the 'ShowFile' program:

{'ShowFileSingleTry'} ==
     <ShowFile Initial Comments>
     <ShowFileSingleTry Additional Initial Comment>
     <Import java.io>
     class ShowFileSingleTry {
       public static void main (String[] args) {
         <ShowFile Instance Variable Declarations>
         <ShowFile Open a File>
         <ShowFileSingleTry Read a File>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Import java.io>          See *note Import-java-io::.
<ShowFile Initial         See *note ShowFile-Initial-Comments::.
Comments>
<ShowFile Instance        See
Variable Declarations>    *note ShowFile-Instance-Variable-Declarations::.
<ShowFile Open a File>    See *note ShowFile-Open-a-File::.
<ShowFileSingleTry        See
Additional Initial        *note ShowFileSingleTry-Additional-Initial-Comment::.
Comment>
<ShowFileSingleTry Read   See *note ShowFileSingleTry-Read-a-File::.
a File>

* Menu:

* ShowFileSingleTry Additional Initial Comment::
* ShowFileSingleTry Read a File::


File: JavaSE9.info,  Node: ShowFileSingleTry Additional Initial Comment,  Next: ShowFileSingleTry Read a File,  Up: Demonstration Reading From File with Single try

7.5.3.1 ShowFile SingleTry Additional Initial Comment
.....................................................

<ShowFileSingleTry Additional Initial Comment> ==
     /* This variation wraps the code that opens and
        accesses the file within a single try block.
        The file is closed by the finally block.
      */


This chunk is called by {'ShowFileSingleTry'}; see its first
definition at *note ShowFileSingleTry::.


File: JavaSE9.info,  Node: ShowFileSingleTry Read a File,  Prev: ShowFileSingleTry Additional Initial Comment,  Up: Demonstration Reading From File with Single try

7.5.3.2 ShowFileSingleTry Read a File
.....................................

In this approach, 'fin' is initialized to 'null'.  In the 'finally'
block, the file is closed only if 'fin' is not 'null'.  This works
because 'fin' will be non-'null' only if the file is successfully
opened.  Thus, 'close()' is not called if an exception occurrs while
opening the file.

<ShowFileSingleTry Read a File> ==
     // The following code opens a file, reads characters until EOF
     // is encountered, and then closes the file via a finally block.

     try {
       fin = new FileInputStream(args[0]);

       do {
         i = fin.read();
         if (i != -1) System.out.print((char) i);
       } while (i != -1);

     } catch (FileNotFoundException e) {
       System.out.println("File Not Found.");

     } catch (IOException e) {
       System.out.println("An I/O Error Occurred");

     } finally {
       // Close file in all cases
       try {
         if (fin != null) fin.close();
       } catch (IOException e) {
         System.out.println("Error Clsoing File");
       }
     }


This chunk is called by {'ShowFileSingleTry'}; see its first
definition at *note ShowFileSingleTry::.

More Compact Catch Code
.......................

It is possible to make the 'try/catch' sequence a bit more compact.
Because 'FileNotFoundException' is a subclass of 'IOException', it
need not be caught separately.  Here is the sequence recoded to
eliminate catching 'FileNotFoundException'.  In this case, the
standard exception message, which describes the error, is displayed.

     } catch (IOException e) {
       System.out.println("I/O Error: " + e);
     } finally {
       try {
         if (fin != null) fin.close();
       } catch (IOException e) {
         System.out.println("Error Closing File");
       }
     }

   In this approach, any error, including an error opening the file,
is simply handled by the single 'catch' statement.  This approach may
not be appropriate in cases in which you want to deal separately with
a failure to open a file, such as might be caused by a mis-typed
filename.  In such a situation, you might want to prompt for the
correct name before entering a 'try' block that accesses the file.

   The next example uses 'write()' to copy a file.


File: JavaSE9.info,  Node: Demonstration Writing to a File,  Prev: Demonstration Reading From File with Single try,  Up: Reading and Writing Files

7.5.4 Demonstration Writing to a File
-------------------------------------

This example uses 'write()' to copy a file.

   Notice that all potential I/O errors are handled in the programs by
the use of exceptions.  This differs from some computer languages that
use error codes to report file errors.  They enable Java to easily
differentiate the end-of-file condition from file errors when input is
being performed.

{'CopyFile.java'} ==
     <CopyFile Initial Comments>
     <Import java.io>
     class CopyFile {
       public static void main (String[] args) {
         <CopyFile Instance Variable Declarations>
         <CopyFile Check For 2 Files>
         <CopyFile Copy a File>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<CopyFile Check For 2     See *note CopyFile-Check-For-2-Files::.
Files>
<CopyFile Copy a File>    See *note CopyFile-Copy-a-File::.
<CopyFile Initial         See *note CopyFile-Initial-Comments::.
Comments>
<CopyFile Instance        See
Variable Declarations>    *note CopyFile-Instance-Variable-Declarations::.
<Import java.io>          See *note Import-java-io::.

* Menu:

* CopyFile Initial Comments::
* CopyFile Instance Variable Declarations::
* CopyFile Check for 2 Files::
* CopyFile Copy a File::


File: JavaSE9.info,  Node: CopyFile Initial Comments,  Next: CopyFile Instance Variable Declarations,  Up: Demonstration Writing to a File

7.5.4.1 CopyFile Initial Comments
.................................

<CopyFile Initial Comments> ==
     /* Copy a file
        To use this program, specify the name
        of the source file and the destination file.
        For example, to copy a file called FIRST.TXT
        to a file called SECOND.TXT, use the following
        command line.

        java CopyFile FIRST.TXT SECOND.TXT
      */


This chunk is called by {'CopyFile.java'}; see its first definition at
*note CopyFile-java::.


File: JavaSE9.info,  Node: CopyFile Instance Variable Declarations,  Next: CopyFile Check for 2 Files,  Prev: CopyFile Initial Comments,  Up: Demonstration Writing to a File

7.5.4.2 CopyFile Instance Variable Declarations
...............................................

<CopyFile Instance Variable Declarations> ==
     int i;
     FileInputStream fin = null;
     FileOutputStream fout = null;


This chunk is called by {'CopyFile.java'}; see its first definition at
*note CopyFile-java::.


File: JavaSE9.info,  Node: CopyFile Check for 2 Files,  Next: CopyFile Copy a File,  Prev: CopyFile Instance Variable Declarations,  Up: Demonstration Writing to a File

7.5.4.3 CopyFile Check for 2 Files
..................................

<CopyFile Check For 2 Files> ==
     // First, confirm that both files have been specified
     if (args.length != 2) {
       System.out.println("Usage: CopyFile from to");
       return;
     }


This chunk is called by {'CopyFile.java'}; see its first definition at
*note CopyFile-java::.


File: JavaSE9.info,  Node: CopyFile Copy a File,  Prev: CopyFile Check for 2 Files,  Up: Demonstration Writing to a File

7.5.4.4 CopyFile Copy a File
............................

Notice that there are two separate 'try' blocks used when closing the
files.  This ensures that both files are closed, even if the call to
'fin.close()' throws an exception.

<CopyFile Copy a File> ==
     // Copy a file
     try {
       // Attempt to open the files
       fin = new FileInputStream(args[0]);
       fout = new FileOutputStream(args[1]);

       do {
         i = fin.read();
         if (i != -1) fout.write(i);
       } while (i != -1);

     } catch (IOException e) {
       System.out.println("I/O Error: " + e);

     } finally {
       try {
         if (fin != null) fin.close();
       } catch (IOException e2) {
         System.out.println("Error Closing Input File");
       }

       try {
         if (fout != null) fout.close();
       } catch (IOException e2) {
         System.out.println("Error Closing Output File");
       }
     }


This chunk is called by {'CopyFile.java'}; see its first definition at
*note CopyFile-java::.


File: JavaSE9.info,  Node: Automatically Closing Files,  Prev: Reading and Writing Files,  Up: I/O

7.6 Automatically Closing Files
===============================

JDK 7 added a feature that offers another way to manage resources,such
as file streams, by automating the closing process.  This feature,
sometimes referred to as "automatic resource management", or ARM for
short, is based on an expanded version of the 'try' statement.  This
form of 'try' is called the 'try-with-resources' statement.  The
principal advantage of automatic resource management is that it
prevents situations in which a file (or other resource) is
inadvertently not released after it is no longer needed.

   Here is its general form:

     try (resource-specification) {
       // use the resource
     }

GeneralForm 7.1: General Form Automatic Resource Management

   Typically, resource-specification is a statement that declares and
initializes, such as a file stream.  It consists of a variable
declaration in which the variable is initialized with a reference to
the object begin managed.  When the 'try' block ends, the resource is
automatically released.  In the case of a file, this means that the
file is automatically closed.  This form of 'try' can also include
'catch' and 'finally' clauses.  A resource declared in the 'try'
statement is implicitly 'final'.  This means that you can't assign to
the resource after it has been created.  The scope of the resource is
limited to the 'try-with-resources' statement.

   Beginning with JDK 9, it is also possible for the resource
specification of the 'try' to consist of a variable that has been
declared and initialized earlier in the program.  However, that
variable must be effectively final, which means that it has not been
assigned a new value after being given its initial value.

'AutoCloseable' Interface
-------------------------

The 'try-with-resources' statement can be used only with those
resources that implement the 'AutoCloseable' interface defined by
'java.lang'.  This interface defines the 'close()' method.
'AutoCloseable' is inherited by the 'Closeable' interface in
'java.io'.  Both interfaces are implmented by the stream classes.
Thus, 'try-with-resources' can be used when working with streams,
including file streams.

Multiple Resources
------------------

You can manage more than one resource within a single 'try' statement.
Simply separate each resource specification with a semicolon.

* Menu:

* Demonstration of Automatically Closing a File::
* Demonstration of Multiple Resources::


File: JavaSE9.info,  Node: Demonstration of Automatically Closing a File,  Next: Demonstration of Multiple Resources,  Up: Automatically Closing Files

7.6.1 Demonstration of Automatically Closing a File
---------------------------------------------------

Here is a reworked verion of the 'ShowFile' program using
'try-with-resources'.

{'ShowFileTryWR.java'} ==
     <ShowFileTryWR Initial Comments>
     <Import java.io>
     class ShowFileTryWR {
       public static void main (String[] args) {
         <ShowFileTryWR Instance Variable Declaration>
         <ShowFileTryWR Check CL Args> <Number 1> <ShowFileTryWR Check CL Args End>
         <ShowFileTryWR Open a File TryWR>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Import java.io>          See *note Import-java-io::.
<Number 1>                See *note Number-1::.
<ShowFileTryWR Check CL   See *note ShowFileTryWR-Check-CL-Args::.
Args>
<ShowFileTryWR Check CL   See *note ShowFileTryWR-Check-CL-Args-End::.
Args End>
<ShowFileTryWR Initial    See *note ShowFileTryWR-Initial-Comments::.
Comments>
<ShowFileTryWR Instance   See
Variable Declaration>     *note ShowFileTryWR-Instance-Variable-Declaration::.
<ShowFileTryWR Open a     See *note ShowFileTryWR-Open-a-File-TryWR::.
File TryWR>

* Menu:

* ShowFileTryWR Initial Comments::
* ShowFileTryWR Instance Variable Declarations::
* ShowFileTryWR Check CL Args::
* ShowFileTryWR Open a File TryWR::


File: JavaSE9.info,  Node: ShowFileTryWR Initial Comments,  Next: ShowFileTryWR Instance Variable Declarations,  Up: Demonstration of Automatically Closing a File

7.6.1.1 Initial Comments
........................

<ShowFileTryWR Initial Comments> ==
     /* This version of teh ShowFile program uses a try-with-resources
        statement to automatically close a file after it is no longer needed.
      */


This chunk is called by {'ShowFileTryWR.java'}; see its first
definition at *note ShowFileTryWR-java::.


File: JavaSE9.info,  Node: ShowFileTryWR Instance Variable Declarations,  Next: ShowFileTryWR Check CL Args,  Prev: ShowFileTryWR Initial Comments,  Up: Demonstration of Automatically Closing a File

7.6.1.2 Instance Variable Declaration
.....................................

<ShowFileTryWR Instance Variable Declaration> ==
     int i;


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'CopyFileMultTryWR.java'}See *note CopyFileMultTryWR-java::.
{'ShowFileTryWR.java'}    See *note ShowFileTryWR-java::.


File: JavaSE9.info,  Node: ShowFileTryWR Check CL Args,  Next: ShowFileTryWR Open a File TryWR,  Prev: ShowFileTryWR Instance Variable Declarations,  Up: Demonstration of Automatically Closing a File

7.6.1.3 Check CL Args
.....................

<ShowFileTryWR Check CL Args> ==
     // First, confirm that a filename has been specified.
     if (args.length !=

This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'CopyFileMultTryWR.java'}See *note CopyFileMultTryWR-java::.
{'ShowFileTryWR.java'}    See *note ShowFileTryWR-java::.

<ShowFileTryWR Check CL Args End> ==
     ) {
       System.out.println("Usage: ShowFile filename");
       return;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'CopyFileMultTryWR.java'}See *note CopyFileMultTryWR-java::.
{'ShowFileTryWR.java'}    See *note ShowFileTryWR-java::.

<Number 1> ==
     1

This chunk is called by {'ShowFileTryWR.java'}; see its first
definition at *note ShowFileTryWR-java::.


File: JavaSE9.info,  Node: ShowFileTryWR Open a File TryWR,  Prev: ShowFileTryWR Check CL Args,  Up: Demonstration of Automatically Closing a File

7.6.1.4 Open a File TryWR
.........................

Pay special attention to how the file is opened within the 'try'
statement.  The resource-specification portion of the 'try' declares a
'FileInputStream' called 'fin', which is then assigned a reference to
the file opened by its constructor.  Therefore, here, the variable
'fin' is local to the 'try' block, being created when the 'try' is
entered.  When the 'try' is left, the stream associated with 'fin' is
automatically closed by an implicit call to 'close()'.  Since you
don't call 'close()' explicitly, you can't forget to close the file.
This is a key advantage of using 'try-with-resources'.

================================================================================

<ShowFileTryWR Open a File TryWR> ==
     /* The following code uses a try-with-resources statement to open
        a file and then automatically close it when the try block is left. */

     try (FileInputStream fin = new FileInputStream(args[0])) {

       do {
         i = fin.read();
         if (i != -1) System.out.print((char) i);
       } while (i != -1);

     } catch (FileNotFoundException e) {
       System.out.println("File Not Found.");

     } catch (IOException e) {
       System.out.println("An I/O Error Occurred.");
     }


This chunk is called by {'ShowFileTryWR.java'}; see its first
definition at *note ShowFileTryWR-java::.


File: JavaSE9.info,  Node: Demonstration of Multiple Resources,  Prev: Demonstration of Automatically Closing a File,  Up: Automatically Closing Files

7.6.2 Demonstration of Multiple Resources
-----------------------------------------

The following program shows an example of handling multiple resources
in a single 'try' statement.  It reworks the 'CopyFile' program shown
earlier so that it uses a single 'try-with-resources' statement to
manage both 'fin' and 'fout'.

{'CopyFileMultTryWR.java'} ==
     <CopyFileMultTryWR Initial Comments>
     <Import java.io>
     class CopyFileMultTryWR {
       public static void main (String[] args) throws IOException {
         <ShowFileTryWR Instance Variable Declaration>
         <ShowFileTryWR Check CL Args> <Number 2> <ShowFileTryWR Check CL Args End>
         <CopyFileMultTryWR Manage Two Files>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<CopyFileMultTryWR        See
Initial Comments>         *note CopyFileMultTryWR-Initial-Comments::.
<CopyFileMultTryWR        See
Manage Two Files>         *note CopyFileMultTryWR-Manage-Two-Files::.
<Import java.io>          See *note Import-java-io::.
<Number 2>                See *note Number-2::.
<ShowFileTryWR Check CL   See *note ShowFileTryWR-Check-CL-Args::.
Args>
<ShowFileTryWR Check CL   See *note ShowFileTryWR-Check-CL-Args-End::.
Args End>
<ShowFileTryWR Instance   See
Variable Declaration>     *note ShowFileTryWR-Instance-Variable-Declaration::.

<Number 2> ==
     2

This chunk is called by {'CopyFileMultTryWR.java'}; see its first
definition at *note CopyFileMultTryWR-java::.

* Menu:

* CopyFileMultTryWR Initial Comments::
* CopyFileMultTryWR Manage Two Files::


File: JavaSE9.info,  Node: CopyFileMultTryWR Initial Comments,  Next: CopyFileMultTryWR Manage Two Files,  Up: Demonstration of Multiple Resources

7.6.2.1 CopyFileMultTryWR Initial Comments
..........................................

<CopyFileMultTryWR Initial Comments> ==
     /* A version of CopyFile that uses try-with-resources.
        It demonstrates two resources (in this case files) being
        managed by a single try statement
      */


This chunk is called by {'CopyFileMultTryWR.java'}; see its first
definition at *note CopyFileMultTryWR-java::.


File: JavaSE9.info,  Node: CopyFileMultTryWR Manage Two Files,  Prev: CopyFileMultTryWR Initial Comments,  Up: Demonstration of Multiple Resources

7.6.2.2 CopyFileMultTryWR Manage Two Files
..........................................

Note how the input and output files are opened within the 'try' block.
After this block ends, both 'fin' and 'fout' will have been closed.
This code is much shorter.  The ability to streamline source code is a
side-benefit of automatic resouce management.

================================================================================

<CopyFileMultTryWR Manage Two Files> ==
     // Open and manage two files via the try statement.
     try (FileInputStream fin = new FileInputStream(args[0]);
          FileOutputStream fout = new FileOutputStream(args[1])) {

       do {
         i = fin.read();
         if (i != -1) fout.write(i);
       } while (i != -1);

     } catch (IOException e) {
       System.out.println("I/O Error: " + e);
     }


This chunk is called by {'CopyFileMultTryWR.java'}; see its first
definition at *note CopyFileMultTryWR-java::.


File: JavaSE9.info,  Node: Miscellaneous Java Keywords,  Next: Generics,  Prev: I/O,  Up: Top

8 Miscellaneous Java Keywords
*****************************

This chapter looks at several more Java keywords:

   * 'volatile'
   * 'instanceof'
   * 'native'
   * 'strictfp'
   * 'assert'

* Menu:

* transient and volatile Modifiers::
* Using instanceof::
* strictfp::
* Native Methods::
* Using assert::
* Static Import::
* Overloaded Constructors with this::
* Compact API Profiles::


File: JavaSE9.info,  Node: transient and volatile Modifiers,  Next: Using instanceof,  Up: Miscellaneous Java Keywords

8.1 The 'transient' and 'volative' Modifiers
============================================


File: JavaSE9.info,  Node: Using instanceof,  Next: strictfp,  Prev: transient and volatile Modifiers,  Up: Miscellaneous Java Keywords

8.2 Using 'instanceof'
======================


File: JavaSE9.info,  Node: strictfp,  Next: Native Methods,  Prev: Using instanceof,  Up: Miscellaneous Java Keywords

8.3 'strictfp'
==============


File: JavaSE9.info,  Node: Native Methods,  Next: Using assert,  Prev: strictfp,  Up: Miscellaneous Java Keywords

8.4 Native Methods
==================


File: JavaSE9.info,  Node: Using assert,  Next: Static Import,  Prev: Native Methods,  Up: Miscellaneous Java Keywords

8.5 Using 'assert'
==================


File: JavaSE9.info,  Node: Static Import,  Next: Overloaded Constructors with this,  Prev: Using assert,  Up: Miscellaneous Java Keywords

8.6 Static Import
=================


File: JavaSE9.info,  Node: Overloaded Constructors with this,  Next: Compact API Profiles,  Prev: Static Import,  Up: Miscellaneous Java Keywords

8.7 Invoking Overloaded Constructors Through 'this()'
=====================================================


File: JavaSE9.info,  Node: Compact API Profiles,  Prev: Overloaded Constructors with this,  Up: Miscellaneous Java Keywords

8.8 Compact API Profiles
========================


File: JavaSE9.info,  Node: Generics,  Next: Enumerations,  Prev: Miscellaneous Java Keywords,  Up: Top

9 Generics
**********

"Generics", introduced in J2SE 5.0, allows a type or method to operate
on objects of various types while providing compile-time type safety.
It adds compile-time type safety to the Collections Framework and
eliminates the need of casting.  In other words, generics allow you to
abstract over types.

   Through the use of generics, it is possible to create classes,
interfaces, and methods that will work in a type-safe manner with
various kinds of data.  Many algorithms are logically the same no
matter what type of data they are being applied to.  For example, the
mechanism that supports a stack is the same whether that stack is
storing items of type 'Integer', 'String', 'Object', or 'Thread'.
With generics, you can define an algorithm once, independently of any
specific type of data, and then apply that algorithm to a wide variety
of data types without any additional effort.

   Perhaps the one feature of Java that has been most significantly
affected by generics is the 'Collections Framework'.  A "collection"
is a group of objects.  The Collections Framework defines several
classes, such as lists and maps, that manage collections.  The
collection classes have always been able to work with any type of
object.  The benefit that generics adds is that the collection classes
can now be used with complete type safety.

   This chapter describes the syntax, theory, and use of generics.  It
also shows how generics provide type safety for some previously
difficult cases.

* Menu:

* Motivation::
* What are Generics::
* Simple Generics Example::
* Notes about Generics::
* Two Type Parameters::
* Generic Class General Form::
* Bounded Types::
* Wildcard Arguments::
* Generic Methods::
* Generic Constructors::


File: JavaSE9.info,  Node: Motivation,  Next: What are Generics,  Up: Generics

9.1 Motivation for Generics
===========================

Code Fragment Without Generics
------------------------------

Here is a typical code fragment abstracting over types by using
'Object' and type casting.

     List myIntList = new LinkedList(); // 1
     myIntList.add(new Integer(0)); // 2
     Integer x = (Integer) myIntList.iterator().next(); // 3

   The cast on line 3 is annoying, although essential.  The compiler
can guarantee only that an 'Object' will be returned by the iterator.
This therefore adds both clutter and the possibility of a run-time
error.

Code Fragment with Generics
---------------------------

Generics allow a programmer to mark their intent to restrict a list to
a particular data type.  Here is a version of the same code that uses
generics.

     List<Integer> myIntList = new LinkedList<Integer>(); // 1'
     myIntList.add(new Integer(0)); // 2'
     Integer x = myIntList.iterator().next(); // 3'

   In line 1, the type declaration for the variable 'myIntList'
specifies that it is to hold a 'List' of 'Integer's: 'List<Integer>'.
'List' is a "generic interface" that takes a "type parameter"
('Integer').  The type parameter is also specified when creating the
'List' object ('new LinkedList<Integer>()').  Also, the cast on line 3
is gone.

   So has this just moved the clutter around, from a type cast to a
type parameter?  No, because this has given the compiler the ability
to check the type correctness of the program _at compile-time_.  When
we say that 'myIntList' is declared with type 'List<Integer>', this
tells us something about the variable 'myIntList', which holds true
wherever and whenever it is used, and the compiler will guarantee it.
In contrast, the cast tells us something the programmer thinks is true
at a single point in the code.

   The net effect, especially in large programs, is improved
readability and robustness.


File: JavaSE9.info,  Node: What are Generics,  Next: Simple Generics Example,  Prev: Motivation,  Up: Generics

9.2 What Are Generics
=====================

The term "generics" means parameterized types.  Parameterized types
are important because they enable you to create classes, interfaces,
and methods in whicht the type of data upon which they operate is
specified as a parameter.  Using generics, it is possible to create a
single class, for example, that automatically works with different
types of data.  A class, interface, or method that operates on a
parameterized type is called "generic", as in generic class or generic
method.

   Java has always given the ability to create generalized classes,
interfaces, and methods by operating through references of type
'Object'.  Generics added the type safety that was lacking.  They also
streamlined the process, because it is no longer necessary to
explicitly employ casts to translate between 'Object' and the type of
data that is being operate upon.  Wtih generics, all casts are
automatic and implicit.


File: JavaSE9.info,  Node: Simple Generics Example,  Next: Notes about Generics,  Prev: What are Generics,  Up: Generics

9.3 A Simple Generics Example
=============================

The following program defines two classes.  The first is the generic
class 'Gen', and the second is 'GenDemo', which uses 'Gen'.

{'SimpleGenerics.java'} ==
     <Class Gen>
     <Class GenDemo>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class Gen>               See *note Class-Gen::.
<Class GenDemo>           See *note Class-GenDemo::.

* Menu:

* Class Gen<T>::
* Class GenDemo::


File: JavaSE9.info,  Node: Class Gen<T>,  Next: Class GenDemo,  Up: Simple Generics Example

9.3.1 Class Gen<T>
------------------

This is a simple generic class.  The class 'Gen' is declared with a
parameter of '<T>':

     class Gen<T> {

   'T' is the name of a "type parameter".  This name is used as a
placeholder for the actual type that will be passed to 'Gen' when an
object is created.  Thus, 'T' is used within 'Gen' whenever the type
parameter is needed.

   Notice that 'T' is contained within '< >'.  This syntax can be
generalized.  Whenever a type parameter is being declared, it is
specified within angle brackets.

   Because 'Gen' uses a type parameter, 'Gen' is a _generic class_,
which is also called a _parameterized type_.

Outline of Class Gen<T>
.......................

Class 'Gen' contains four parts:

   * an instance variable declaration
   * a constructor
   * a method returning the instance variable
   * a method describing the type of the instance variable

<Class Gen> ==
     class Gen<T> {
       <Instance Variable ob of Type T>
       <Constructor taking parameter of Type T>
       <Method returning object of type T>
       <Method showing type of T>
     }

This chunk is called by {'SimpleGenerics.java'}; see its first
definition at *note SimpleGenerics-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Constructor taking       See
parameter of Type T>      *note Constructor-taking-parameter-of-Type-T::.
<Instance Variable ob     See *note Instance-Variable-ob-of-Type-T::.
of Type T>
<Method returning         See
object of type T>         *note Method-returning-object-of-type-T::.
<Method showing type of   See *note Method-showing-type-of-T::.
T>

Implementation of Class Gen<T>
..............................

'T' is used to declare an object called 'ob'.  'T' is a placeholder
for the actual type that will be specified when a 'Gen' object is
created.  Thus, 'ob' will be an object of the type passed to 'T'.

<Instance Variable ob of Type T> ==
     T ob;   // declare an object of type T


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

The Constructor
...............

Here is the constructor for 'Gen'.  Notice that its parameter, 'o', is
of type 'T'.  This means that the actual type of 'o' is determined by
the type passed to 'T' when a 'Gen' object is created.  Because both
the parameter 'o' and the member variable 'ob' are of type 'T', they
will both be the same actual type when a 'Gen' object is created.

<Constructor taking parameter of Type T> ==
     // Pass the constructor a reference to
     // an object of type T
     Gen (T o) {
       ob = o;
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

Instance Methods 'getob()' and 'showType()'
...........................................

The type parameter 'T' can also be used to specify the return type of
a method, as here in 'getob()'.  Because 'ob' is also of type 'T', its
type is compatible wih the return type specified by 'getob()'.

<Method returning object of type T> ==
     // Return ob
     T getob() {
       return ob;
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.

   The method 'showType()' displays the type of 'T' by calling
'getName()' on the 'Class' object return by the call to 'getClass()'
on 'ob'.  The 'getClass()' method is defined by 'Object' and is thus a
member of _all_ class types.  It returns a 'Class' object that
corresponds to the type of the class of the object on which it is
called.  'Class' defines the 'getName()' method, which returns a
string representation of the class name.

<Method showing type of T> ==
     // Show type of T
     void showType() {
       System.out.println("Type of T is " + ob.getClass().getName();
     }


This chunk is called by <Class Gen>; see its first definition at *note
Class-Gen::.


File: JavaSE9.info,  Node: Class GenDemo,  Prev: Class Gen<T>,  Up: Simple Generics Example

9.3.2 Class GenDemo
-------------------

The 'GenDemo' class demonstrates the generic 'Gen' class.

   But first, take note: The Java compiler does not actually create
different versions of 'Gen', or of any other generic class.  The
compiler removes all generic type information, substituting the
necessary casts, to make your code *behave as if* a specific version
of 'Gen' were created.  There is really only one version of 'Gen' that
actually exists.

   The process of removing generic type information is called "type
erasure".

   'GenDemo' first creates a version of 'Gen' for integers and calls
the methods defined in 'Gen' on it.  It then does the same for a
String object.

<Class GenDemo> ==
     // Demonstrate the generic class
     class GenDemo {
       public static void main(String args[]) {
         <Create a Gen object for Integers>
         <Create a Gen object for Strings>
       }
     }


This chunk is called by {'SimpleGenerics.java'}; see its first
definition at *note SimpleGenerics-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Create a Gen object      See
for Integers>             *note Create-a-Gen-object-for-Integers::.
<Create a Gen object      See *note Create-a-Gen-object-for-Strings::.
for Strings>

* Menu:

* GenDemo as Integer::
* GenDemo as String::


File: JavaSE9.info,  Node: GenDemo as Integer,  Next: GenDemo as String,  Up: Class GenDemo

9.3.2.1 Implementation of Class GenDemo with Type Integer
.........................................................

<Create a Gen object for Integers> ==
     <Integer Type Parameter>
     <Reference to Integer Instance>
     <Show Type>
     <Get Value>

This chunk is called by <Class GenDemo>; see its first definition at
*note Class-GenDemo::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Get Value>               See *note Get-Value::.
<Integer Type             See *note Integer-Type-Parameter::.
Parameter>
<Reference to Integer     See *note Reference-to-Integer-Instance::.
Instance>
<Show Type>               See *note Show-Type::.

Integer Type Declaration
........................

A reference to an Integer is declared in 'iOb'.  Here, the type
'Integer' is specified within the angle brackets after 'Gen'.
'Integer' is a "type argument" that is passed to 'Gen''s type
parameter, 'T'.  This effectively creates a version of 'Gen' in which
all references to 'T' are translated into references to 'Integer'.
Thus, 'ob' is of type 'Integer', and the return type of 'getob()' is
of type 'Integer'.

<Integer Type Parameter> ==
     Gen<Integer> iOb;


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

Reference Assignment
....................

The next line assigns to 'iOb' a reference to an instance of an
'Integer' version of the 'Gen' class.  When the 'Gen' constructor is
called, the type argument 'Integer' is also specified.  This is
because the type of the object (in this case 'iOb' to which the
reference is being assigned is of type 'Gen<Integer>'.  Thus, the
reference returned by 'new' must also be of type 'Gen<Integer>'.  If
it isn't, a compile-time error will result.  This type checking is one
of the main benefits of generics because it ensures type safety.

   Notice the use of autoboxing to encapsulate the value 88 within an
Integer object.

<Reference to Integer Instance> ==
     iOb = new Gen<Integer>(88);


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

   The automatic autoboxing could have been written explicitly, like
so:
     iOb = new Gen<Integer>(Integer.valueOf(88));
but there would be no value to doing it that way.

Showing the Reference's Type
............................

The program then uses 'Gen''s instance method to show the type of
'ob', which is an 'Integer' in this case.

<Show Type> ==
     iOb.showType();


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.

Showing the Reference's Value
.............................

The program now obtains the value of 'ob' by assiging 'ob' to an 'int'
variable.  The return type of 'getob()' is 'Integer', which unboxes
into 'int' when assigned to an 'int' variable ('v').  There is no need
to cast the return type of 'getob()' to 'Integer'.

<Get Value> ==
     int v = iOb.getob();
     System.out.println("value: " + v);
     System.out.println();


This chunk is called by <Create a Gen object for Integers>; see its
first definition at *note Create-a-Gen-object-for-Integers::.


File: JavaSE9.info,  Node: GenDemo as String,  Prev: GenDemo as Integer,  Up: Class GenDemo

9.3.2.2 Implementation of Class GenDemo with Type String
........................................................

<Create a Gen object for Strings> ==
     // Create a Gen object for Strings.
     Gen<String> strOb = new Gen<String>("Generics Test");

     // Show the type of data used by strOb
     strOb.showType();

     // Get the value of strOb.  Again, notice
     // that no cast is needed.
     String str = strOb.getob();
     System.out.println("value: " + str);


This chunk is called by <Class GenDemo>; see its first definition at
*note Class-GenDemo::.


File: JavaSE9.info,  Node: Notes about Generics,  Next: Two Type Parameters,  Prev: Simple Generics Example,  Up: Generics

9.4 Notes About Generics
========================

* Menu:

* Reference Types::
* Type Arguments::
* Subtyping::
* Type Safety::


File: JavaSE9.info,  Node: Reference Types,  Next: Type Arguments,  Up: Notes about Generics

9.4.1 Generics Work Only with Reference Types
---------------------------------------------

When declaring an instance of a generic type, the type argument passed
to the type parameter must be a reference type.  It cannot be a
primitive type, such as 'int' or 'char'.

   You can use the type wrappers to encapsulate a primitive type.
Java's autoboxing and auto-unboxing mechanism makes the use of the
type wrapper transparent.


File: JavaSE9.info,  Node: Type Arguments,  Next: Subtyping,  Prev: Reference Types,  Up: Notes about Generics

9.4.2 Generic Types Differ Based on their Type Arguments
--------------------------------------------------------

A reference of one specific version of a generic type is not
type-compatible with another version of the same generic type.  In
other words, the following line of code is an error and will not
compile:

     iOb = strOb; // Gen<Integer> != Gen<String>

   These are references to different types because their type
arguments differ.


File: JavaSE9.info,  Node: Subtyping,  Next: Type Safety,  Prev: Type Arguments,  Up: Notes about Generics

9.4.3 Generics and Subtyping
----------------------------

Is the following legal?

     List<String> ls = new ArrayList<String>(); // 1
     List<Object> lo = ls; // 2

   Line 1 is legal.  What about line 2?  This boils down to the
question: "is a List of String a List of Object."  Most people
instinctively answer, "Sure!"

   Now look at these lines:

     lo.add(new Object()); // 3
     String s = ls.get(0); // 4: Attempts to assign an Object to a String!

   Here we've aliased 'ls' and 'lo'.  Accessing 'ls', a list of
'String', through the alias 'lo', we can insert arbitrary objects into
it.  As a result 'ls' does not hold just 'Strings' anymore, and when
we try and get something out of it, we get a rude surprise.

   The Java compiler will prevent this from happening of course.  Line
2 will cause a compile time error.

   The take-away is that, if 'Foo' is a subtype (subclass or
subinterface) of 'Bar', and 'G' is some generic type declaration, it
is not the case that 'G<Foo>' is a subtype of 'G<Bar>'.


File: JavaSE9.info,  Node: Type Safety,  Prev: Subtyping,  Up: Notes about Generics

9.4.4 How Generics Improve Type Safety
--------------------------------------

Generics automatically ensure the type safety of all operations
involving a generic class, such as 'Gen'.  They eliminate the need for
the coder to enter cases and to type-check code by hand.


File: JavaSE9.info,  Node: Two Type Parameters,  Next: Generic Class General Form,  Prev: Notes about Generics,  Up: Generics

9.5 A Generic Class with Two Type Parameters
============================================

You can declare more than one type parameter in a generic type.  To
specify two or more type parameters, use a comma-separated list.  When
an object is created, the same number of type arguments must be passed
as there are type parameters.  The type arguments can be the same or
different.

* Menu:

* Two Types Example Code::


File: JavaSE9.info,  Node: Two Types Example Code,  Up: Two Type Parameters

9.5.1 Example of Code with Two Type Parameters
----------------------------------------------

{'TwoTypeParameters.java'} ==
     <Class TwoGen>
     <Class SimpGen>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class SimpGen>           See *note Class-SimpGen::.
<Class TwoGen>            See *note Class-TwoGen::.

* Menu:

* Class TwoGen::
* Class SimpGen::


File: JavaSE9.info,  Node: Class TwoGen,  Next: Class SimpGen,  Up: Two Types Example Code

9.5.1.1 Class TwoGen
....................

<Class TwoGen> ==
     <Class Declaration>
       <Two Instance Variables Declarations>
       <Constructor of Two Parameters>
       <Instance Methods Show and Get>

This chunk is called by {'TwoTypeParameters.java'}; see its first
definition at *note TwoTypeParameters-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Class Declaration>       See *note Class-Declaration::.
<Constructor of Two       See *note Constructor-of-Two-Parameters::.
Parameters>
<Instance Methods Show    See *note Instance-Methods-Show-and-Get::.
and Get>
<Two Instance Variables   See
Declarations>             *note Two-Instance-Variables-Declarations::.

Class Declaration
.................

Notice how 'TwoGen' is declared.  It specifies two type parameters:
'T' and 'V', separated by a comma.  Because it has two type
parameters, two type arguments must be passed to 'TwoGen' when an
object is created.

<Class Declaration> ==
     class TwoGen<T, V> {

This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Instance Variables Declarations
...............................

<Two Instance Variables Declarations> ==
     T ob1;
     V ob2;


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Constructor
...........

<Constructor of Two Parameters> ==
     TwoGen(T o1, V 02) {
       ob1 = o1;
       ob2 = o2;
     }


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.

Instance Methods Show and Get
.............................

<Instance Methods Show and Get> ==
     void showTypes() {
       System.out.println("Type of T is " + ob1.getClass().getName());
       System.out.println("Type of V is " + ob2.getClass().getName());
     }

     T getob1() {
       return ob1;
     }

     V getob2() {
       return ob2;
     }


This chunk is called by <Class TwoGen>; see its first definition at
*note Class-TwoGen::.


File: JavaSE9.info,  Node: Class SimpGen,  Prev: Class TwoGen,  Up: Two Types Example Code

9.5.1.2 Class SimpGen
.....................

Two type arguments must be supplied to the constructor.  In this case,
the two type parameters are 'Integer' and 'String'.

<Class SimpGen> ==
     class SimpGen {
       public static void main(String args[]) {
         TwoGen<Integer, String> tgObj =
           new TwoGen<Integer, String>(88, "Generics");

         // Show the types
         tgObj.showTypes();

         // Obtain and show values
         int v = tgObj.getob1();
         System.out.println("value: " + v);

         String str = thObj.getob2();
         System.out.println("value: " + str);
       }
     }

This chunk is called by {'TwoTypeParameters.java'}; see its first
definition at *note TwoTypeParameters-java::.


File: JavaSE9.info,  Node: Generic Class General Form,  Next: Bounded Types,  Prev: Two Type Parameters,  Up: Generics

9.6 The General Form of a Generic Class
=======================================

The generics syntax shown above can be generalized.  Here is the
syntax for declaring a generic class:

     class class-name<type-param-list> { ...

Here is the full syntax for declaring a reference to a generic class
and instance creation:

     class-name<type-arg-list> var-name =
       new class-name<type-arg-list>(cons-arg-list);

GeneralForm 9.1: General Form for Declaring and Creating a Reference
to a Generic Class


File: JavaSE9.info,  Node: Bounded Types,  Next: Wildcard Arguments,  Prev: Generic Class General Form,  Up: Generics

9.7 Bounded Types
=================

Sometimes it can be useful to limit the types that can be passed to a
type parameter.  Java provides "bounded types".  When specifying a
type parameter, you can create an upper bound that declares the
superclass from which all type arguments must be derived.  This is
accomplished through the use of an 'extends' clause when specifying
the type parameter:

      <T extends superclass>

   This specifies that T can only be replaced by superclass or
subclasses of superclass.  Thus, superclass defines an inclusive,
upper limit.

Interface Type as a Bound
-------------------------

In addition to using a class type as a bound, you can also use an
interface type.  In fact, youi can specify multiple interfaces as
bounds.  Furthermore, a bound can include both a class type and one or
more interfaces.  In this case, the class type must be specified
first.  When a bound includes an interface type, only type arguments
that implement that interface are legal.

   When specifying a bound that has a class and an interface, or
multiple interfaces, use the '&' operator to connnect them.

     class Gen<T extends MyClass & MyInterface> { ...

   Any type argument passed to 'T' must be a subclass of 'MyClass' and
implement 'MyInterface'.


File: JavaSE9.info,  Node: Wildcard Arguments,  Next: Generic Methods,  Prev: Bounded Types,  Up: Generics

9.8 Using Wildcard Arguments
============================

* Menu:

* Wildcard Motivation::
* Wildcard Syntax::
* Bounded Wildcards::


File: JavaSE9.info,  Node: Wildcard Motivation,  Next: Wildcard Syntax,  Up: Wildcard Arguments

9.8.1 Wildcard Motivation
-------------------------

Consider the problem of writing a routine that prints out all the
elements in a collection.  Here's how you might write it in an older
version of the language (i.e., a pre-5.0 release):

     void printCollection(Collection c) {
         Iterator i = c.iterator();
         for (k = 0; k < c.size(); k++) {
             System.out.println(i.next());
         }
     }

   And here is a naive attempt at writing it using generics (and the
new 'for loop' syntax):

         for (Object e : c) {
             System.out.println(e);
         }
     }

   The problem is that this new version is much less useful than the
old one.  Whereas the old code could be called with any kind of
collection as a parameter, the new code only takes
'Collection<Object>', which, as we've just demonstrated, is _not_ a
supertype of all kinds of collections!

   So what is the supertype of all kinds of collections?  It's written
'Collection<?>' (pronounced "collection of unknown"), that is, a
collection whose element type matches anything.  It's called a
"wildcard type".  We can write:

     void printCollection(Collection<?> c) {
         for (Object e : c) {
             System.out.println(e);
         }
     }

   and now, we can call it with any type of collection.  Notice that
inside 'printCollection()', we can still read elements from 'c' and
give them type 'Object'.  This is always safe, since whatever the
actual type of the collection, it does contain objects.  It isn't safe
to add arbitrary objects to it however:

     Collection<?> c = new ArrayList<String>();
     c.add(new Object()); // Compile time error

   Since we don't know what the element type of 'c' stands for, we
cannot add objects to it.  The 'add()' method takes arguments of type
'E', the element type of the collection.  When the actual type
parameter is '?', it stands for some unknown type.  Any parameter we
pass to 'add' would have to be a subtype of this unknown type.  Since
we don't know what type that is, we cannot pass anything in.  The sole
exception is 'null', which is a member of every type.

   On the other hand, given a 'List<?>', we can call 'get()' and make
use of the result.  The result type is an unknown type, but we always
know that it is an object.  It is therefore safe to assign the result
of 'get()' to a variable of type 'Object' or pass it as a parameter
where the type 'Object' is expected.


File: JavaSE9.info,  Node: Wildcard Syntax,  Next: Bounded Wildcards,  Prev: Wildcard Motivation,  Up: Wildcard Arguments

9.8.2 Wildcard Syntax
---------------------

Sometimes type safety can get in the way of perfectly acceptable
constructs.  In such cases, there is a "wildcard" argument that can be
used.  The wildcard argument is specified by the '?', and it
represents an unknown type.  It would be used in place of a type
parameter, for example:

     boolean sameAvg(Stats<?> ob) {
       if(average() == ob.average())
         return true;

       return false;
     }

   Here, 'Stats<?>' matches any 'Stats' object ('Integer', 'Double'),
allowing any two 'Stats' objects to have their averages compared.  The
wildcard does not affect what type of 'Stats' object can be created.
That is governed by the 'extends' clause in the 'Stats' declaration.
The wildcard simply matches any _valid_ 'Stats' object.


File: JavaSE9.info,  Node: Bounded Wildcards,  Prev: Wildcard Syntax,  Up: Wildcard Arguments

9.8.3 Bounded Wildcards
-----------------------

Wildcard arguments can be bounded in much the same way that a type
parameter can be bounded (the "bounded wildcard argument".  A bounded
wildcard is especially important when you are creating a generic type
that will operate on a class hierarchy.

   A bounded wildcard specifies either an upper bound or a lower bound
for the type argument.  This enables you to restrict the types of
objects upon which a method will operate.

Upper Bounded Wildcard
......................

The most common bounded wildcard is the upper bound, which is created
using an 'extends' clause.In general, to establish an upper bound for
a wildcard, use the following type of wildcard expression:

     <? extends superclass>

GeneralForm 9.2: General Form of Upper Bounded Wildcard Syntax

   where superclass is the name of the class that serves as the upper
bound.  This is an inclusive clause.

Lower Bounded Wildcard
......................

You can also specify a lower bound for a wildcard by adding a 'super'
clause to a wildcard declaration.  Here is its general form:

     <? super subclass>

GeneralForm 9.3: General Form of Lower Bounded Wildcard Syntax

   Only classes that are superclasses of subclass are acceptable
arguments


File: JavaSE9.info,  Node: Generic Methods,  Next: Generic Constructors,  Prev: Wildcard Arguments,  Up: Generics

9.9 Creating a Generic Method
=============================

It is possible to declare a generic method that uses one or more type
parameters of its own.  It is also possible to create a generic method
that is enclosed within a non-generic class.

Generalized Form
----------------

     < type-param-list > ret-type meth-name ( param-list ) { ...

GeneralForm 9.4: General Form for Declaring a Generic Method

* Menu:

* Example of Generic Method::


File: JavaSE9.info,  Node: Example of Generic Method,  Up: Generic Methods

9.9.1 Example of Generic Method
-------------------------------

The following program declares a non-generic class called
'GenMethDemo' and a static *generic method* within that class called
'isIn()'.  The 'isIn()' method determines if an object is a member of
an array.  It can be used with any type of object and array as long as
the array contains objects that are compatible with the type of the
object being sought.

{'GenMethDemo.java'} ==
     class GenMethDemo {
       <Static Method isIn>
       <GenMethDemo Main>
     }

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<GenMethDemo Main>        See *note GenMethDemo-Main::.
<Static Method isIn>      See *note Static-Method-isIn::.

* Menu:

* Method isIn::
* GenMethDemo Main::


File: JavaSE9.info,  Node: Method isIn,  Next: GenMethDemo Main,  Up: Example of Generic Method

9.9.1.1 Method isIn()
.....................

The *type parameters* are declared _before_ the return type of the
method.

<Static Method isIn> ==
     static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {

       for (int i = 0; i < y.length; i++)
         if (x.equals(y[i]) return true;

       return false;
     }


This chunk is called by {'GenMethDemo.java'}; see its first definition
at *note GenMethDemo-java::.

   The type T is *upper-bounded* by the 'Comparable' interface, which
must be of the same type as T. Likewise, the second type, V, is also
*upper-bounded* by T. Thus, V must be either the same type as T or a
subclass of T. This relationship enforces that 'isIn()' can be called
only with arguments that are compatible with each other.

   While 'isIn()' is static in this case, generic methods can be
either static or non-static; there is no restriction in this regard.

Explicitly Including Type Arguments
...................................

There is generally no need to specify type arguments when calling this
method from within the 'main' routine.  This is because the type
arguments are automatically discerned, and the types of T and V are
adjusted accordingly.

   Although type inference will be sufficient for most generic method
calls, you can explicitly specify the type argument if needed.  For
example, here is how the first call to 'isIn()' looks when the type
argumetns are specified:

     GenMethDemo.<Integer, Integer>isIn(2, nums)


File: JavaSE9.info,  Node: GenMethDemo Main,  Prev: Method isIn,  Up: Example of Generic Method

9.9.1.2 GenMethDemo Main
........................

<GenMethDemo Main> ==
     public static void main(String args[]) {

       // call isIn() with Integer type
       Integer nums[] = { 1, 2, 3, 4, 5 };

       if ( isIn(2, nums) )
         System.out.println("2 is in nums");

       if ( @isIn(7, nums))
         System.out.println("7 is not in nums");

       System.out.println();

       // call isIn() with String type
       String strs[] = { "one", "two", "three", "four", "five" };

       if ( isIn("two", strs))
         System.out.println("two is in strs");

       if ( !isIn("seven", strs))
         System.out.println("seven is not in strs");

       // call isIn() with mixed types
       // WILL NOT COMPILE! TYPES MUST BE COMPATIBLE
       // if ( isIn("two", nums))
       //    System.out.println("two is in nums");
     }


This chunk is called by {'GenMethDemo.java'}; see its first definition
at *note GenMethDemo-java::.


File: JavaSE9.info,  Node: Generic Constructors,  Prev: Generic Methods,  Up: Generics

9.10 Generic Constructors
=========================

It is possible for constructors to be generic, even if their class is
not (*note generics-constructor::).  The syntax is the same (type
parameters come first).

     < type-param-list> constructor-name ( param-list ) { ...


File: JavaSE9.info,  Node: Enumerations,  Next: Strings,  Prev: Generics,  Up: Top

10 Enumerations
***************

Enumerations were added by JDK 5.  In earlier versions of Java,
enumerations were implemented using 'final' variables.

   An "enumeration" is a list of named constants that define a new
data type and its legal values.  In other words, an enumeration
defines a class type.  An "enumeration object" can only hold values
that were declared in the list.  Other values are not allowed.  An
enumeration allows the programmer to define a set of values that a
data type can legally have.

   By making enumerations classes, the capabilities of the enumeration
are greatly expanded.  An enumeration can have:

   * constructors
   * methods
   * instance variables

* Menu:

* Enumeration Basics::
* Enum Methods::
* Enumerations as Class Types::
* Inherit Enum::


File: JavaSE9.info,  Node: Enumeration Basics,  Next: Enum Methods,  Up: Enumerations

10.1 Enumeration Basics
=======================

An enumeration is created using the 'enum' keyword.

     enum Apple {
          Jonathon, GoldenDel, RedDel, Winesap, Cortland
     }

enumeration constants
---------------------

The enum constants 'Jonathon', 'GoldenDel', etc.  are called
"enumeration constants".  The enumeration constants are declared as
'public static final' members of the enum.  Their type is the type of
the enumeration in which they are declared.  These constants are
called "self-typed", in which "self" refers to the enclosing
enumeration.

enumeration objects
-------------------

You can create a variable of an enumeration type.  You do not
instantiate an 'enum' using 'new'.  Rather, you declare an 'enum'
variable like you do for primitive types: 'Apple ap'.  Now, the
variable 'ap' can only hold values of type 'Apple'.

     Apple ap;
     ap = Apple.RedDel;

   The 'enum' type (i.e., 'Apple') must be part of the expression.

Comparing for Equality; Switch
------------------------------

Two enumeration constants can be compared for equality using the '=='
relational operator.  Furthermore, an enumneration value can be used
to control a 'switch' statement.  The 'enum' prefix (type) is not
required for 'switch'.

     switch(ap) {
       case Jonathon: ...
       case Winesap: ...
     }

Printing Enum Types
-------------------

When an enumeration object is printed, its name is output (without the
'enum' type): 'System.out.println(ap)' would produce 'RedDel'.


File: JavaSE9.info,  Node: Enum Methods,  Next: Enumerations as Class Types,  Prev: Enumeration Basics,  Up: Enumerations

10.2 Enum Methods 'values()' and 'valueOf()'
============================================

All enumerations inherit two methods:

 -- Method on Enum:
          public static enum-type[]
          values ()
     The 'values()' method returns an array that contains a list of
     the enumeration constants.

 -- Method on Enum:
          public static enum-type
          valueOf (String STR)
     The 'valueOf()' method returns the enumeration constant whose
     value corresponds to the string passed in STR.

Examples using 'values()' and 'valueOf()' Methods
-------------------------------------------------

'Apple allapples[] = Apple.values();' is an example of using the
'values()' method to populate an array with enumeration constants.

     for(Apple a : Apple.values()) {
       System.out.println(a);
     }

is an example of iterating directly on the 'values()' method.

     Apple ap;
     ap = Apple.valueOf("Winesap");
     System.out.println("ap contains " + ap);

is an example of using the 'valueOf()' method to obtain the
enumeration constant corresponding to the value of a string.


File: JavaSE9.info,  Node: Enumerations as Class Types,  Next: Inherit Enum,  Prev: Enum Methods,  Up: Enumerations

10.3 Java Enumerations are Class Types
======================================

A Java enumeration is a class type.  That is, 'enum' defines a class,
which has much the same capabilities as other classes.  An enumeration
can be given constructors, instance variables, and methods.  It can
even implement interfaces.  Each enumeration constant is an object of
its enumeration type.  When an enumeration is given a constructor, the
constructor is called when each enumeration constant is created.
Also, each enumeration constant has its own copy of any instance
variables defined by the enumeration.

     enum Apple {
       Jonathon(10), GoldenDel(9), RedDel(12), Winesap(15), Cortland(8);
       private int price;
       Apple(int p) { price = p; }
       int getPrice() { return price; }
     }

     class EnumDemo {
       public static void main (String[] args) {
         Apple ap;
       }
     }

   In this example, the enumeration 'Apple' is given an instance
variable 'price', a constructor, and an instance method 'getPrice()'.
When the variable 'ap' is declared in 'main()', the constructor for
'Apple' is called once for each constant that is specified.  The
arguments to the constructor are placed in parentheses after the name
of each constant.  Thereafter, each enumeration constant has its own
copy of 'price', which can be obtained by calling the instance method
'getPrice()'.  In addition, there can be multiple overloaded
constructors just as for any other class.

Restrictions on Enums
---------------------

   * An enumeration cannot inherit another class.
   * An 'enum' cannot be a superclass ('enum' cannot be extended).

   The key is to remember that each enumeration constant is an object
of the class in which it is defined.


File: JavaSE9.info,  Node: Inherit Enum,  Prev: Enumerations as Class Types,  Up: Enumerations

10.4 Enumerations Inherit 'Enum'
================================

All enumerations automatically inherit from one superclass:
'java.lang.Enum'.  This class defines several methods that are
available for use by all enumerations.

'ordinal()' and 'compareTo()'
-----------------------------

 -- Method on Enum:
          final int
          ordinal ()
     The 'ordinal()' method returns a value that indicates an
     enumeration constant's position in the list of constants, called
     its "ordinal value".  In other words, calling 'ordinal()' returns
     the ordinal value of the invoking constant (zero indexed).

 -- Method on Enum:
          final int
          compareTo (enum-type E)
     The ordinal values of two constants can be compared using the
     'compareTo()' method.  Both the invoking constant and E must be
     of the same enumeration enum-type.  This method returns a
     negative value, a zero, or a positive value depending on whether
     the invoking constant's ordinal value is less than, equal to, or
     greater than the passed-in enumeration constant's ordinal value.

'equals()' and '=='
-------------------

 -- Method on Enum:
          boolean
          equals (enum-type E)
 -- Method on Enum:
          boolean
          == (enum-type E)
     Compare for equality an invoking enum constant with a referenced
     enum constant.

   An invoking enum constant can compare for equality itself with any
other object by using 'equals()' or, equivalently, '==', which
overrides the 'equals()' method defined in 'Object'.  'equals()' will
return true only if both objects refer to the same constant within the
same enumeration.  (In other words, 'equals' does not just compare
ordinal values in general.)


File: JavaSE9.info,  Node: Strings,  Next: Exploring java-lang,  Prev: Enumerations,  Up: Top

11 String Handling
******************


File: JavaSE9.info,  Node: Exploring java-lang,  Next: java util Collections,  Prev: Strings,  Up: Top

12 Exploring 'java.lang'
************************

Classes and interfaces defined by 'java.lang', which is automatically
imported into all programs.  Contains classes and interfaces that are
fundamental to all of Java programming.  Beginning with JDK 9, all of
'java.lang' is part of the 'java.base' module.

'java.lang' includes the following classes
------------------------------------------

   * Boolean
   * Byte
   * Character
        * Character.Subset
        * Character.UnicodeBlock
   * Class
   * ClassLoader
   * ClassValue
   * Compiler
   * Double
   * Enum
   * Float
   * InheritableThreadLocal
   * Integer
   * Long
   * Math
   * Module
        * ModuleLayer
        * ModuleLayer.Controller
   * Number
   * Object
   * Package
   * Process
        * ProcessBuilder
        * ProcessBuilder.Redirect
   * Runtime
        * RuntimePermission
        * Runtime.Version
   * SecurityManager
   * Short
   * StackFramePermission
   * StackTraceElement
   * StackWalker
   * StrictMath
   * String
        * StringBuffer
        * StringBuilder
   * System
        * System.LoggerFinder
   * Thread
        * ThreadGroup
        * ThreadLocal
   * Throwable
   * Void

'java.lang' includes the following interfaces
---------------------------------------------

   * Appendable
   * AutoClosable
   * CharSequence
   * Clonable
   * Comparable
   * Iterable
   * ProcessHandle
        * ProcessHandle.Info
   * Readable
   * Runnable
   * StackWalker.StackFrame
   * System.Logger
   * Thread.UncaughtExceptionHandler

* Menu:

* Primitive Wrappers::
* Iterable Interface::


File: JavaSE9.info,  Node: Primitive Wrappers,  Next: Iterable Interface,  Up: Exploring java-lang

12.1 Primitive Type Wrappers
============================

Java uses primitive types for 'int', 'char', etc.  for performance
reasons.  These primitives are not part of the object hierarchy; they
are passed by-value, not by reference.  Sometimes you may need to
create an object representation for a primitive type.  To store a
primitive in a class, you need to wrap the primitive type in a class.

   Java provides classes that correspond to each of the primitive
types.  These classes encapsulate or "wrap" the primitive types within
a class.  They are commonly referred to as "type wrappers".

* Menu:

* Number::
* Double and Float::
* isInfinite() and isNaN()::
* Byte Short Integer Long::
* Numbers to from String::


File: JavaSE9.info,  Node: Number,  Next: Double and Float,  Up: Primitive Wrappers

12.1.1 Number
-------------


File: JavaSE9.info,  Node: Double and Float,  Next: isInfinite() and isNaN(),  Prev: Number,  Up: Primitive Wrappers

12.1.2 Double and Float
-----------------------


File: JavaSE9.info,  Node: isInfinite() and isNaN(),  Next: Byte Short Integer Long,  Prev: Double and Float,  Up: Primitive Wrappers

12.1.3 isInfinite() and isNaN()
-------------------------------


File: JavaSE9.info,  Node: Byte Short Integer Long,  Next: Numbers to from String,  Prev: isInfinite() and isNaN(),  Up: Primitive Wrappers

12.1.4 Byte, Short, Integer, Long
---------------------------------


File: JavaSE9.info,  Node: Numbers to from String,  Prev: Byte Short Integer Long,  Up: Primitive Wrappers

12.1.5 Converting Numbers to and from String
--------------------------------------------


File: JavaSE9.info,  Node: Iterable Interface,  Prev: Primitive Wrappers,  Up: Exploring java-lang

12.2 The 'Iterable' Interface
=============================

'Iterable' must be implemented by any class whose objects will be used
by the for-each version of the 'for' loop.  In other words, for an
object to be used within a for-each style 'for' loop, its class must
implement 'Iterable'.  'Iterable' is a generic interface that has this
declaration:

     interface Iterable<T>

   Here, 'T' is the type of the object being iterated.  It defines one
abstract method, 'iterator()', which is declared as:

     Iterator<T> iterator()

   It returns an iterator to the elements contained in the invoking
object.

'Iterable' Default Methods
--------------------------

'forEach()'
...........

Beginning with JDK 8, 'Iterable' also defines two default methods.
The first is called 'forEach()':

     default void forEach(Consumer<? super T> action)

   For each element being iterated, 'forEach()' executes the code
specified by action.  ('Consumer' is a functional interface added by
JDK 8 and defined in 'java.util.function'.)

'spliterator()'
...............

The second default method is 'spliterator()':

     default Spliterator<T> spliterator()

   It returns a 'Spliterator' to the sequence being iterated.


File: JavaSE9.info,  Node: java util Collections,  Next: java util Utility Classes,  Prev: Exploring java-lang,  Up: Top

13 'java.util' -- Part 1: The Collections Framework
***************************************************

The package 'java.util' contains a large assortment of classes and
interfaces that support a braod range of functionality.  For example,
'java.util' has classes that

   * generate pseudorandom numnbers,
   * manage date and time,
   * observe events,
   * manipulate sets of bits,
   * tokenize strings, and
   * handle formatted data

Collections Framework
=====================

The 'java.util' package also contains one of Java's most powerful
subsystems: the Collections Framework.  This is a sophisticated
hierarchy of interfaces and classes that provide state-of-the-art
technology for managing groups of objects.  Beginning with JDK 9,
'java.util' is part of the 'java.base' module.

* Menu:

* Collections Overview::
* Collection Interfaces::
* Collection Classes::
* Accessing a Collection via Iterator::
* Spliterators::
* Storing User-Defined Classes::
* RandomAccess Interface::
* Working with Maps::
* Comparators::
* Collection Algorithms::
* Arrays Class::
* Legacy Classes and Interfaces::


File: JavaSE9.info,  Node: Collections Overview,  Next: Collection Interfaces,  Up: java util Collections

13.1 Collections Overview
=========================

The Java Collections Framework standardizes the way in whcih groups of
objects are handled by programs.  Collections were not part of the
original Java release, but were added by J2SE 1.2.  Prior to the
Collections Framework, Java provided ad hoc classes such as
'Dictionary', 'Vector', 'Stack', and 'Properties' to stored and
manipulate groups of objects.  These classes lacked a central unifying
theme.  The way that you used 'Vector' was different from the way that
you used 'Properties'.  This early, ad hoc approach was not designed
to be easily extended or adapted.  Collections were an answer to these
(and other) problems.

Collections Goals
-----------------

The Collections Framework was designed to meet several goals.
_First_, the framework had to be high-performance.  The
implementations for the fundamental collections (dynamic arrays,
linked lists, trees, and hash tables) are highly efficient.  You
seldom, if ever, need to code one of these "data engines" manually.
_Second_, the framework had to allow different types of collections to
work in a similar manner and with a high degree of interoperability.
_Third_, extending and/or adapting a collection had to be easy.
Toward this end, the entire Collections Framework is built upon a set
of standard interfaces.  Several standard implementations (such as
'LinkedList', 'HashSet', and 'TreeSet' of these interfaces are
provided that you may use as-is.  You may also implement your own
collection.  Various special-purpose implementations are created for
your convenience, and some partial implementations are provided that
make creating your own collection class easier.  _Finally_, mechanisms
were added that allow the integration of standard arrays into the
Collections Framework.

  1. high-performance
  2. interoperatibility
  3. standard interfaces and implementations; easily extensibible
  4. integration of arrays

Algorithms
----------

"Algorithms" are another important part of the collection mechanism.
Algorithms operate on collections and are defined as static methods
within the 'Collections' class.  Thus, they are available for all
collections.  Each collection class need not implement its own
versions.  The algorithms provide a standard means of manipulating
collections.

'Iterator' Interface
--------------------

Antoher item closely associated with the Collections Framework is the
'Iterator' interface.  An "iterator" offers a general-purpose
standardized way of accessing the elements within a collection, one at
a time.  Thus, an iterator provides a means of _enumerating the
contents of a collection_.  Because each collection provides an
iterator, the elements of any collection class can be accessed through
the methods defined by 'Iterator'.  Thus, with only small changes, the
code that cycles through a set can also be used to cycle through a
list.

'Splitarator'
-------------

JDK 8 added another type of iterator called a "spliterator".  These
are iterators that provide support for parallel iteration.  The
interfaces that support spliterators are 'Spliterator' and several
nested interfaces that support primitive types.  JDK 8 also added
iterator interfaces designed for use with primitive types such as
'PrimitiveIterator' and 'PrimitiveIterator.OfDouble'.

Map Interfaces and Classes
--------------------------

In addition to collections, the framework defines several map
interfaces and classes.  "Maps" store key/value pairs.  Although maps
are part of the Collections Framework, they are not "collections" in
the strict use of the term.  You can, however, obtain a
"collection-view" of a map.  Such a view contains the elements from
the map stored in a collection.  Thus, you can process the contents of
a map as a collection.


File: JavaSE9.info,  Node: Collection Interfaces,  Next: Collection Classes,  Prev: Collections Overview,  Up: java util Collections

13.2 The Collection Interfaces
==============================

The Collections Framework defines several core interfaces.  Beginning
with the collection interfaces is necessary because they determine the
fundamental nature of the collection classes.  The concrete classes
simply provide different implementations of the standard interfaces.
The interfaces that underpin collections are summarized:

'Collection'
     Enables you to work with groups of objects; it is at the top of
     the collections hierarchy.
'Deque'
     Extends 'Queue' to handle a double-ended queue.
'List'
     Extends 'Collection' to handle sequences (lists of objects).
'NavigableSet'
     Extends 'SortedSet' to handle retrieval of elements based on
     closest-match searchesl.
'Queue'
     Extends 'Collection' to handle special types of lists in which
     elements are removed only from the head.
'Set'
     Extends 'Collection' to handle sets, which must contain unique
     elements.
'SortedSet'
     Extends 'Set' to handle sorted sets

Table 13.1: Summary of 'Collection' Interfaces

   In addition to the collection interfaces, collections also use the
following interfaces:

   * 'Comparator' (defines how two objects are compared)
   * 'RandomAccess' (indicates that a collection supports efficient
     random access to its elements)
   * 'Iterator' (the iterators enumerate the objects within a
     collection)
   * 'ListIterator'
   * 'Spliterator'

Optional Interface Methods -- Modifiable Collections
----------------------------------------------------

To provide the greatest flexibility in their use, the collection
interfaces allow some methods to be optional.  The optional methods
enable you to modify the contents of a collection.  Collections that
support these methods are called "modifiable".  Collections that do
not allow their contents to be changed are called "unmodifiable".  If
an attempt is made to use one of these methods on an unmodifiable
collection, an 'UnsupportedOperationException' is thrown.  All of the
built-in collections are modifiable.

* Menu:

* Collection Interface::
* List Interface::
* Set Interface::
* SortedSed Interface::
* NavigableSet Interface::
* Queue Interface::
* Dequeue Interface::


File: JavaSE9.info,  Node: Collection Interface,  Next: List Interface,  Up: Collection Interfaces

13.2.1 The 'Collection' Interface
---------------------------------

The 'Collection' interface is the foundation upon which the
Collections Framework is build because it must be implemented by any
class that defines a collection.  'Collection' is a generic interface
that has this declaration:

     interface Collection<E>

   Here, 'E' specifies the type of objects that the collection will
hold.  'Collections' extends the 'Iterable' interface.  This means
that all collections can be cycled through by use of their for-each
style 'for' loop.  (Only classes that implement 'Iterable' can be
cycled through by the 'for'.  *Note Iterable Interface::.)

Collection Core Methods
-----------------------

'Collection' declares the core methods that all collecitons will have.
These methods are summarized in *note Table 13.2:
CollectionsCoreMethods.  Because all collections implement
'Collection', familiarity with its methods is necessary for a clear
understanding of the framework.  Several of these methods can throw an
'UnsupportedOperationException'.  This occurs if a collection cannot
be modified.  A 'ClassCastException' is generated when one object is
incompatible with another, such as when an attempt is made to add an
incompatible object to a collection.  A 'NullPointerException' is
thrown if an attempt is made to store a 'null' object and 'null'
elements are not allowed in the collection.  An
'IllegalArgumentException' is thrown if an invalid argument is used.
An 'IllegalStateException' is thrown if an attempt is made to add an
element to a fixed-length collection that is full.

boolean add(E obj)           Adds obj to the invoking collection.
                             Returns 'true' if obj was added to the
                             collection.  Returns 'false' if obj is
                             already a member of the collection and
                             the collection does not allow duplicates
boolean                      Adds all the elements of c to the
addAll(Collection<?          invoking collection.  Returns 'true' if
extends E> c)                the collection changed (i.e., the
                             elements were added).  Otherwise,
                             returns 'false'.
*FIXME*: continue adding methods

Table 13.2: The Methods Declared by 'Collection'

Adding and Removing Objects to and from Collections
---------------------------------------------------

Objects are added to a collection by calling 'add()' Notice that
'add()' takes an argument of type 'E', whcih means that objects added
to a collection must be compatible with the type of data expected by
the collection.  You can add the entire contents of one collection to
another by called 'addAll()'.

   You can remove an object by using 'remove()'.  To remove a group of
objects, call 'removeAll()'.  You can remove all elements except those
of a specified group by calling 'retainAll()'.  To remove an element
only if it satisfies some condition,you cna use 'removeIf()'.  To
empty a collection, call 'clear()'.

Determine Whether a Collection Contains an Object
-------------------------------------------------

You can determine whether a collection contains a specific object by
calling 'contains()'.  To determine whether one collection contains
all the members of another, call 'containsAll()'.  You can determine
when a collection is empty by calling 'isEmpty()'.  The number of
elements currently held in a collection can be determined by calling
'size()'.

'toArray()' Methods
-------------------

     Object[] toArray()
     <T> T[] toArray(T array[])

   The 'toArray()' methods return an array that contains the elements
stored in the collection.  The first returns an array of 'Object'.
The second returns an array of elements that have the same type as the
array specified as a parameter.  Normally, the second form is more
convenient because it returns the desired array type.  Often,
processing the contents of a collection by using array-like syntax is
advantageous.  By providing a pathway between collections and arrays,
you have the best of both.

Comparing Collections
---------------------

Two collections can be compared for equality by called 'equals()'.
The precise meaning of "equality" may differ from collection to
collection.

Collection Iterators
--------------------

Another important method is 'iterator()', which returns an iterator to
a collection.  The 'spliterator()' methods returns a spliterator to
the collection.  Iterators are frequently used when working with
collections.  Finally, the 'stream()' and 'parallelStream()' methods
return a 'Stream' that uses the collection as a source of elements.


File: JavaSE9.info,  Node: List Interface,  Next: Set Interface,  Prev: Collection Interface,  Up: Collection Interfaces

13.2.2 The 'List' Interface
---------------------------


File: JavaSE9.info,  Node: Set Interface,  Next: SortedSed Interface,  Prev: List Interface,  Up: Collection Interfaces

13.2.3 The 'Set' Interface
--------------------------


File: JavaSE9.info,  Node: SortedSed Interface,  Next: NavigableSet Interface,  Prev: Set Interface,  Up: Collection Interfaces

13.2.4 The 'SortedSet' Interface
--------------------------------


File: JavaSE9.info,  Node: NavigableSet Interface,  Next: Queue Interface,  Prev: SortedSed Interface,  Up: Collection Interfaces

13.2.5 The 'NavigableSet' Interface
-----------------------------------


File: JavaSE9.info,  Node: Queue Interface,  Next: Dequeue Interface,  Prev: NavigableSet Interface,  Up: Collection Interfaces

13.2.6 The 'Queue' Interface
----------------------------


File: JavaSE9.info,  Node: Dequeue Interface,  Prev: Queue Interface,  Up: Collection Interfaces

13.2.7 The 'Dequeue' Interface
------------------------------


File: JavaSE9.info,  Node: Collection Classes,  Next: Accessing a Collection via Iterator,  Prev: Collection Interfaces,  Up: java util Collections

13.3 The Collection Classes
===========================

Some collection classes provide full implementations that can be used
as-is.  Others are abstract, providing skeletal implementations that
are used as starting points for creating concrete collections.  As a
general rule, the collection classes are not synchronized, but it is
possible to obtain synchronized version.

Core Collection Classes
=======================

AbstractCollection           Implements most of the 'Collections'
                             interface
AbstractList                 Extends 'AbstractCollection' and
                             implments most of the 'List' interface
AbstractQueue                Extends 'AbstractCollection' and
                             implements parts of the 'Queue'
                             interface
*FIXME*: Complete entering
Classes

Table 13.3: Collection Core Classes


File: JavaSE9.info,  Node: Accessing a Collection via Iterator,  Next: Spliterators,  Prev: Collection Classes,  Up: java util Collections

13.4 Accessing a Collection via an Interator
============================================

Often you will want to cycle through the elements in a collection.
One way to do this is to employ an "iterator", which is an object that
implements either the 'Iterator' of the 'ListIterator' interface.
'Iterator' enables you to cycle through a collection, obtaining or
removing elements.  'ListIterator' extends 'Iterator' to allow
bidirectional traversal of a list, and the modification of elements.
'Iterator' and 'ListIterator' are generic interfaces which are
declared as shown:

     interface Iterator<E>
     interface ListIterator<E>

Here, 'E' specifies the type of objects being iterated.


File: JavaSE9.info,  Node: Spliterators,  Next: Storing User-Defined Classes,  Prev: Accessing a Collection via Iterator,  Up: java util Collections

13.5 Spliterators
=================


File: JavaSE9.info,  Node: Storing User-Defined Classes,  Next: RandomAccess Interface,  Prev: Spliterators,  Up: java util Collections

13.6 Storing User-Defined Classes in Collections
================================================


File: JavaSE9.info,  Node: RandomAccess Interface,  Next: Working with Maps,  Prev: Storing User-Defined Classes,  Up: java util Collections

13.7 RandomAccess Interface
===========================


File: JavaSE9.info,  Node: Working with Maps,  Next: Comparators,  Prev: RandomAccess Interface,  Up: java util Collections

13.8 Working with Maps
======================


File: JavaSE9.info,  Node: Comparators,  Next: Collection Algorithms,  Prev: Working with Maps,  Up: java util Collections

13.9 Comparators
================


File: JavaSE9.info,  Node: Collection Algorithms,  Next: Arrays Class,  Prev: Comparators,  Up: java util Collections

13.10 The Collection Algorithms
===============================


File: JavaSE9.info,  Node: Arrays Class,  Next: Legacy Classes and Interfaces,  Prev: Collection Algorithms,  Up: java util Collections

13.11 Arrays Class
==================


File: JavaSE9.info,  Node: Legacy Classes and Interfaces,  Prev: Arrays Class,  Up: java util Collections

13.12 Legacy Classes and Interfaces
===================================


File: JavaSE9.info,  Node: java util Utility Classes,  Next: Input/Output java.io,  Prev: java util Collections,  Up: Top

14 'java.util' -- Part 2: Utility Classes
*****************************************


File: JavaSE9.info,  Node: Input/Output java.io,  Next: NIO,  Prev: java util Utility Classes,  Up: Top

15 Input/Output -- 'java.io'
****************************

This chapter explores 'java.io', which provides support for I/O
operations.  Data is retrieved from an _input_ source.  The results of
a program are sent to an _output_ destination.  In Java, these sources
or destinations are defined very broadly.  Although physically
different, these devices are all handled by the same abstraction: the
"stream".  An I/O stream is a logical entity that either produces or
consumes information.  An I/O stream is linked to a physical device by
the Java I/O system.  All I/O streams behave in the same manner, even
if the phyiscal devices they are linked to differ.

   Beginning with version 1.4, a second I/O system was added to Java,
called NIO (which meant New I/O). NIO is packaged in 'java.nio' and
its subpackages.  The NIO is described in *note NIO::.

* Menu:

* I/O Classes and Interfaces::
* File::
* AutoCloseable Closeable Flushable Interfaces::
* I/O Exceptions::
* Closing a Stream::
* Stream Classes::
* Byte Streams::
* Character Streams::
* Console Class::
* Serialization::
* Stream Benefits::


File: JavaSE9.info,  Node: I/O Classes and Interfaces,  Next: File,  Up: Input/Output java.io

15.1 I/O Classes and Interfaces
===============================

* Menu:

* I/O Classes::
* I/O Interfaces::


File: JavaSE9.info,  Node: I/O Classes,  Next: I/O Interfaces,  Up: I/O Classes and Interfaces

15.1.1 I/O Classes Defined by 'java.io'
---------------------------------------

   * BufferedInputStream / BufferedOutputStream
   * BufferedReader / Buffered Writer
   * ByteArrayInputStream / ByteArrayOutputStream
   * CharArrayReader / CharArrayWriter
   * Console
   * DataInputStream / DataOutputStream
   * File
   * FileDescriptor
   * FileInputStream / FileOutputStream
   * FilePermission
   * FileReader / FileWriter
   * FilterInputStream / FilterOutputStream
   * FilterReader / FilterWriter
   * InputStream / OutputStream
   * InputStreamReader / OutputStreamWriter
   * LineNumberReader
   * ObjectInputFilter.Config
   * ObjectInputStream / ObjectOutputStream
   * ObjectInputStream.GetField / ObjectOutputStream.PutField
   * ObjectStreamClass
   * ObjectStreamField
   * PipedInputStream / PipedOutputStream
   * PipedReader / PipedWriter
   * PrintStream / PrintWriter
   * PushbackInputStream / PusbbackReader
   * RandomAccessFile
   * Reader / Writer
   * SequenceInputStream
   * SerializablePermission
   * StreamTokenizer
   * StringReader / StringWriter


File: JavaSE9.info,  Node: I/O Interfaces,  Prev: I/O Classes,  Up: I/O Classes and Interfaces

15.1.2 I/O Interfaces Defined by 'java.io'
------------------------------------------

   * Closeable
   * DataInput / DataOutput
   * Externalize
   * FileFilter
   * FilenameFilter
   * Flushable
   * ObjectInput / ObjectOutput
   * ObjectInputFilter
   * ObjectInputFilter.FilterInfo
   * ObjectInputValidation
   * ObjectStreamConstants
   * Serializable


File: JavaSE9.info,  Node: File,  Next: AutoCloseable Closeable Flushable Interfaces,  Prev: I/O Classes and Interfaces,  Up: Input/Output java.io

15.2 File
=========

The 'File' class does not operate on streams.  It deals directly with
files and the file system.  The 'File' class does not specify how
information is retrieved from or stored in files; rather, it describes
the properties of a file itself.  A 'File' object is used to obtain or
manipulate the information associated with a disk file, such as the
permissions, time, date, and directory path, and to navigate
subdirectory hierarchies.(1)

Files and Directories in Java
-----------------------------

Files are a primary source and destination for data within programs.
Files are a central resource for storing persistent and shared
information.  A directory in Java is treated simply as a 'File' with
one additional property -- a list of filenames that can be examined by
the 'list()' method.

Constructors Used to Create 'File' Objects
------------------------------------------

   * File(String directoryPath)
   * File(String directoryPath, String filename)
   * File(File dirObj, String filename)
   * File(URI uriObj)

   dirObj is a 'File' object that specifies a directory, while uriObj
is a 'URI' object that describes a file.

Examples Creating Files and Directories
---------------------------------------

The following example creates three files.  The first 'File' object is
constructed with a directory path as the only argument.  The second
includes two arguments -- the path and the filename.  The third
includes the file path assigned to 'f1' and a filename; 'f3' refers to
the same file as 'f2'.

     File f1 = new File("/");
     File f2 = new File("/", "autoexec.bat");
     File f3 = new File(f1, "autoexec.bat");

* Menu:

* File Methods::
* File Utility Methods::
* Directories::
* Examine Directory Contents::
* FilenameFilter::
* Example Using FilenameFilter Interface::
* listFiles() Alternative::
* Creating Directories::

   ---------- Footnotes ----------

   (1) The 'Path' interface and 'Files' class, part of the NIO system,
offer a powerful alternative to 'File'.  *Note NIO::.


File: JavaSE9.info,  Node: File Methods,  Next: File Utility Methods,  Up: File

15.2.1 'File' Methods
---------------------

'File' defines many methods that obtain the standard properties of a
'File' object.

'getName()'
     returns the name of the file
'getParent()'
     returns the name of the parent directory
'getPath()'
'getAbsolutePath()'
     returns the path
'exists()'
     returns 'true' if the file exists, 'false' if it does not
'canWrite()'
'canRead()'
     returns whether the file is writeable/readable
'isDirectory()'
     returns whether the file is a directory
'isFile()'
     returns whether the file is a regular file ('true') or a non-file
     ('false') such as directory, device drivers, named pipes, etc.
'isAbsolute()'
     returns whether the file is an absolute path ('true') or a
     relative path ('false')
'lastModified()'
     returns the modification date and time
'length()'
     returns the file's size

Table 15.1: 'File' Property Methods


File: JavaSE9.info,  Node: File Utility Methods,  Next: Directories,  Prev: File Methods,  Up: File

15.2.2 'File' Utility Methods
-----------------------------

'renameTo()'
     boolean renameTo(File newName); returns 'true' upon success or
     'false' if the file cannot be renamed
'delete()'
     boolean delete(); deletes a file or directory (if the directory
     is empty); returns 'true' if it successfully deletes or 'false'
     if the file or directory cannot be removed;
'deleteOnExit()'
     removes the file associated with the invoking object when the
     Java Virtual Machines terminates
'getFreeSpace()'
     returns the number of free bytes of storage (as a 'long')
     available on the partition associated with the invoking object
'getTotalSpace()'
     returns the stoarage capacity (as a 'long') of the partition
     associated with the invoking object
'getUsableSpace()'
     returns the number of usable free bytes of storage (as a 'long')
     available on the partition associated with the invoking object
'isHidden()'
     returns 'true' if the invoking file is hidden, or 'false'
     otherwise
'setLastModifiedTime()'
     sets the time stamp on the invoking file to that specified by the
     arguement ('long' millisec), which is the number of milliseconds
     from January 1, 1970, UTC
'setReadOnly()'
     sets the invoking to read-only; returns 'true' on success
'readable()'
'writeable()'
'executable()'

'compareTo()'
     because 'File' implements the 'Comparable' interface
'toPath()'
     returns a 'Path' object that represents the file encapsulated by
     the invoking 'File' object; (in other words, 'toPath()' converts
     a 'File' into a 'Path');(1)
'mkdir()'
'mkdirs()'
     the first creates a directory, returning 'true' on success and
     'false' on failure; use the second to create a directory for
     which no path exists; it creates both a directory and all the
     parents of the directory;

Table 15.2: File Utility Methods

   ---------- Footnotes ----------

   (1) 'toPath()' forms a bridge between the older 'File' class and
the newer 'Path' interface; *Note NIO::.


File: JavaSE9.info,  Node: Directories,  Next: Examine Directory Contents,  Prev: File Utility Methods,  Up: File

15.2.3 Directories
------------------

A "directory" is a 'File' that contains a list of other files and
directories.  When you create a 'File' object that is a directory, the
'isDirectory()' method will return true.  In this case, you can call
'list()' on that object to extract the list of other files and
directories inside.  It has two forms.  Here is the more general form:

 -- Method on File:
          String[]
          list ()
     'list()' is used to extract the list of other files and
     directories inside the calling File object

GeneralForm 15.1: Obtaining a list of files in a directory


File: JavaSE9.info,  Node: Examine Directory Contents,  Next: FilenameFilter,  Prev: Directories,  Up: File

15.2.4 Using 'list()' to Examine Directory Contents
---------------------------------------------------

This program illustrates how to use 'list()' to examine the contents
of a directory.

{'DirList.java'} ==
     <Import java.io.File>
     class DirList {
       public static void main(String[] args) {
         <DirList Instance Variable Declarations>
         <DirList Examine Directory Contents>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<DirList Examine          See
Directory Contents>       *note DirList-Examine-Directory-Contents::.
<DirList Instance         See
Variable Declarations>    *note DirList-Instance-Variable-Declarations::.
<Import java.io.File>     See *note Import-java-io-File::.

* Menu:

* Import java.io.File::
* DirList Instance Variable Declarations::
* DirList Examine Directory Contents::
* Examine Directory Contents For-Loop::
* DirList Obtain Directory From Command-Line Args::


File: JavaSE9.info,  Node: Import java.io.File,  Next: DirList Instance Variable Declarations,  Up: Examine Directory Contents

15.2.4.1 Import 'java.io.File'
..............................

<Import java.io.File> ==
     import java.io.File;


This chunk is called by {'DirList.java'}; see its first definition at
*note DirList-java::.


File: JavaSE9.info,  Node: DirList Instance Variable Declarations,  Next: DirList Examine Directory Contents,  Prev: Import java.io.File,  Up: Examine Directory Contents

15.2.4.2 DirList Instance Variable Declarations
...............................................

<DirList Instance Variable Declarations> ==
     <DirList Obtain Directory From Command-Line Args>
     String dirname = args[0];
     File f1 = new File(dirname);


This chunk is called by {'DirList.java'}; see its first definition at
*note DirList-java::.

The called chunk <DirList Obtain Directory From Command-Line Args> is
first defined at *note
DirList-Obtain-Directory-From-Command-Line-Args::.


File: JavaSE9.info,  Node: DirList Examine Directory Contents,  Next: Examine Directory Contents For-Loop,  Prev: DirList Instance Variable Declarations,  Up: Examine Directory Contents

15.2.4.3 DirList Examine Directory Contents
...........................................

<DirList Examine Directory Contents> ==
     if (f1.isDirectory()) {
       System.out.println("Directory of " + dirname);

       String[] s = f1.list();

       <DirList Examine Directory Contents For-Loop>

     } else {
       System.out.println(dirname + " is not a directory");
     }


This chunk is called by {'DirList.java'}; see its first definition at
*note DirList-java::.

The called chunk <DirList Examine Directory Contents For-Loop> is
first defined at *note DirList-Examine-Directory-Contents-For-Loop::.


File: JavaSE9.info,  Node: Examine Directory Contents For-Loop,  Next: DirList Obtain Directory From Command-Line Args,  Prev: DirList Examine Directory Contents,  Up: Examine Directory Contents

15.2.4.4 Examine Directory Contents For-Loop
............................................

<DirList Examine Directory Contents For-Loop> ==
     for (int i = 0; i < s.length; i++) {
       File f = new File(dirname + "/" + s[i]);

       if (f.isDirectory()) {
         System.out.println(s[i] + " is a directory");
       } else {
         System.out.println(s[i] + " is a file");
       }
     }


This chunk is called by <DirList Examine Directory Contents>; see its
first definition at *note DirList-Examine-Directory-Contents::.


File: JavaSE9.info,  Node: DirList Obtain Directory From Command-Line Args,  Prev: Examine Directory Contents For-Loop,  Up: Examine Directory Contents

15.2.4.5 DirList Obtain Directory From Command-Line Args
........................................................

<DirList Obtain Directory From Command-Line Args> ==
     if (args.length != 1) {
       System.out.println("Usage: java DirList <directory>");
       return;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<DirList Instance         See
Variable Declarations>    *note DirList-Instance-Variable-Declarations::.
{'DirListOnly'}           See *note DirListOnly::.


File: JavaSE9.info,  Node: FilenameFilter,  Next: Example Using FilenameFilter Interface,  Prev: Examine Directory Contents,  Up: File

15.2.5 Using 'FilenameFilter'
-----------------------------

You can limit the number of files returned by the 'list()' method to
include only those files that match a certain filename pattern, or
"filter".  To do this, use a second form of list:

 -- Method on File:
          String[]
          list (FilenameFilter FFOBJ)
     Returns an array of String filenames found in the directory named
     by the calling File object

GeneralForm 15.2: Obtaining a filtered list of files in a directory

   Here, FFObj is an object of a class that implements the
'FilenameFilter' interface.  This interface defines a single method,
'accept()', whcih is called once for each file in a list.  It's
general form is given here:

 -- Method on FilenameFilter:
          boolean
          accept (File DIRECTORY, String FILENAME)
     The 'accept()' method returns 'true' for files in the directory
     specified by the DIRECTORY that should be included in the list
     (that is, those that match the FILENAME argument) and returns
     'false' for those files that should be excluded.

GeneralForm 15.3: 'accept()' Form to be used with 'list()'


File: JavaSE9.info,  Node: Example Using FilenameFilter Interface,  Next: listFiles() Alternative,  Prev: FilenameFilter,  Up: File

15.2.6 Example Program Using FilenameFilter Interface
-----------------------------------------------------

The 'OnlyExt' class implements 'FilenameFilter' by defining an
'accept()' method, which will be used by a variation of the preceding
program listing the contents of a directory to filter the directory
listing.

OnlyExt Class
.............

{'OnlyExt.java'} ==
     <Import java.io>
     public class OnlyExt implements FilenameFilter {
       <OnlyExt Instance Variable Declarations>
       <OnlyExt Constructor>
       <OnlyExt Accept Method Implementation>
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Import java.io>          See *note Import-java-io::.
<OnlyExt Accept Method    See
Implementation>           *note OnlyExt-Accept-Method-Implementation::.
<OnlyExt Constructor>     See *note OnlyExt-Constructor::.
<OnlyExt Instance         See
Variable Declarations>    *note OnlyExt-Instance-Variable-Declarations::.

DirListOnly Class
.................

This class now 'list()'s the directory contents by including the
'FilenameFilter' object from 'OnlyExt'.

{'DirListOnly'} ==
     <Import java.io>
     class DirListOnly {
       public static void main(String[] args) {
         <DirList Obtain Directory From Command-Line Args>
         <DirListOnly FilenameFilter Object>
         <DirListOnly FilenameFilter Object List>
         <DirListOnly Print List>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<DirList Obtain           See
Directory From            *note DirList-Obtain-Directory-From-Command-Line-Args::.
Command-Line Args>
<DirListOnly              See
FilenameFilter Object>    *note DirListOnly-FilenameFilter-Object::.
<DirListOnly              See
FilenameFilter Object     *note DirListOnly-FilenameFilter-Object-List::.
List>
<DirListOnly Print        See *note DirListOnly-Print-List::.
List>
<Import java.io>          See *note Import-java-io::.

* Menu:

* DirListOnly FilenameFilter Object::
* DirListOnly FilenameFilter Object List::
* DirListOnly Print List::
* OnlyExt Instance Variable Declarations::
* OnlyExt Constructor::
* OnlyExt Accept Method Implementation::


File: JavaSE9.info,  Node: DirListOnly FilenameFilter Object,  Next: DirListOnly FilenameFilter Object List,  Up: Example Using FilenameFilter Interface

15.2.6.1 DirListOnly FilenameFilter Object
..........................................

<DirListOnly FilenameFilter Object> ==
     FilenameFilter only = new OnlyExt("html");


This chunk is called by {'DirListOnly'}; see its first definition at
*note DirListOnly::.


File: JavaSE9.info,  Node: DirListOnly FilenameFilter Object List,  Next: DirListOnly Print List,  Prev: DirListOnly FilenameFilter Object,  Up: Example Using FilenameFilter Interface

15.2.6.2 DirListOnly FilenameFilter Object List
...............................................

Recallthe corresopnding line in the 'DirList' program: *Note DirList
Examine Directory Contents::.

<DirListOnly FilenameFilter Object List> ==
     String[] s = f1.list(only);


This chunk is called by {'DirListOnly'}; see its first definition at
*note DirListOnly::.


File: JavaSE9.info,  Node: DirListOnly Print List,  Next: OnlyExt Instance Variable Declarations,  Prev: DirListOnly FilenameFilter Object List,  Up: Example Using FilenameFilter Interface

15.2.6.3 DirListOnly Print List
...............................

<DirListOnly Print List> ==
     for (int i = 0; i < s.length; i++) {
       System.out.println(s[i]);
     }


This chunk is called by {'DirListOnly'}; see its first definition at
*note DirListOnly::.


File: JavaSE9.info,  Node: OnlyExt Instance Variable Declarations,  Next: OnlyExt Constructor,  Prev: DirListOnly Print List,  Up: Example Using FilenameFilter Interface

15.2.6.4 OnlyExt Instance Variable Declarations
...............................................

<OnlyExt Instance Variable Declarations> ==
     String ext;


This chunk is called by {'OnlyExt.java'}; see its first definition at
*note OnlyExt-java::.


File: JavaSE9.info,  Node: OnlyExt Constructor,  Next: OnlyExt Accept Method Implementation,  Prev: OnlyExt Instance Variable Declarations,  Up: Example Using FilenameFilter Interface

15.2.6.5 OnlyExt Constructor
............................

<OnlyExt Constructor> ==
     public OnlyExt(String ext) {
       this.ext = "." + ext;
     }


This chunk is called by {'OnlyExt.java'}; see its first definition at
*note OnlyExt-java::.


File: JavaSE9.info,  Node: OnlyExt Accept Method Implementation,  Prev: OnlyExt Constructor,  Up: Example Using FilenameFilter Interface

15.2.6.6 OnlyEct Accept Method Implementation
.............................................

<OnlyExt Accept Method Implementation> ==
     public boolean accept(File dir, String name) {
       return name.endsWith(ext);
     }


This chunk is called by {'OnlyExt.java'}; see its first definition at
*note OnlyExt-java::.


File: JavaSE9.info,  Node: listFiles() Alternative,  Next: Creating Directories,  Prev: Example Using FilenameFilter Interface,  Up: File

15.2.7 'listFiles()' Alternative
--------------------------------

There is a variation to the 'list()' method, called 'listFiles()',
that might be useful.

 -- Method on File:
          File[]
          listFiles ()
 -- Method on File:
          File[]
          listFiles (FilenameFilter FFOJB)
 -- Method on File:
          File[]
          listFiles (FileFilter FOJB)
     These methods return the file list as an array of 'File' objects
     instead of Strings.  The first method returns all files, and the
     second returns those files that satisfy the specified
     'FilenameFilter'.  The third version of 'listFiles()' returns
     those files with path names that satisfy the specified
     'FileFilter'.  'FileFilter' defines only a single method,
     'accept()', whcih is called once for each file in a list.  Its
     general form is shown below (*note GeneralForm 15.5:
     FileFilter-accept().).

GeneralForm 15.4: 'File.listFiles()' Form

FileFilter.accept()
-------------------

 -- Method on FileFilter:
          boolean
          accept (File PATH)
     Called once for each file in a list; it returns 'true' for files
     that should be included in the list (that is, those that match
     the PATH argument) and 'false' for those that should be excluded.

GeneralForm 15.5: FileFilter.accept() Method


File: JavaSE9.info,  Node: Creating Directories,  Prev: listFiles() Alternative,  Up: File

15.2.8 Creating Directories
---------------------------

   * boolean mkdir()
   * boolen mkdirs()


File: JavaSE9.info,  Node: AutoCloseable Closeable Flushable Interfaces,  Next: I/O Exceptions,  Prev: File,  Up: Input/Output java.io

15.3 The 'AutoCloseable', 'Closeable', and 'Flushable' Interfaces
=================================================================


File: JavaSE9.info,  Node: I/O Exceptions,  Next: Closing a Stream,  Prev: AutoCloseable Closeable Flushable Interfaces,  Up: Input/Output java.io

15.4 I/O Exceptions
===================

'IOException' and 'FileNotFoundException'
-----------------------------------------

Two exceptions play an important role in I/O handling.  The first is
'IOException'.  If an I/O error occurs, an 'IOException' is thrown.
In many cases, if a file cannot be opened, a 'FileNotFoundException'
is thrown.  'FileNotFoundException' is a subclass of 'IOException', so
both can be caught with a single 'catch' that catches 'IOException'.
You might find it useful to 'catch' each exception separately.

'SecurityException'
-------------------

'SecurityException'

   Another exception class that could occur during I/O is
'SecurityException'.  In situations in which a security manager is
present, several of the file classes will throw a 'SecurityException'
if a security violation occurs when attempting to open a file.  By
default, application run via 'java' do not use a security manager.
Other applications could generate a 'SecurityExcpetion', which will
need to be handled.


File: JavaSE9.info,  Node: Closing a Stream,  Next: Stream Classes,  Prev: I/O Exceptions,  Up: Input/Output java.io

15.5 Two Ways to Close a Stream
===============================

In general, a stream must be closed when it is no longer needed.
Failure to do so can lead to memory leaks and resource starvation.

Traditional Method with 'close()' in 'finally'
----------------------------------------------

Beginning with JDK 7, there are two basic ways in which you can close
a stream.  The first is to explicitly call 'close()' on the stream.
This is the traditional approach that has been used since the original
release of Java.  With this approach, 'close()' is typically called
within a 'finally' block.

     try {
       open and access file ...
     } catch (IOException) {
        handle IOException ...
     } finally {
        close the file ...
     }

GeneralForm 15.6: Simplified skeleton for traditional approach to
close a stream

'try-with-resources' Statement
------------------------------

The second approach to closing a stream is to automate the process by
using the 'try-with-resources' statement added by JDK 7.  The
'try-with-resources' is an enhanced form of 'try' with the following
form:

     try (resource-specification) {
       use the resource ...
     }

GeneralForm 15.7: Closing a file using 'try-with-resources' Statement

   Typically, _resource-specification_ is a statement or statements
that declare and initialize a resource, such as a file or other
stream-related resource.  It consists of a variable declaration in
which the variable is initialized with a reference to the object being
managed.  When the 'try' block ends, the resource is automatically
released.  In the case of a file, the file is automatically closed
(there is no need to call 'close()'.

'try-with-resources' Under JDK 9
--------------------------------

Beginning with JDK 9, it is also possible for the resource
specification of the 'try' to consist of a variable that has been
declared and initialized earlier in the program.  However, that
variable must be effectively 'final', which means that it has not been
assigned a new value after being given its initial value.

   Here are three key points about 'try-with-resources' statement:

   * Resources must be objects of classes the implement
     'AutoCloseable' interface
   * A resource declared in 'try' is _implicitly_ 'final', while a
     resource declared outside the 'try' must be _effectively_
     'final'.
   * More than one resource can be handled by separating each
     declaration with a semicolon.

Principal Advantages to using 'try-with-resources'
--------------------------------------------------

A principal advantage of 'try-with-resources' is that the resource is
closed automatically when the 'try' block ends.  Thus, it is not
possible to forget to close a stream.  Another advantage is that the
'try-with-resources' approach typically results in shorter, clear,
easier-to-maintain source code.


File: JavaSE9.info,  Node: Stream Classes,  Next: Byte Streams,  Prev: Closing a Stream,  Up: Input/Output java.io

15.6 The Stream Classes
=======================

Java's stream-based I/O is built upon four abstract classes:

   * Byte Streams
        * 'InputStream'
        * 'OutputStream'

   * Character Streams
        * 'Reader'
        * 'Writer'

The top-level classes define the basic functionality common to all
stream classes.  In general, you should use the character stream
classes when working with characters or strings and use the byte
stream classes when working with bytes or other binary objects.


File: JavaSE9.info,  Node: Byte Streams,  Next: Character Streams,  Prev: Stream Classes,  Up: Input/Output java.io

15.7 The Byte Streams
=====================

The byte stream classes provide an environment for handling
byte-oriented I/O. A byte stream can be used with any type of object,
including binary data.  The byte streams are topped by 'InputStream'
and 'OutputStream'.

* Menu:

* InputStream::
* OutputStream::
* FileInputStream::
* FileOutputStream::
* ByteArrayInputStream::
* ByteArrayOutputStream::
* Filtered Byte Streams::
* Buffered Byte Streams::
* SequenceInputStream::
* PrintStream::
* DataOutputStream DataInputStream::
* RandomAccessFile::


File: JavaSE9.info,  Node: InputStream,  Next: OutputStream,  Up: Byte Streams

15.7.1 'InputStream'
--------------------

'InputStream' is an abstract class that defines Java's model of
streaming byte input.  It implements the 'AutoCloseable' and
'Closeable' interfaces.  Most of the methods in this class will throw
an 'IOException' when an I/O error occurs.(1)

* Menu:

* InputStream Methods::

   ---------- Footnotes ----------

   (1) The exceptions are 'mark()' and 'markSupported()'.


File: JavaSE9.info,  Node: InputStream Methods,  Up: InputStream

15.7.1.1 'InputStream' Methods
..............................

int available()
     Returns the number of bytes of input currently available for
     reading
void close()
     Closes the input source.  Further read attempts will generate an
     'IOException'.
void mark(int numBytes)
     Places a mark at the current point in the input stream that will
     remain valid until numBytes bytes are read.
boolean markSupported()
     Returns 'true' if 'mark()' / 'reset()' are supported by the
     invoking stream.
int read()
     Returns an integer representation of the next available byte of
     input.  '-1' is returned when an attempt is made to read at the
     end of the stream.
int read(byte buffere[])
     Attempts to read up to buffer.length bytes into buffer and
     returns the actual number of bytes that were successfully read.
     '-1' is returned when an attempt is made to read at the end of
     the stream.
int read(byte buffer[], int offset, int numBytes)
     Attempts to read up to numBytes bytes into buffer starting at
     buffer[offset], returning the numnber of bytes successfully read.
     '-1' is returned when an attempt is made to read at the end of
     the stream.
byte[] readAllBytes()
     Beginning at the current position, reads to the end of the
     stream, returning a byte array that holds the input.  (Added by
     JDK 9.)
int readNBytes(byte buffer[], int offset, int numBytes)
     Attempts to read up to numBytes bytes into buffer starting at
     buffer[offset], returning the number of types successfully read.
     (Added by JDK 9.)
void reset()
     Resets the input pointer to the previously set mark.
long skip(long numBytes)
     Ignores (that is, skips) numBytes bytes of input, returning the
     number of bytes actually ignored.
long transferTo(OutputStream strm)
     Copies the bytes in teh invoking stream into strm, returning the
     number of bytes copies.  (Added by JDK 9.)

Table 15.3: The Methods Defined by 'InputStream'


File: JavaSE9.info,  Node: OutputStream,  Next: FileInputStream,  Prev: InputStream,  Up: Byte Streams

15.7.2 'OutputStream'
---------------------

'OutputStream' is an abstract class that defines streaming byte
output.  It implements 'AutoCloseable', 'Closeable', and 'Flushable'
interfaces.  Most of the methods defined by this class return 'void'
and throw an 'IOException' in the case of I/O errors.

* Menu:

* OutputStream Methods::


File: JavaSE9.info,  Node: OutputStream Methods,  Up: OutputStream

15.7.2.1 'OutputStream' Methods
...............................

void close()
     Closes the output stream.  Further write attempts will generate
     an 'IOException'.
void flush()
     Finalizes the output state so that any buffers are cleared (it
     flushes the output buffers).
void write(int b)
     Writes a single byte to an output stream.  Note that the
     parameter is an 'int', which allows you to call 'write()' with an
     expression without having to cast it back to 'byte'.
void write(byte buffer[])
     Writes a complete array of bytes to an output stream.
void write(byte buffer[], int offset, int numBytes)
     Writes a subrange of numBytes bytes from the array buffer,
     beginning at buffer[offset].

Table 15.4: The Methods Defined by 'OutputStream'


File: JavaSE9.info,  Node: FileInputStream,  Next: FileOutputStream,  Prev: OutputStream,  Up: Byte Streams

15.7.3 'FileInputStream'
------------------------

The 'FileInputStream' class creates an 'InputStream' that you can use
to read bytes from a file.  Two commonly used constructors are:

     FileInputStream(String filePath)
     FileInputStream(File fileObj)

   Either can throw a 'FileNotFoundException'.


File: JavaSE9.info,  Node: FileOutputStream,  Next: ByteArrayInputStream,  Prev: FileInputStream,  Up: Byte Streams

15.7.4 'FileOutputStream'
-------------------------


File: JavaSE9.info,  Node: ByteArrayInputStream,  Next: ByteArrayOutputStream,  Prev: FileOutputStream,  Up: Byte Streams

15.7.5 'ByteArrayInputStream'
-----------------------------


File: JavaSE9.info,  Node: ByteArrayOutputStream,  Next: Filtered Byte Streams,  Prev: ByteArrayInputStream,  Up: Byte Streams

15.7.6 'ByteArrayOutputStream'
------------------------------


File: JavaSE9.info,  Node: Filtered Byte Streams,  Next: Buffered Byte Streams,  Prev: ByteArrayOutputStream,  Up: Byte Streams

15.7.7 Filtered Byte Streams
----------------------------

"Filtered streams" are simply wrappers around underlying input or
output streams that transparently provide some extended level of
functionality.  These streams are typcially accessed by methods that
are expecting a generic stream, which is a superclass of the filtered
streams.  Typical extensions are buffering, character translation, and
raw data translation.  The filtered byte streams are:

   * 'FilterInputStream'
   * 'FilterOutputStream'

Their constructors are:

     FilterOutputStream (OutputStream os)
     FilterInputStream (InputStream is)


File: JavaSE9.info,  Node: Buffered Byte Streams,  Next: SequenceInputStream,  Prev: Filtered Byte Streams,  Up: Byte Streams

15.7.8 Buffered Byte Streams
----------------------------

For the byte-oriented streams, a "buffered stream" extends a filtered
stream class by attaching a memory buffer to the I/O stream.  This
buffer allows Java to do I/O operations on more than a byte at a time,
thereby improving performance.  Because the buffer is available,
skipping, marking, and resetting of the stream become possible.  The
buffered byte stream classes are:

   * 'BufferedInputStream'
   * 'BufferedOutputStream'
   * 'PushbackInputStream'

* Menu:

* BufferedInputStream::
* Buffered Input Example::
* BufferedInputStreamDemo Instance Variables::
* BufferedInputStreamDemo TryWithResources BufferedInputStream::
* BufferedInputStreamDemo While Loop::
* BufferedInputStreamDemo Switch on Character::
* BufferedInputStreamDemo String Into Buffer::
* BufferedInputStreamDemo Buffer::
* BufferedInputStreamDemo ByteArrayInputStream::
* BufferedInputStreamDemo Utility Variables::
* BufferedOutputStream::
* PushbackInputStream::


File: JavaSE9.info,  Node: BufferedInputStream,  Next: Buffered Input Example,  Up: Buffered Byte Streams

15.7.8.1 'BufferedInputStream'
..............................

Java's 'BufferedInputStream' class allows you to "wrap" any
'InputStream' into a buffered stream to improve performance.
'BufferedInputStream' has two constructors:

     BufferedInputStream (InputStream inputStream)
     BufferedInputStream (InputStream inputStream, int bufSize)

   The first form creates a buffered stream using a default buffer
size.  In the second, the size of the buffer is passed in bufSize.
Use of sizes that are multiples of a memory page, a disk block, and
son, can have a significant positive impact on performance.  A good
guess for a size is around 8,192 bytes, and attaching even a rather
small buffer to an I/O stream is always a good idea.  That way, the
low-level system can read blocks of data from the disk or network and
store the results in your buffer.  Thus, even if you are reading the
data a byte at a time out of the 'InputStream', you will be
manipulating fast memory most of the time.

   Buffering an input stream provides the foundation required to
support moving backward in the stream of the available buffer.  Beyond
the 'read()' and 'skip()' methods implemented in any 'InputStream',
'BufferedInputStream' also supports the 'mark()' and 'reset()'
methods.  This support is reflected by the
'BufferedInputStream.markSupported()' returning 'true'.


File: JavaSE9.info,  Node: Buffered Input Example,  Next: BufferedInputStreamDemo Instance Variables,  Prev: BufferedInputStream,  Up: Buffered Byte Streams

15.7.8.2 Buffered Input Example
...............................

The following example contrives a situation where we can use 'mark()'
to remember where we are in an input stream and later use 'reset()' to
get back there.  This example is parsing a stream for the HTML entity
reference for the "copyright" symbol.  Such a reference begins with an
ampersand ('&') and ends with a semicolon (';') without any
intervening whitespace.  The sample input has two ampersands to show
the case where the 'reset()' happens and where it does not.

=============================================================================

{'BufferedInputStreamDemo.java'} ==
     <Import java.io>
     class BufferedInputStreamDemo {
       public static void main(String[] args) {

         <BufferedInputStreamDemo Instance Variables>

         <BufferedInputStreamDemo TryWithResources BufferedInputStream>
         <Catch IOException>

       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BufferedInputStreamDemo  See
Instance Variables>       *note BufferedInputStreamDemo-Instance-Variables::.
<BufferedInputStreamDemo  See
TryWithResources          *note BufferedInputStreamDemo-TryWithResources-BufferedInputStream::.
BufferedInputStream>
<Catch IOException>       See *note Catch-IOException::.
<Import java.io>          See *note Import-java-io::.


File: JavaSE9.info,  Node: BufferedInputStreamDemo Instance Variables,  Next: BufferedInputStreamDemo TryWithResources BufferedInputStream,  Prev: Buffered Input Example,  Up: Buffered Byte Streams

15.7.8.3 BufferedInputStreamDemo Instance Variables
...................................................

<BufferedInputStreamDemo Instance Variables> ==
     <BufferedInputStreamDemo String>
     <BufferedInputStreamDemo Buffer>
     <BufferedInputStreamDemo ByteArrayInputStream>
     <BufferedInputStreamDemo Utility Variables>

This chunk is called by {'BufferedInputStreamDemo.java'}; see its
first definition at *note BufferedInputStreamDemo-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BufferedInputStreamDemo  See *note BufferedInputStreamDemo-Buffer::.
Buffer>
<BufferedInputStreamDemo  See
ByteArrayInputStream>     *note BufferedInputStreamDemo-ByteArrayInputStream::.
<BufferedInputStreamDemo  See *note BufferedInputStreamDemo-String::.
String>
<BufferedInputStreamDemo  See
Utility Variables>        *note BufferedInputStreamDemo-Utility-Variables::.


File: JavaSE9.info,  Node: BufferedInputStreamDemo TryWithResources BufferedInputStream,  Next: BufferedInputStreamDemo While Loop,  Prev: BufferedInputStreamDemo Instance Variables,  Up: Buffered Byte Streams

15.7.8.4 BufferedInputStreamDemo TryWithResources BufferedInputStream
.....................................................................

<BufferedInputStreamDemo TryWithResources BufferedInputStream> ==
     try (BufferedInputStream f = new BufferedInputStream(in)) {

       <BufferedInputStreamDemo While Loop>

     }


This chunk is called by {'BufferedInputStreamDemo.java'}; see its
first definition at *note BufferedInputStreamDemo-java::.

The called chunk <BufferedInputStreamDemo While Loop> is first defined
at *note BufferedInputStreamDemo-While-Loop::.


File: JavaSE9.info,  Node: BufferedInputStreamDemo While Loop,  Next: BufferedInputStreamDemo Switch on Character,  Prev: BufferedInputStreamDemo TryWithResources BufferedInputStream,  Up: Buffered Byte Streams

15.7.8.5 BufferedInputStreamDemo While Loop
...........................................

<BufferedInputStreamDemo While Loop> ==
     while ( (c = f.read()) != -1 ) {

        <BufferedInputStreamDemo Switch on Character>

     }


This chunk is called by <BufferedInputStreamDemo TryWithResources
BufferedInputStream>; see its first definition at *note
BufferedInputStreamDemo-TryWithResources-BufferedInputStream::.

The called chunk <BufferedInputStreamDemo Switch on Character> is
first defined at *note BufferedInputStreamDemo-Switch-on-Character::.


File: JavaSE9.info,  Node: BufferedInputStreamDemo Switch on Character,  Next: BufferedInputStreamDemo String Into Buffer,  Prev: BufferedInputStreamDemo While Loop,  Up: Buffered Byte Streams

15.7.8.6 BufferedInputStreamDemo Switch on Character
....................................................

<BufferedInputStreamDemo Switch on Character> ==
     switch (c) {
       case '&':
         if (!marked) {
           f.mark(32);
           marked = true;
         } else marked = false;
         break;

       case ';':
         if (marked) {
           marked = false;
           System.out.print("(c)");
         } else System.out.print( (char) c);
         break;

       case ' ':
         if (marked) {
           marked = false;
           f.reset();
           System.out.print("&");
         } else System.out.print( (char) c);
         break;

       default:
         if (!marked) System.out.print( (char) c);
         break;
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<BufferedInputStreamDemo  See
While Loop>               *note BufferedInputStreamDemo-While-Loop::.
<BufferedReaderDemo       See
TryWithResources          *note BufferedReaderDemo-TryWithResources-BufferedReader::.
BufferedReader>


File: JavaSE9.info,  Node: BufferedInputStreamDemo String Into Buffer,  Next: BufferedInputStreamDemo Buffer,  Prev: BufferedInputStreamDemo Switch on Character,  Up: Buffered Byte Streams

15.7.8.7 BufferedInputStreamDemo String Into Buffer
...................................................

<BufferedInputStreamDemo String> ==
     String s = "This is a &copy; copyright symbol " + "but this is &copy not.\n"

This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
<BufferedInputStreamDemo  See
Instance Variables>       *note BufferedInputStreamDemo-Instance-Variables::.
<BufferedReaderDemo       See
Instance Variables>       *note BufferedReaderDemo-Instance-Variables::.


File: JavaSE9.info,  Node: BufferedInputStreamDemo Buffer,  Next: BufferedInputStreamDemo ByteArrayInputStream,  Prev: BufferedInputStreamDemo String Into Buffer,  Up: Buffered Byte Streams

15.7.8.8 BufferedInputStreamDemo Buffer
.......................................

<BufferedInputStreamDemo Buffer> ==
     byte buf[] = s.getBytes();


This chunk is called by <BufferedInputStreamDemo Instance Variables>;
see its first definition at *note
BufferedInputStreamDemo-Instance-Variables::.


File: JavaSE9.info,  Node: BufferedInputStreamDemo ByteArrayInputStream,  Next: BufferedInputStreamDemo Utility Variables,  Prev: BufferedInputStreamDemo Buffer,  Up: Buffered Byte Streams

15.7.8.9 BufferedInputStreamDemo ByteArrayInputStream
.....................................................

<BufferedInputStreamDemo ByteArrayInputStream> ==
     ByteArrayInputStream in = new ByteArrayInputStream(buf);


This chunk is called by <BufferedInputStreamDemo Instance Variables>;
see its first definition at *note
BufferedInputStreamDemo-Instance-Variables::.


File: JavaSE9.info,  Node: BufferedInputStreamDemo Utility Variables,  Next: BufferedOutputStream,  Prev: BufferedInputStreamDemo ByteArrayInputStream,  Up: Buffered Byte Streams

15.7.8.10 BufferedInputStreamDemo Utility Variables
...................................................

<BufferedInputStreamDemo Utility Variables> ==
     int c;
     boolean marked = false;


This chunk is called by <BufferedInputStreamDemo Instance Variables>;
see its first definition at *note
BufferedInputStreamDemo-Instance-Variables::.


File: JavaSE9.info,  Node: BufferedOutputStream,  Next: PushbackInputStream,  Prev: BufferedInputStreamDemo Utility Variables,  Up: Buffered Byte Streams

15.7.8.11 'BufferedOutputStream'
................................


File: JavaSE9.info,  Node: PushbackInputStream,  Prev: BufferedOutputStream,  Up: Buffered Byte Streams

15.7.8.12 'PushbackInputStream'
...............................


File: JavaSE9.info,  Node: SequenceInputStream,  Next: PrintStream,  Prev: Buffered Byte Streams,  Up: Byte Streams

15.7.9 'SequenceInputStream'
----------------------------


File: JavaSE9.info,  Node: PrintStream,  Next: DataOutputStream DataInputStream,  Prev: SequenceInputStream,  Up: Byte Streams

15.7.10 'PrintStream'
---------------------


File: JavaSE9.info,  Node: DataOutputStream DataInputStream,  Next: RandomAccessFile,  Prev: PrintStream,  Up: Byte Streams

15.7.11 'DataOutputStream' and 'DataInputStream'
------------------------------------------------


File: JavaSE9.info,  Node: RandomAccessFile,  Prev: DataOutputStream DataInputStream,  Up: Byte Streams

15.7.12 'RandomAccessFile'
--------------------------


File: JavaSE9.info,  Node: Character Streams,  Next: Console Class,  Prev: Byte Streams,  Up: Input/Output java.io

15.8 The Character Streams
==========================

While th byte stream classes provide sufficient functionality to
handle any type of I/O operation, they cannot work directly with
Unicode characters.  Since one of the purposes of Java is to support
the "write once, run anywhere" philosophy, it was necessary to include
direction I/O support for characters.  In this section, several of the
character I/O classes are discussed.

   At the top of the character stream hierarchies are the

   * 'Reader'
   * 'Writer'

abstract classes.

* Menu:

* Reader::
* Writer::
* FileReader::
* FileWriter::
* CharArrayReader::
* CharArrayWriter::
* BufferedReader::
* Buffered Reader Demo::
* BufferedWriter::
* PushbackReader::
* PrintWriter::


File: JavaSE9.info,  Node: Reader,  Next: Writer,  Up: Character Streams

15.8.1 'Reader'
---------------

'Reader' is an abstact class that defines Java's model of streaming
character input.  It implements the 'AutoCloseable', 'Closeable', and
'Readable' interfaces.  All of the methods in this class (except
'markSupported()') will throw an 'IOException' on error conditions.

Reader Methods
..............

abstract void close()
     Closes the input source.  Further read attempts will general an
     'IOException'.
void mark(int numChars)
     Places a mark at the current point in the input stream that will
     remain valid until numChars characters are read.
boolean markSupported()
     Returns 'true' if 'mark()'/'reset()' are supported on this
     stream.
int read(char buffer[])
     Attempts to read up to buffer.length characters into buffer and
     returns the actual number of characters that were successfully
     read.  '-1' is returned when an attempt is made to read at the
     end of the stream.
int read(CharBuffer buffer)
     Attempts to read characters into buffer and returns the actual
     number of characters that were successfully read.  '-1' is
     returned when an attempt is made to read at the end of the
     stream.
abstract int read(char buffer[], int offset, int numChars)
     Attempts to read up to numChars characters into buffer starting
     at buffer[offset], returning the number of characters
     successfully read.  '-1' is returned whn an attempt is made to
     read at the end of the stream.
boolean read()
     Returns 'true' if the next input request will not wait.
     Otherwise, it returns 'false'.
void reset()
     Resets the input pointer to the previously set mark.
long skip(long numChars)
     Skips over numChars characters of input, returning the number of
     characters actually skipped.

Table 15.5: The Methods Defined by 'Reader'


File: JavaSE9.info,  Node: Writer,  Next: FileReader,  Prev: Reader,  Up: Character Streams

15.8.2 'Writer'
---------------

'Writer' is an abstract class that defines streaming character output.
It implements the 'AutoCloseable', 'Closeable', 'Flushable', and
'Appendable' interfaces.  All of the methods in this class throw an
'IOException' in the case of errors.

'Writer' Methods
................

Writer append(char ch)
     Appends ch tot he end of the invoking output stream.  Returns a
     reference to the invoking stream.
Writer append(CharSequence chars)
     Appends chars to the end of the invoking output stream.  Returns
     a reference to the invoking stream.
Writer append(CharSequence chars, int begin, int end)
     Appends the subrange of chars specified by begin and end - 1 to
     the end of the invoking output stream.  Returns a refernce to the
     invoking stream.
abstract void close()
     Closes the output stream.  Further write attempts will generate
     an 'IOException'.
abstract void flush()
     Finalizes the output state so that any buffers are cleared (it
     flushes the output buffers).
void write(int ch)
     Writes a single character to the invoking output stream.  The
     parameter is an 'int', whcih allows you to call 'write()' with an
     expression without have to case it back to 'char'.  However, only
     the low-order 16 bits are written.
void write(char buffer[])
     Writes a complete array of characters to the invoking output
     stream.
abstract void(char buffer[], int offset, int numChars)
     Writes a subrange of numChars characters from the array buffer,
     beginning at buffer[offset] to the invoking output stream.
void write(String str)
     Writes str to the invoking output stream.
void write(String str, int offset, int numChars)
     Writes a subrange of numChars characters from the string str,
     beginning at the specified offset

Table 15.6: The Methods Defined by Writer


File: JavaSE9.info,  Node: FileReader,  Next: FileWriter,  Prev: Writer,  Up: Character Streams

15.8.3 'FileReader'
-------------------

The 'FileReader' class creates a 'Reader' that you can use to read the
contents of a file.  Two commonly used constructors are:

     FileReader (String filePath)
     FileReader (File fileObj)

   Either can throw a 'FileNotFoundException'.

Example Reading Lines From a File
.................................

This example shows how to read lines from a file and display them on
the standard output device.  It reads its own source file, which must
be in the current directory.

=========================================================================

{'FileReaderDemo.java'} ==
     <Import java.io>
     class FileReaderDemo {
       public static void main (String[] args) {
         <FileReaderDemo TryWithResources FileReader>
         <Catch IOException>
       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Catch IOException>       See *note Catch-IOException::.
<FileReaderDemo           See
TryWithResources          *note FileReaderDemo-TryWithResources-FileReader::.
FileReader>
<Import java.io>          See *note Import-java-io::.

* Menu:

* FileReaderDemo TryWithResources FileReader::
* Catch IOException::


File: JavaSE9.info,  Node: FileReaderDemo TryWithResources FileReader,  Next: Catch IOException,  Up: FileReader

15.8.3.1 FileReaderDemo TryWtihResources FileReader
...................................................

<FileReaderDemo TryWithResources FileReader> ==
     try (FileReader fr = new FileReader("FileReaderDemo.java")) {
       int c;

       while ((c = fr.read()) != -1)
         System.out.print((char) c);
     }


This chunk is called by {'FileReaderDemo.java'}; see its first
definition at *note FileReaderDemo-java::.


File: JavaSE9.info,  Node: Catch IOException,  Prev: FileReaderDemo TryWithResources FileReader,  Up: FileReader

15.8.3.2 Catch IOException
..........................

<Catch IOException> ==
     catch (IOException e) {
       System.out.println("I/O Error: " + e);
     }


This chunk is called by the following chunks:

Chunk name                First definition point
-------------------------------------------------------------------------
{'BufferedInputStreamDemo.java'}See *note BufferedInputStreamDemo-java::.
{'BufferedReaderDemo.java'}See *note BufferedReaderDemo-java::.
{'FileReaderDemo.java'}   See *note FileReaderDemo-java::.


File: JavaSE9.info,  Node: FileWriter,  Next: CharArrayReader,  Prev: FileReader,  Up: Character Streams

15.8.4 'FileWriter'
-------------------

'FileWriter' creates a 'Writer' that you can use to write to a file.
Four commonly used constructors are:

     FileWriter (String filePath)
     FileWriter (String filePath, boolean append)
     FileWriter (File fileObj)
     FileWriter (File fileObj, boolean append)

They can all throw an 'IOException'.  If append is 'true', then output
is appended to the end of the file.  Creation of a 'FileWriter' is not
dependent on the file already existing.  'FileWriter' will create the
file before opening it for output when you create the object.  In the
case where you attept to open a read-only file, an 'IOException' will
be thrown.


File: JavaSE9.info,  Node: CharArrayReader,  Next: CharArrayWriter,  Prev: FileWriter,  Up: Character Streams

15.8.5 'CharArrayReader'
------------------------


File: JavaSE9.info,  Node: CharArrayWriter,  Next: BufferedReader,  Prev: CharArrayReader,  Up: Character Streams

15.8.6 'CharArrayWriter'
------------------------


File: JavaSE9.info,  Node: BufferedReader,  Next: Buffered Reader Demo,  Prev: CharArrayWriter,  Up: Character Streams

15.8.7 'BufferedReader'
-----------------------

'BufferedReader' improves performance by buffering input.  It has two
constructors:

     BufferedReader (Reader inputStream)
     BufferedReader (Reader inputStream, int bufSize)

   The first form creates a buffered character stream using a default
buffer size.  In the second, the size of the buffer is passed in
bufSize.  Closing a 'BufferedReader' also causes the underlying stream
specified by inputStream to be closed.

   Buffering an input character stream provides the foundation
required to support moving backward in the stream within the available
buffer.  To support this, 'BufferedReader' implements the 'mark()' and
'reset()' methods, and 'BufferedReader.markSupported()' returns
'true'.

   JDK 8 added a new method to 'BufferedReader' called 'lines()'.  It
returns a 'Stream' reference to the sequence of lines read by the
reader.  ('Stream' is part of the stream API discussed in *note
Streams API::.


File: JavaSE9.info,  Node: Buffered Reader Demo,  Next: BufferedWriter,  Prev: BufferedReader,  Up: Character Streams

15.8.8 Buffered Reader Demo
---------------------------

This example reworks the 'BufferedInputStream' example (*note Buffered
Input Example::) so that it uses a 'BufferedReader' character stream
rather than a buffered byte stream.  It uses the 'mark()' and
'reset()' methods to parse a stream for the HTML-entity reference for
the copyright symbol.  Such a reference begins with an ampersand ('&')
and ends with a semicolon (';') without any intervening whitespace.
The sample has two ampersands to show the case where the 'reset()'
happens and where it does not.

=============================================================================

{'BufferedReaderDemo.java'} ==
     <Import java.io>
     class BufferedReaderDemo {
       public static void main (String[] args) throws IOException {

         <BufferedReaderDemo Instance Variables>

         <BufferedReaderDemo TryWithResources BufferedReader>
         <Catch IOException>

       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BufferedReaderDemo       See
Instance Variables>       *note BufferedReaderDemo-Instance-Variables::.
<BufferedReaderDemo       See
TryWithResources          *note BufferedReaderDemo-TryWithResources-BufferedReader::.
BufferedReader>
<Catch IOException>       See *note Catch-IOException::.
<Import java.io>          See *note Import-java-io::.

* Menu:

* BufferedReaderDemo Instance Variables::
* BufferedReaderDemo Buffer::
* BufferedReaderDemo TryWithResources BufferedReader::


File: JavaSE9.info,  Node: BufferedReaderDemo Instance Variables,  Next: BufferedReaderDemo Buffer,  Up: Buffered Reader Demo

15.8.8.1 BufferedReaderDemo Instance Variables
..............................................

The String is copied directly from the prior implementation.

=========================================================================

<BufferedReaderDemo Instance Variables> ==
     <BufferedInputStreamDemo String>
     <BufferedReaderDemo Buffer>


This chunk is called by {'BufferedReaderDemo.java'}; see its first
definition at *note BufferedReaderDemo-java::.

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<BufferedInputStreamDemo  See *note BufferedInputStreamDemo-String::.
String>
<BufferedReaderDemo       See *note BufferedReaderDemo-Buffer::.
Buffer>


File: JavaSE9.info,  Node: BufferedReaderDemo Buffer,  Next: BufferedReaderDemo TryWithResources BufferedReader,  Prev: BufferedReaderDemo Instance Variables,  Up: Buffered Reader Demo

15.8.8.2 BufferedReaderDemo Buffer
..................................

Notice that this implementation uses a 'char' buffer, with a
'getChars()' method to transfer the string characters, while the
'BufferedInputStream' implementation uses a 'byte' buffer, and a
'getBytes()' method to transfer the string bytes.  *Note
BufferedInputStreamDemo Buffer::.

=========================================================================

<BufferedReaderDemo Buffer> ==
     char buf[] = new char[s.length()];
     s.getChars(0, s.length(), buf, 0);


This chunk is called by <BufferedReaderDemo Instance Variables>; see
its first definition at *note BufferedReaderDemo-Instance-Variables::.


File: JavaSE9.info,  Node: BufferedReaderDemo TryWithResources BufferedReader,  Prev: BufferedReaderDemo Buffer,  Up: Buffered Reader Demo

15.8.8.3 BufferedReaderDemo TryWithResources BufferedReader
...........................................................

Notice that the Switch code is identical to the byte stream example.

==========================================================================

<BufferedReaderDemo TryWithResources BufferedReader> ==
     try ( BufferedReader f = new BufferedReader(in) ) {
       while ( (c = f.read()) != -1 ) {
         <BufferedInputStreamDemo Switch on Character>
       }
     }


This chunk is called by {'BufferedReaderDemo.java'}; see its first
definition at *note BufferedReaderDemo-java::.

The called chunk <BufferedInputStreamDemo Switch on Character> is
first defined at *note BufferedInputStreamDemo-Switch-on-Character::.


File: JavaSE9.info,  Node: BufferedWriter,  Next: PushbackReader,  Prev: Buffered Reader Demo,  Up: Character Streams

15.8.9 'BufferedWriter'
-----------------------

A 'BufferedWriter' is a 'Writer' that buffers output.  Using a
'BufferedWriter' can improve performance by reducing the number of
times data is actually phyiscally written to the output device.  A
'BufferedWriter' has these constructors:

     BufferedWriter (Writer outputStream)
     BufferedWriter (Writer outputStream, int bufSize)


File: JavaSE9.info,  Node: PushbackReader,  Next: PrintWriter,  Prev: BufferedWriter,  Up: Character Streams

15.8.10 'PushbackReader'
------------------------


File: JavaSE9.info,  Node: PrintWriter,  Prev: PushbackReader,  Up: Character Streams

15.8.11 'PrintWriter'
---------------------


File: JavaSE9.info,  Node: Console Class,  Next: Serialization,  Prev: Character Streams,  Up: Input/Output java.io

15.9 The Console Class
======================


File: JavaSE9.info,  Node: Serialization,  Next: Stream Benefits,  Prev: Console Class,  Up: Input/Output java.io

15.10 Serialization
===================

"Serialization" is the process of writing the state of an object to a
byte stream.  This is useful when you want to save the state of your
program to a persistent storage area, such as a file.  At a later
time, you may restore these objects by using the process of
deserialization.

   Assume that an object to be serialized has references to other
objects, which, in turn, have references to still more objects.  This
set of objects and the relationships among them form a directed graph.
There may also be circular references within this object graph.
Objects may also contain references to themselves.  The object
serialization and deserialization facilities have been designed to
work correctly in these scenarios.  If you attempt to serialize an
object at the top of an object graph, all of the other referenced
objects are recurseively located and serialized.  Similarly, during
the process of deserialization, all of these objects and their
references are correctly restored.

* Menu:

* Serializable::
* Externalizable::
* ObjectOutput::
* ObjectOutputStream::
* ObjectInput::
* ObjectInputStream::
* Serializable Example::


File: JavaSE9.info,  Node: Serializable,  Next: Externalizable,  Up: Serialization

15.10.1 'Serializable'
----------------------

Only an object that implements the 'Serializable' interface can be
saved and restored by the serialization facilities.  The
'Serializable' interface defines no members.  It is simply used to
indicate that a class may be serialized.  If a class is serializable,
all of its subclasses are also serializable.

   Variables that are declared as 'transient' are not saved by the
serialization facilities.  Also 'static' variables are not saved.


File: JavaSE9.info,  Node: Externalizable,  Next: ObjectOutput,  Prev: Serializable,  Up: Serialization

15.10.2 'Externalizable'
------------------------

The Java facilities for serialization and deserialization have been
designed so that much of the work to save and restore the state of an
object occurs automatically.  However, there are cases in which the
programmer may need to have control over these processes.  The
'Externalizable' interface is designed for these sitautions.

   The 'Externalizable' interface defines these two methods:

     void readExternal (ObjectInput inStream) throws IOException, ClassNotFoundException
     void writeExternal (ObjectOutput outStream throws IOException


File: JavaSE9.info,  Node: ObjectOutput,  Next: ObjectOutputStream,  Prev: Externalizable,  Up: Serialization

15.10.3 'ObjectOutput'
----------------------


File: JavaSE9.info,  Node: ObjectOutputStream,  Next: ObjectInput,  Prev: ObjectOutput,  Up: Serialization

15.10.4 'ObjectOutputStream'
----------------------------


File: JavaSE9.info,  Node: ObjectInput,  Next: ObjectInputStream,  Prev: ObjectOutputStream,  Up: Serialization

15.10.5 'ObjectInput'
---------------------


File: JavaSE9.info,  Node: ObjectInputStream,  Next: Serializable Example,  Prev: ObjectInput,  Up: Serialization

15.10.6 'ObjectInputStream'
---------------------------


File: JavaSE9.info,  Node: Serializable Example,  Prev: ObjectInputStream,  Up: Serialization

15.10.7 A Serializable Example
------------------------------


File: JavaSE9.info,  Node: Stream Benefits,  Prev: Serialization,  Up: Input/Output java.io

15.11 Stream Benefits
=====================


File: JavaSE9.info,  Node: NIO,  Next: Networking,  Prev: Input/Output java.io,  Up: Top

16 NIO
******


File: JavaSE9.info,  Node: Networking,  Next: Event Handling,  Prev: NIO,  Up: Top

17 Networking
*************


File: JavaSE9.info,  Node: Event Handling,  Next: AWT,  Prev: Networking,  Up: Top

18 Event Handling
*****************


File: JavaSE9.info,  Node: AWT,  Next: AWT Controls,  Prev: Event Handling,  Up: Top

19 AWT: Working with Windows, Graphics, and Text
************************************************


File: JavaSE9.info,  Node: AWT Controls,  Next: Images,  Prev: AWT,  Up: Top

20 Using AWT Controls, Layout Managers, and Menus
*************************************************


File: JavaSE9.info,  Node: Images,  Next: Concurrency,  Prev: AWT Controls,  Up: Top

21 Images
*********


File: JavaSE9.info,  Node: Concurrency,  Next: Streams API,  Prev: Images,  Up: Top

22 The Concurrency Utilities
****************************


File: JavaSE9.info,  Node: Streams API,  Next: Regular Expressions,  Prev: Concurrency,  Up: Top

23 The Stream API
*****************


File: JavaSE9.info,  Node: Regular Expressions,  Next: Reflection,  Prev: Streams API,  Up: Top

24 Regular Expressions
**********************


File: JavaSE9.info,  Node: Reflection,  Next: Swing,  Prev: Regular Expressions,  Up: Top

25 Reflection
*************

"Reflection" is the ability of software to analyze or modify itself at
runtime rather than at compile time.  This is provided by the
'java.lang.reflect' package and elements in 'Class'.  Beginning with
JDK 9, 'java.lang.reflect' is part of the 'java.base' module.
Reflection allows you to analyze a software component and describe its
capabilities dynamcically at run-time rather than at compile time.
For example, by using reflection, you can determine what methods,
constructors, and fields a class supports.

Drawbacks of Reflection
=======================

Because reflection is dynamic, the java virtual machine is unable to
make certain optimizations and could therefor run slower.  Also, since
reflection allows code to perform operations that would be illegal in
non-reflective code, such as accessing private fields and methods, the
use of reflection can result in unexpected behavior.  Reflection
breaks abstractions.

* Menu:

* java.lang.reflect Package::
* Classes and Reflection::
* Members and Reflection::
* Arays and Enumerated Types and Reflection::


File: JavaSE9.info,  Node: java.lang.reflect Package,  Next: Classes and Reflection,  Up: Reflection

25.1 'java.lang.reflect' Package
================================

This package provides classes and interfaces for obtaining reflective
information about classes and objects.  Reflection allows programmatic
access to information about the fields, methods and constructors of
loaded classes, and the use of reflected fields, methods, and
constructors to operate on their underlying counterparts, within
encapsulation and security restrictions.

   The package 'java.lang.reflect' includes several interfaces.  Of
special interest is 'Member', which defines methods that allow you to
get information abouta field, constructor, or method of a class.
There are also ten classes in this package.

   Classes in this package, along with java.lang.Class accommodate
applications such as debuggers, interpreters, object inspectors, class
browsers, and services such as Object Serialization and JavaBeans that
need access to either the public members of a target object (based on
its runtime class) or the members declared by a given class.

   Note that none of the classes in 'java.lang.reflect' offer any
public constructors.  All reflection interactions must go through
'java.lang.Class'.  Note also that 'java.lang.Class' does not offer
any public constructors.  Instances of this class are created by the
Java Virtual Machine.

* Menu:

* Classes Defined in java-lang-reflect::
* Interfaces Defined in java-lang-reflect::
* Reflection Demonstration::


File: JavaSE9.info,  Node: Classes Defined in java-lang-reflect,  Next: Interfaces Defined in java-lang-reflect,  Up: java.lang.reflect Package

25.1.1 Classes Defined in 'java.lang.reflect'
---------------------------------------------

AccessibleObject
     Allows you to bypass the default access control checks
Array
     Allows you to dynamically create and manipulate arrays
Constructor
     Provides information about a constructor
Executable
     An abstract superclass extended by 'Member' and 'Constructor'
Field
     Provides information about a field
Method
     Provides information about a method
Modifier
     Provides information about class and member access modifiers
Parameter
     Provides information about parameters
Proxy
     Supports dynamic proxy classes
ReflectPermission
     Allows reflection of private or protected members of a class

Table 25.1: Classes Defined in 'java.lang.reflect'


File: JavaSE9.info,  Node: Interfaces Defined in java-lang-reflect,  Next: Reflection Demonstration,  Prev: Classes Defined in java-lang-reflect,  Up: java.lang.reflect Package

25.1.2 Interfaces Defined in 'java.lang.reflect'
------------------------------------------------

AnnotatedArrayType
     represents the potentially annotated use of an array type, whose
     component type may itself represent the annotated use of a type.
AnnotatedElement
     represents an annotated element of the program currently running
     in this VM.
AnnotatedParameterizedType
     represents the potentially annotated use of a parameterized type,
     whose type arguments may themselves represent annotated uses of
     types.
AnnotatedType
     represents the potentially annotated use of a type in the program
     currently running in this VM.
AnnotatedTypeVariable
     represents the potentially annotated use of a type variable,
     whose declaration may have bounds which themselves represent
     annotated uses of types.
AnnotatedWildcardType
     represents the potentially annotated use of a wildcard type
     argument, whose upper or lower bounds may themselves represent
     annotated uses of types.
GenericArrayType
     represents an array type whose component type is either a
     parameterized type or a type variable.
GenericDeclaration
     A common interface for all entities that declare type variables.
InvocationHandler
     the interface implemented by the invocation handler of a proxy
     instance.
Member
     an interface that reflects identifying information about a single
     member (a field or a method) or a constructor.
ParameterizedType
     ParameterizedType represents a parameterized type such as
     Collection<String>.
Type
     Type is the common superinterface for all types in the Java
     programming language.
TypeVariable<D extends GenericDeclaration>
     the common superinterface for type variables of kinds.
WildcardType
     WildcardType represents a wildcard type expression, such as ?, ?
     extends Number, or ?  super Integer.

Table 25.2: Interfaces Defined in 'java.lang.reflect'


File: JavaSE9.info,  Node: Reflection Demonstration,  Prev: Interfaces Defined in java-lang-reflect,  Up: java.lang.reflect Package

25.1.3 Reflection Demonstration
-------------------------------

The following application illustrates a simple use of the Java
reflection capabilities.  It prints the constructors, fields, and
methods of the class 'java.awt.Dimension'.  The program begins by
using the 'forName()' mthod of 'Class' to get a class object for
'java.awt.Dimension'.  Once this is obtained, 'getConstructors()',
'getFields()', and 'getMethods()' are used to analyze this class
object.  They return arrays of 'Constructor', 'Field', and 'Method'
objects that provide the information about the object.  The
'Constructor', 'Field', and 'Method' classes define several methods
that can be used to obtain information about an object.  Each supports
the 'toString()' method.  Therefore, using these objects as arguments
tot he 'println()' method is straightforward.

ReflectionDemo1.java
....................

{'ReflectionDemo1.java'} ==
     <Import java.lang.reflect>

     public class ReflectionDemo1 {
       public static void main(String[] args) {

         try {

           <ReflectionDemo1 Class forName Call>

           System.out.println("Constructors:");
           <ReflectionDemo1 getConstructors Call>

           System.out.println("Fields:");
           <ReflectionDemo1 getFields Call>

           System.out.println("Methods:");
           <ReflectionDemo1 getMethods Call>

         }
         <Catch Exception>

       }
     }


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Catch Exception>         See *note Catch-Exception::.
<Import                   See *note Import-java-lang-reflect::.
java.lang.reflect>
<ReflectionDemo1 Class    See
forName Call>             *note ReflectionDemo1-Class-forName-Call::.
<ReflectionDemo1          See
getConstructors Call>     *note ReflectionDemo1-getConstructors-Call::.
<ReflectionDemo1          See *note ReflectionDemo1-getFields-Call::.
getFields Call>
<ReflectionDemo1          See *note ReflectionDemo1-getMethods-Call::.
getMethods Call>

* Menu:

* ReflectionDemo1 Class forName Call::
* ReflectionDemo1 getConstructors Call::
* ReflectionDem1 getFields Call::
* ReflectionDemo1 getMethods Call::
* Catch Exception::
* Import java.lang.reflect::


File: JavaSE9.info,  Node: ReflectionDemo1 Class forName Call,  Next: ReflectionDemo1 getConstructors Call,  Up: Reflection Demonstration

25.1.3.1 ReflectionDemo1 Class forName Call
...........................................

<ReflectionDemo1 Class forName Call> ==
     Class<?> c = Class.forName("java.awt.Dimension");


This chunk is called by {'ReflectionDemo1.java'}; see its first
definition at *note ReflectionDemo1-java::.


File: JavaSE9.info,  Node: ReflectionDemo1 getConstructors Call,  Next: ReflectionDem1 getFields Call,  Prev: ReflectionDemo1 Class forName Call,  Up: Reflection Demonstration

25.1.3.2 ReflectionDemo1 getConstructors Call
.............................................

<ReflectionDemo1 getConstructors Call> ==
     Constructor<?> constructors[] = c.getConstructors();

     for (int i = 0; i < constructors.length; i++) {
       System.out.println(" " + constructors[i]);
     }


This chunk is called by {'ReflectionDemo1.java'}; see its first
definition at *note ReflectionDemo1-java::.


File: JavaSE9.info,  Node: ReflectionDem1 getFields Call,  Next: ReflectionDemo1 getMethods Call,  Prev: ReflectionDemo1 getConstructors Call,  Up: Reflection Demonstration

25.1.3.3 ReflectionDem1 getFields Call
......................................

<ReflectionDemo1 getFields Call> ==
     Filed fields[] = c.getFields();

     for (int i = 0; i < fields.length; i++) {
       System.out.println(" " + fields[i]);
     }


This chunk is called by {'ReflectionDemo1.java'}; see its first
definition at *note ReflectionDemo1-java::.


File: JavaSE9.info,  Node: ReflectionDemo1 getMethods Call,  Next: Catch Exception,  Prev: ReflectionDem1 getFields Call,  Up: Reflection Demonstration

25.1.3.4 ReflectionDemo1 getMethods Call
........................................

<ReflectionDemo1 getMethods Call> ==
     Method methods[] = c.getMethods();

     for (int i = 0; i < methods.length; i++) {
       System.out.print.n(" " + methods[i]);
     }


This chunk is called by {'ReflectionDemo1.java'}; see its first
definition at *note ReflectionDemo1-java::.


File: JavaSE9.info,  Node: Catch Exception,  Next: Import java.lang.reflect,  Prev: ReflectionDemo1 getMethods Call,  Up: Reflection Demonstration

25.1.3.5 Catch Exception
........................

<Catch Exception> ==
     catch (Exception e) {
       System.out.println("Exception: " + e);
     }


This chunk is called by {'ReflectionDemo1.java'}; see its first
definition at *note ReflectionDemo1-java::.


File: JavaSE9.info,  Node: Import java.lang.reflect,  Prev: Catch Exception,  Up: Reflection Demonstration

25.1.3.6 Import java.lang.reflect
.................................

<Import java.lang.reflect> ==
     import java.lang.reflect.*;


This chunk is called by {'ReflectionDemo1.java'}; see its first
definition at *note ReflectionDemo1-java::.


File: JavaSE9.info,  Node: Classes and Reflection,  Next: Members and Reflection,  Prev: java.lang.reflect Package,  Up: Reflection

25.2 Classes and Reflection
===========================

For every type of object, the Java virtual machine instantiates an
immutable instance of 'java.lang.Class' which provides methods to
examine the runtime properties of the object including its members and
type information.

   'Class' also provides the ability to create new classes and
objects.  Most importantly, it is the entry point for all of the
Reflective APIs.

* Menu:

* java.lang.Class::
* Retrieving Class Objects::
* Examining Class Modifiers::
* Discovering Class Members::


File: JavaSE9.info,  Node: java.lang.Class,  Next: Retrieving Class Objects,  Up: Classes and Reflection

25.2.1 'java.lang.Class'
------------------------

Instances of the class 'Class' represent classes and interfaces in a
running Java application.  An 'enum' is a kind of class and an
'annotation' is a kind of interface.  Every array also belongs to a
class that is reflected as a 'Class' object that is shared by all
arrays with the same element type and number of dimensions.  The
primitive Java types ('boolean', 'byte', 'char', 'short', 'int',
'long', 'float', and 'double'), and the keyword 'void' are also
represented as 'Class' objects.

   'Class' has no public constructor.  Instead 'Class' objects are
constructed automatically by the Java Virtual Machine as classes are
loaded and by calls to the 'defineClass' method in the class loader.

   The following example uses a Class object to print the class name
of an object:

     void printClassName(Object obj) {
              System.out.println("The class of " + obj +
                                 " is " + obj.getClass().getName());
          }

   It is also possible to get the 'Class' object for a named type (or
for 'void') using a class literal.

     System.out.println("The name of class Foo is: "+Foo.class.getName());

* Menu:

* Class Constructor::


File: JavaSE9.info,  Node: Class Constructor,  Up: java.lang.Class

25.2.1.1 'Class' getConstructor
...............................

 -- Constructor on Class:
          Constructor<T>
          getConstructor (parameterType)
     Returns a 'Constructor' object that reflects the specified public
     constructor of the class represented by this 'Class' object.

'Class' getConstructors
.......................

 -- Constructor on Class:
          Constructor<?>[]
          getConstructors ()
     Returns an array containing 'Constructor' objects reflecting all
     the public constructors of the class represented by this 'Class'
     object.


File: JavaSE9.info,  Node: Retrieving Class Objects,  Next: Examining Class Modifiers,  Prev: java.lang.Class,  Up: Classes and Reflection

25.2.2 Retrieving Class Objects
-------------------------------

The entry point for all reflection operations is 'java.lang.Class'.
None of the classes in 'java.lang.reflect' have public constructors.
(1) To get to these classes, it is necessary to invoke appropriate
methods on 'Class'.  There are several ways to get a 'Class' depending
on whether the code has access to an object, the name of the class, a
type, or an existing 'Class'.

* Menu:

* Object.getClass::
* .class Syntax::
* Class.forName() and Class.getName() Methods::
* TYPE Field for Primitive Wrappers::
* Methods that Return Classes::

   ---------- Footnotes ----------

   (1) with the exception of 'java.lang.reflect.ReflectPermission'.


File: JavaSE9.info,  Node: Object.getClass,  Next: .class Syntax,  Up: Retrieving Class Objects

25.2.2.1 'Object.getClass()'
............................

If an instance of an object is available, then the simplest way to get
its 'Class' is to invoke 'Object.getClass()'.

String.getClass()
.................

     Class c = "foo".getClass();

returns the 'Class' for 'String';

System.console.getClass()
.........................

     Class c = System.console().getClass();

returns the 'Class' corresponding to 'java.io.Console'.  (1)

Enum.getClass()
...............

     enum E { A, B }
     Class c  = A.getClass();

'A' is an instance of the 'enum' 'E'; thus, 'getClass()' returns the
'Class' corresponding to the enumeration type 'E'.

Array.getClass()
................

Since arrays are 'Object's, it is possible to invoke 'getClass()' on
an instance of an array.  The returned 'Class' corresponds to an array
with component type 'byte'.

     import java.util.HashSet;
     import java.util.Set;

     Set<String> s = new HashSet<String>();
     Class c = s.getClass();

   'java.util.Set' is an interface to an object of type
'java.util.HashSet'.  The value returned by 'getClass()' is the class
corresponding to 'java.util.HashSet'.

   ---------- Footnotes ----------

   (1) There is a unique console associated with the virtual machine
which is returned by the 'static' method 'System.console()'.

