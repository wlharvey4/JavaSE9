\input texinfo   @c -*-texinfo-*-

@c %**start of header (This is for running Texinfo on a region.)
@setfilename JavaSE9.info
@settitle About Java SE 9
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH SEPTEMBER, 2018
@set TITLE Outline Covering Java SE 9
@set SHORTTITLE Java SE 9 Outline
@set EDITION 0.1
@set VERSION 0.1.7

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@ignore
@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} YYYY, YYYY @*
Full name here @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The FOO program is copyright
@copyright{} YYYY, YYYY by Full name here. It is published under
the conditions of the GNU General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying
@end ignore

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author LOLH

@ignore COPYRIGHT PAGES
@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Full name here @*
Address Line 1 @*
Address Line 2 @*
etc. @*
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@end ignore
@end titlepage

@set DRAFT @i{DRAFT}

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| Version @value{VERSION} @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @value{TITLE}.

@c @insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@ignore
PREFATORY MATTER THRU ACKNOWLEDGEMENTS

@node Preface
@c @unnumbered Preface

Text here.

@node Audience
@c @unnumberedsec Intended Audience

Text here.

@node Overview
@c @unnumberedsec What Is Covered

Text and chapter by chapter description here.

@node Conventions
@c @unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@c @unnumberedsec Acknowledgements

@end ignore

@part The Java Language

@node Java SE 9 Introduction
@chapter Java SE 9 Introduction
@cindex Java SE 9 introduction
@cindex introduction to Java SE 9

@c *****************************************************************************
@node Packages
@chapter Packages
@cindex Packages (chapter)
@cindex containers, packages as
@cindex compartmentalized
@cindex class namespace, compartmentalize
@cindex packages, purposes, prevent collisions
@cindex collisions, prevention
@cindex packages, how stored
@cindex packages, import
@cindex import packages
@cindex hierarchical structure, packages

@ii{Packages} are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file names.
Packages are stored in a hierarchical manner and are explicitly imported into
new class definitions.

@node Packages Intro
@section Introduction to Packages
@cindex Introduction to Packages (section)
@cindex partitioning mechanism
@cindex naming mechanism
@cindex visibility mechanism
@cindex accessibility
@cindex exposure of code

Java provides a mechanism for partitioning the class namespace into
manageble chunks: the @dfn{PACKAGE}.  The package is both a naming and
a visibility control mechanism.  In other words, you can use the
package mechanism to define classes inside a package that are not
accessible by code outside the package; and you can define class
members that are exposed only to other members of the same package.

@node Defining Packages
@section Defining Packages
@cindex Packages, Defining (section)
@cindex @command{package} command
@cindex default package
@cindex package statement
@cindex package namespace

To create a package (``define'' a package), include the
@command{package} command as the first statement in a Java source
file.  Thereafter, any classes declared within that file will belong
to the specified package.  The @command{package} statement defines a
namespace in which classes are stored.  Without the @command{package}
statement, classes are put into the @file{default} package (which has
no name).

@subheading General Form of @command{package} statement
@cindex package statement, general form

@float GeneralForm,PackageStatement
@display
package @ii{pkg}
@end display
@caption{Package Statement --- General Form}
@end float

@ii{pkg} is the name of the package.  For example:
@cindex package statement, example

@example
package mypackage;
@end example

@subheading File System Directories
@cindex packages stored in file system

Java uses the file system directories to store packages.  Therefore, the
@code{.class} files for any classes you declare to be part of
@code{mypackage} must be stored in a directory called @code{mypackage}.  The
directory name must match the package name exactly.

More than one file can include the same @command{package} statement.  The
@command{package} statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other files
from being part of that same package.  Most real-world packages are spread
across many files.

@subheading Hierarchy of Packages
@cindex packages hierarchy
@cindex hierarchy of packages

You can create a hierarch of packages.  To do so, separate each package name
form the one above it by use of a period.  The general form of a multileveled
package statement is:
@cindex package statement, multilevel form

@float GeneralForm,PackageStatementMulti
@display
package @ii{pkg1[.pkg2[.pkg3]]}
@end display
@caption{Package Statement --- Multilevel Form}
@end float

A package hierarchy must be reflected in the file system of your Java
development system.  For example a package declared as:

@example
package a.b.c;
@end example

needs to be stored in directory @file{a/b/c}.

@cindex package renaming
Be sure to choose package names carefully; you cannot rename a package
without renaming the directory in which the classes are stored.

@node Classpath
@section Finding Packages and CLASSPATH
@cindex @env{CLASSPATH} @option{-classpath}
@cindex finding packages
@cindex run-time system, finding packages
@cindex modules, packages
@cindex module path
@cindex JDK 9, package part of module

Packages are mirrored by directories.  How does the Java run-time system know
where to look for packages?

@table @b
@item @samp{cwd}
By default, the Java run-time system uses the currect working directory as
its starting point.  Thus, if your package is in a subdirectory of the
current directory, it will be found.
@item @env{CLASSPATH}
You can specify a directory path or paths by setting the @env{CLASSPATH}
environment variable.
@item @option{-classpath}
You can use the @option{-classpath} option with @command{java} and
@command{javac} to specify the path to your classes.
@item module path
Beginning with JDK 9, a package can be part of a module, and thus found on
the @file{module path}.
@end table

@subheading Example Finding a Package
@cindex packages, finding, example

Consider the following package specification:

@example
package mypack;
@end example

In order for programs to find @code{mypack}, the program can be executed from
a directory @strong{immediadely above} @code{mypack}, or the @env{CLASSPATH}
must be set to include the path to @code{mypack} or the @option{-classpath}
option must specify the path to @code{mypack} when the program is run via
@command{java}.

When the second or third of the above options is used, the @file{class
path} @strong{must not include} @file{mypack} itself.  It must simply
specify the @file{path} to just above @file{mypack}.  For example, if
the path to @file{mypack} is

@example
/MyPrograms/Java/mypack
@end example

then the class path to @code{mypack} is

@example
/MyPrograms/Java
@end example

@node Member Access
@section Packages and Member Access
@cindex access control, packages
@cindex packages, access control
@cindex member access
@cindex access, member

Packages add another dimension to access control.  Classes and packages are
both means of encapsulating and containing the name space and scope of
variables and methods.  @emph{Packages} act as containiners for classes and
other subordinate packages.  @emph{Classes} act as containers for data and
code.  The class is Java's smallest unit of abstraction.  As it relates to
the interplay between classes and packages, Java addresses four categories of
visibility for class members:

@itemize
@item
Subclasses in the same package
@item
Non-subclasses in the same package
@item
Subclasses in different packages
@item
Classes that are neither in the same package nor subclasses
@end itemize

The three access modifiers

@itemize
@item
private
@item
public
@item
protected
@end itemize

provide a variaty of ways to produce many levels of access required by these
categories.
@cindex access control table

@float Table,PackageAccess
@multitable @columnfractions .4 .15 .15 .15 .15
@headitem Category @tab Private @tab None @tab Protected @tab public
@item
Same Class @tab Yes @tab Yes @tab Yes @tab Yes
@item
Same package subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Same package non-subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Different package subclass @tab No @tab No @tab Yes @tab Yes
@item
Different package noni-subclass @tab No @tab No @tab No @tab Yes
@end multitable
@caption {Package Access Table --- Shows all combinations of the access
control modifiers}
@shortcaption{Package Access Table}
@end float

@node Importing
@section Importing Packages
@cindex packages, importing
@cindex importing packages

Java includes the @command{import} statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be referred to
directly, using only its name.  The @command{import} statement is a
convenience to the programmer and is not technically needed to write a
complete Java program.

In a Java source file, @command{import} statements occur immediately
following the @command{package} statement (if one exists) and before any
class definitions.  This is the general form of the @command{import}
statement:
@cindex import statement, general form and example

@float GeneralForm,Import
@display
import @ii{pkg1}[.@ii{pkg2}].(@ii{classname} | *);
@end display
@caption{Import Statement --- General Form}
@end float

Here, @ii{pkg1} is the name of a top-level package, and @ii{pkg2} is the name
of a subordinate package inside the outerpackage separated by a dot
(@t{.}).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit @file{classname} or a star (@t{*}), which
indicates that the Java compiler should import the entire package.

@example
import java.util.Date;
imort java.io.*;
@end example

@cindex standard Java classes, imported implicitly
@cindex @file{java.lang}
All of the standard Java SE classes included with Java begin with the name
@file{java}.  The basic language functions are stored in a package called
@file{java.lang}.  Normally, you have to import every package or class that
you want to use, but since Java is useless without much of the functionality
in @file{java.lang}, it is implicitly imported by the compiler for all
programs.  This is equivalent to the following line being at the top of all
your programs:

@example
import java.lang.*;
@end example

@cindex import is optional
@cindex fully qualified name
The @command{import} statement is @emph{optional}.  Any place you use a class
name, you can use its @emph{fully qualified name}, which includes its full
package hierarchy.

@cindex imported packages must be public
When a package is imported, only those items within the package declared as
@command{public} will be available to non-subclasses in the importing code.

@c *****************************************************************************
@node Interfaces
@chapter Interfaces
@cindex Interfaces (chapter)
@cindex interfaces, introduction
@cindex keyword interface
@cindex abstract class
@cindex interface, implement
@cindex polymorphism, one interface multiple methods

Using the keyword @command{interface}, you can fully abstract a class'
interface from its implementation.  That is, using @command{interface}, you
can specify what a class must do, but not how to do it.  Interfaces are
syntactically similar to classes, but they lack instance variables, and, as a
general rule, their methods are declared without any body.  Once it is
defined, any number of classes can implement an @command{interface}.  Also,
one class can implement any number of interfaces.  To implement an interfce,
a class must provide the complete set of methods required by the interface.
Each class is free to determine the details of its own implementation.  By
providing the @command{interface} keyword, Java allws you to fully utilize
the ``one interface, multiple methods'' aspect of polymorphism.

@cindex dynamic method resolution
@cindex run-time
@cindex compile time
@cindex method signatures compatible
@cindex static environment
Interfaces are designed to support @dfn{dynamic method resolution} at run
time.  Normally, in order for a method to be called from one class to
another, both classes need to be present at compile time so the Java compiler
can check to ensure that the method signatures are compatible.  This
requirement by itself makes for a static and nonextensible classing
environment.  Inevitably in a system like this, functionality gets pushed up
higher and higher in the class hierarchy so that the mechanisms will be
available to more and more subclasses.  Interfaces are designed to avoid this
problem.  @emph{They disconnect the definition of a method or set of methods
from the inheritance hierarchy.}  Since interfaces are in a different
hierarchy from classes, it is possible for classes that are unrelated in
terms of class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.

@node Defining Interfaces
@section Defining Interfaces
@cindex interfaces, defining

An interface is defined much like a class.  Here is a simplified general form
of an interface definition:
@cindex interface definition, simplified general form

@float GeneralForm,InterfaceSimple
@display
@ii{access} interface @ii{name} @{
  @ii{return-type method-name1}(@ii{parameter-list});
  @ii{return-type method-name2}(@ii{parameter-list});

  @ii{type final-varname1} = @ii{value}
  @ii{type final-varname2} = @ii{value}
  @dots{}
  @ii{return-type method-nameN}(@ii{parameter-list});
  @ii{type final-varnameN} = @ii{value}
@}
@end display
@caption{Interface Definition --- Simplified General Form}
@end float

@cindex interface default access, no modified
@cindex interface public access
@cindex abstract methods, interface
@cindex interface methods, abstract methods
When no access modifier is included, then default access results, and the
interface is only available to other members of the package in which it is
declared.  When it is declared as @command{public}, the interface can be used
by code outside its package.  In this case, the interface mst be the only
public interface declared in the file, and the file must have the same name
as the interface.  The methods that are declared have no bodies.  They end
with a semicolon after the parameter list.  They are, essentially, abstract
methods.  Each class that includes such an interface must implement all of
the methods.

@subheading Variable Declarations inside Interfaces
@cindex interface variable declarations

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly @command{final} and @command{static},
meaning they cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly @command{public}.

@node Implementing Interfaces
@section Implementing Interfaces
@cindex interfaces, implementing
@cindex @command{implements} clause

Once an interface has been defined, one or more classes can implement that
interface.  To implement an interface, include the @command{implements}
clause in a class definition, and then create the methods required by the
interface.  The general form of a class that includes the
@command{implements} clause looks like this:

@float GeneralForm,ClassImplementsInterface
@display
class @ii{clasname} [extends @ii{superclass}] [implements @ii{interface} [,@ii{interface}@dots{}] @{
  @ii{class-body}
@}
@end display
@caption{Class Implementing Interface --- General Form}
@end float

@cindex interface method defintion, declared @command{public}
The methods that implement an interface must be declared @command{public}.
The type signature of the implementing method must match exactly the type
signature specified in the @command{interface} definition.

It is both permissible and common for classes that implement interfaces to
define additional members of their own.

@node Interface References
@section Accessing Implementations Through Interface References
@cindex interface references, accessing implementations
@cindex object references, interfaces
@cindex interfaces, key feature, reference look-ups
@cindex dynamic dispatch, interface method look-ups
@cindex dispatch through an interface

You can declare variables as object references that use an interface rather
than a class type.  Any instance of any class that implements the declared
interface can be referred to by such a variable.  When you call a method
through one of these references, the correct version will be called based on
the actual instance of the interface being referred to.  This is one of the
key features of interfaces.  The method to be executed is looked up
dynamically at run-time, allowing classes to be created later than the code
which calls methods on them.  The calling code can dispatch through an
interface without having to know anything about the ``callee.''  This process
is similar to using a superclass reference to access a subclass object.

@node Partial Implementations
@section Partial Implementations
@cindex interface, partial implementation

If a class includes an interface but does not implement the methds required
by that interface, then that class must be declared as @command{abstract}.
Any class that inherits the abstract class must implement the interface or be
declared @command{abstract} itself.

@node Nested Interfaces
@section Nested Interfaces
@cindex interfaces, nested
@cindex nested interfaces
@cindex member interfaces

An interface can be declared a member of a class or another interface.  Such
an interface is called a @dfn{member interface} or a @dfn{nested interface}.
A nested interface can be declared as @command{public}, @command{private}, or
@command{protected}.  This differs from a top-level interface, which must
either be declared as @command{public} or use the default access level.  When
a nexted interface is used outside of its enclosing scope, it must be
qualified by the name of the class or interface of which it is a member.
Thus, outside of the class or interface in which a nested interface is
declared, its name must be fully qualified.

@node Applying Interfaces
@section Applying Interfaces
@cindex intefaces, applying

See detailed example @dots{}

@node Variables in Interfaces
@section Variables in Interfaces
@cindex interfaces, final variables in
@cindex interfaces, shared constants

You can use interfaces to import shared constants into multiple classes by
simply declaring an interface that contains variables that are initialized to
the desired values.  When you include that interface in a class (when you
``implement'' the interface), all of those variable names will be in scope as
constants.  If an interface contains no methods, then any class that includes
such an interface doesn't actually implement anything.  It is as if that
class were importing this constant fields into the class name space as
@command{final} variables.

@node Extending Interfaces
@section Interfaces Can Be Extended
@cindex interfaces, extending
@cindex interfaces, inheriting
@cindex @command{extents}, with interfaces
@cindex extending interfaces
@cindex inheriting interfaces

One interface can inherit another by use of the keyword @command{extends}.
The syntax is the same as for inheriting classes.  When a class implements an
interface that inherits another interface, it must provide implementations
for all methods required by the interface inheritance chain.

@node Default Interface Methods
@section Default Interface Methods
@cindex index interface, default methods
@cindex default methods, interface
@cindex abstract methods, interface
@cindex interface, traditional form
@cindex JDK 8, default method in interface

Prior to JDK 8, an interface could not define any implementation whatsoever.
This meant that for all previous versions of Java, the methods specified by
an interface were abstract, constaining no body.  This is the traditional
form of an interface.  The release of JDK 8 changed this by adding a new
capability to @command{interface} called the @dfn{default method}.  A default
method lets you define a default implementation for an interface method.  It
is possible for an interface method to provide a body, rather than being
abstract.

@cindex default method, interface, motivation
@cindex preexisting code, default method, interface
A primary motivation for the default method was to provide a means by which
interfaces could be expanded without breaking existing code.  There must be
implementations for all methods defined by an interface.  If a new method
were added to a popular, widely used interface, then the addition of that
method would break existing code because no implementation would be found for
that new method.  The default method solves this problem by supplying an
implementation that willbe used if no other implementation is explicitly
provided.  Thus, the addition of a default method will not cause preexisting
code to break.

Another motivation for the default method was the desire to specify methods
in an interface that are, essentially, optional, depending on how the
interface is used.

@subheading Interfaces Do No Maintain State and Cannot Be Created
@cindex interfaces, key aspect, no state
@cindex difference between class and interface

It is important to point out that the addition of default methods does not
change a key aspect of @command{interface}: its inability to maintain state
information.  An interface still cannot have instance variables, for example.
Thus, @strong{the defining difference between an interface and a class is
that a class can maintain state information, but an interface cannot.}
Furthermore, it is still not possible to create an instance of an interface
by itself.  It must be implemented by a class.

@node Interface Static Methods
@section Use Static Methods in an Interface
@cindex interface, static method
@cindex static method, interface
@cindex method, static, interface
@cindex JDK 8, static interface method

Another capability added to interface by JDK 8 is the ability to define one
or more @command{static} methods.  Like @command{static} methods in a class,
a @command{static} method defined by an interface can be called independently
of any object.  Thus, no implementation of the interface is necessary, and no
instance of the interface is required, in order to call a @command{static}
method.  Instead, a @command{static} method is called by specifying the
interface name, followed by a period, followed by the method name.  Here is
the general form:

@float GeneralForm,InterfaceStaticMethod
@display
@ii{InterfaceName.staticMethodName}
@end display
@caption{Interface Static Method, Calling}
@end float

Notice that this is similar to the way that a @command{static} method in a
class is called.  However, @command{static} interface methods are not
inherited by either an implementing class or a subinterface.

@node Private Interface Methods
@section Private Interface Methods
@cindex interface methods, private
@cindex JDK 9, private interface method

Beginning with JDK 9, an interface can include a private method.  A private
interface method can be called only by a default method or another private
method defined by the same interface.  Because a private interface method is
specified @command{private}, it cannot be used by code outside the interface
in which it is defined.  This restriction includes subinterfaces because a
private inteface method is not inherited by a subinterface.

The key benefit of a private interface method is that it lets two or more
default methods use a common piece of code, thus avoiding code duplication.


@c ****************************************************************************
@node Generics
@chapter Generics
@cindex Generics (chapter)
@cindex generics, introduction
@cindex J2SE 5.0
@cindex Collections Framework
@cindex collections, generics
@cindex type abstraction, generics
@cindex abstract over types

@dfn{Generics}, introduced in J2SE 5.0, allows a type or method to operate on
objects of various types while providing compile-time type safety.  It adds
compile-time type safety to the Collections Framework and eliminates the need
of casting.  In other words, generics allow you to abstract over types.

Through the use of generics, it is possible to create classes, interfaces,
and methods that will work in a type-safe manner with various kinds of data.
Many algorithms are logically the same no matter what type of data they are
being applied to.  For example, the mechanism that supports a stack is the
same whether that stack is storing items of type @command{Integer},
@command{String}, @command{Object}, or @command{Thread}.  With generics, you
can define an algorithm once, independently of any specific type of data, and
then apply that algorithm to a wide variety of data types without any
additional effort.

Perhaps the one feature of Java that has been most significantly affected by
generics is the @cite{Collections Framework}.  A @dfn{collection} is a group
of objects.  The Collections Framework defines several classes, such as lists
and maps, that manage collections.  The collection classes have always been
able to work with any type of object.  The benefit that generics adds is that
the collection classes can now be used with complete type safety.

This chapter describes the syntax, theory, and use of generics.  It also
shows how generics provide type safety for some previously difficult cases.

@node Motivation
@section Motivation for Generics
@cindex generics, motivation

@subheading Code Fragment Without Generics

Here is a typical code fragment abstracting over types by using @code{Object}
and type casting.

@example
List myIntList = new LinkedList(); // 1
myIntList.add(new Integer(0)); // 2
Integer x = (Integer) myIntList.iterator().next(); // 3
@end example

The cast on line 3 is annoying, although essential.  The compiler can
guarantee only that an @code{Object} will be returned by the iterator.  This
therefore adds both clutter and the possibility of a run-time error.

@subheading Code Fragment with Generics

Generics allow a programmer to mark their intent to restrict a list to a
particular data type.  Here is a version of the same code that uses generics.

@example
List<Integer> myIntList = new LinkedList<Integer>(); // 1'
myIntList.add(new Integer(0)); // 2'
Integer x = myIntList.iterator().next(); // 3'
@end example
@cindex generic interface
@cindex type parameter
@cindex type correctness
@cindex compile-time type check
@cindex generics, motivation, readability and robustness

In line 1, the type declaration for the variable @code{myIntList} specifies
that it is to hold a @code{List} of @code{Integer}s: @samp{List<Integer>}.
@code{List} is a @dfn{generic interface} that takes a @dfn{type parameter}
(@code{Integer}).  The type parameter is also specified when creating the
@code{List} object (@samp{new LinkedList<Integer>()}).  Also, the cast on
line 3 is gone.

So has this just moved the clutter around, from a type cast to a type
parameter?  No, because this has given the compiler the ability to check the
type correctness of the program @emph{at compile-time}.  When we say that
@code{myIntList} is declared with type @code{List<Integer>}, this tells us
something about the variable @code{myIntList}, which holds true wherever and
whenever it is used, and the compiler will guarantee it.  In contrast, the
cast tells us something the programmer thinks is true at a single point in
the code.

The net effect, especially in large programs, is improved readability and
robustness.

@node What are Generics
@section What Are Generics
@cindex generics, what they are
@cindex parameterized types
@cindex generic class, method
@cindex @command{Object} type
@cindex type safety, generics
@cindex casts, generics, automatic, implicit
@cindex generics, casts

The term @dfn{generics} means @i{parameterized types}.  Parameterized types
are important because they enable you to create classes, interfaces, and
methods in whicht the type of data upon which they operate is specified as a
parameter.  Using generics, it is possible to create a single class, for
example, that automatically works with different types of data.  A class,
interface, or method that operates on a parameterized type is called
@dfn{generic}, as in @i{generic class} or @i{generic method}.

Java has always given the ability to create generalized classes, interfaces,
and methods by operating through references of type @code{Object}.
Generics added the type safety that was lacking.  They also streamlined the
process, because it is no longer necessary to explicitly employ casts to
translate between @code{Object} and the type of data that is being operate
upon.  Wtih generics, all casts are automatic and implicit.

@node Simple Generics Example
@section A Simple Generics Example
@cindex generics example
@cindex example, generics
@cindex generic class

The following program defines two classes.  The first is the generic class
@code{Gen}, and the second is @code{GenDemo}, which uses @code{Gen}.

@(SimpleGenerics.java@)=
@<Class Gen@>
@<Class GenDemo@>
@

@node Class Gen<T>
@subsection Class Gen<T>
@cindex generic class
@cindex parameter, generic class
@cindex type parameter, generic class
@cindex parameterized type

This is a simple generic class.  The class @code{Gen} is declared with a
parameter of @samp{<T>}:

@example
class Gen<T> @{
@end example

@samp{T} is the name of a @dfn{type parameter}.  This name is used as a
placeholder for the actual type that will be passed to @code{Gen} when an
object is created.  Thus, @samp{T} is used within @code{Gen} whenever the
type parameter is needed.

Notice that @samp{T} is contained within @samp{< >}.  This syntax can be
generalized.  Whenever a type parameter is being declared, it is specified
within angle brackets.

Because @code{Gen} uses a type parameter, @code{Gen} is a @emph{generic
class}, which is also called a @emph{parameterized type}.

@subsubheading Outline of Class Gen<T>

Class @code{Gen} contains four parts:

@itemize
@item
an instance variable declaration
@item
a constructor
@item
a method returning the instance variable
@item
a method describing the type of the instance variable
@end itemize

@<Class Gen@>=
class Gen<T> {
  @<Instance Variable ob of Type T@>
  @<Constructor taking parameter of Type T@>
  @<Method returning object of type T@>
  @<Method showing type of T@>
}
@

@subsubheading Implementation of Class Gen<T>

@samp{T} is used to declare an object called @code{ob}.  @samp{T} is a
placeholder for the actual type that will be specified when a @code{Gen}
object is created.  Thus, @code{ob} will be an object of the type passed to
@samp{T}.  

@<Instance Variable ob of Type T@>=
T ob;	// declare an object of type T

@

@subsubheading The Constructor
@anchor{generics-constructor}

Here is the constructor for @code{Gen}.  Notice that its parameter, @code{o},
is of type @samp{T}.  This means that the actual type of @code{o} is
determined by the type passed to @samp{T} when a @code{Gen} object is
created.  Because both the parameter @code{o} and the member variable
@code{ob} are of type @samp{T}, they will both be the same actual type when
a @code{Gen} object is created.

@<Constructor taking parameter of Type T@>=
// Pass the constructor a reference to
// an object of type T
Gen (T o) {
  ob = o;
}

@

@subsubheading Instance Methods @code{getob()} and @code{showType()}

The type parameter @samp{T} can also be used to specify the return type of a
method, as here in @code{getob()}.  Because @code{ob} is also of type
@samp{T}, its type is compatible wih the return type specified by
@code{getob()}.  

@<Method returning object of type T@>=
// Return ob
T getob() {
  return ob;
}

@

@cindex @code{Class}
@cindex @code{Object}
@cindex @code{getClass()}, defined in @code{Object}
@cindex @code{Class} object, from @code{getClass()}
@cindex @code{getName()}, defined in @code{Class}
@cindex class name, from @code{getName()}

The method @code{showType()} displays the type of @samp{T} by calling
@code{getName()} on the @code{Class} object return by the call to
@code{getClass()} on @code{ob}.   The @code{getClass()} method is defined
by @code{Object} and is thus a member of @emph{all} class types.  It returns
a @code{Class} object that corresponds to the type of the class of the
object on which it is called.  @code{Class} defines the @code{getName()}
method, which returns a string representation of the class name.

@<Method showing type of T@>=
// Show type of T
void showType() {
  System.out.println("Type of T is " + ob.getClass().getName();
}

@

@node Class GenDemo
@subsection Class GenDemo
@cindex generic code, demonstrating an implementation
@cindex erasure
@cindex type erasure

The @code{GenDemo} class demonstrates the generic @code{Gen} class.

But first, take note: The Java compiler does not actually create different
versions of @code{Gen}, or of any other generic class.  The compiler removes
all generic type information, substituting the necessary casts, to make your
code @strong{behave as if} a specific version of @code{Gen} were created.
There is really only one version of @code{Gen} that actually exists.

The process of removing generic type information is called @dfn{type
erasure}.  

@code{GenDemo} first creates a version of @code{Gen} for integers and calls
the methods defined in @code{Gen} on it.  It then does the same for a String
object.

@<Class GenDemo@>=
// Demonstrate the generic class
class GenDemo {
  public static void main(String args[]) {
    @<Create a Gen object for Integers@>
    @<Create a Gen object for Strings@>
  }
}

@

@node GenDemo as Integer
@subsubsection Implementation of Class GenDemo with Type Integer
@cindex generic reference, creating
@cindex type argument, passed to type parameter

@<Create a Gen object for Integers@>=
@<Integer Type Parameter@>
@<Reference to Integer Instance@>
@<Show Type@>
@<Get Value@>
@

@subsubheading Integer Type Declaration
@cindex generic reference to Integer

A reference to an Integer is declared in @code{iOb}.  Here, the type
@samp{Integer} is specified within the angle brackets after @code{Gen}.
@samp{Integer} is a @dfn{type argument} that is passed to @code{Gen}'s type
parameter, @samp{T}.  This effectively creates a version of @code{Gen} in
which all references to @samp{T} are translated into references to
@samp{Integer}.  Thus, @code{ob} is of type @samp{Integer}, and the return
type of @code{getob()} is of type @samp{Integer}.

@<Integer Type Parameter@>=
Gen<Integer> iOb;

@

@subsubheading Reference Assignment
@cindex generic reference assignment to Integer
@cindex generic type checking
@cindex generics, compile-time error, mismatched types
@cindex generics, type safety benefit
@cindex autoboxing in generic reference

The next line assigns to @code{iOb} a reference to an instance of an
@samp{Integer} version of the @code{Gen} class.  When the @code{Gen}
constructor is called, the type argument @samp{Integer} is also specified.
This is because the type of the object (in this case @code{iOb} to which the
reference is being assigned is of type @code{Gen<Integer>}.  Thus, the
reference returned by @command{new} must also be of type
@code{Gen<Integer>}.  If it isn't, a compile-time error will result.  This
type checking is one of the main benefits of generics because it ensures type
safety.  

Notice the use of autoboxing to encapsulate the value 88 within an Integer
object.

@<Reference to Integer Instance@>=
iOb = new Gen<Integer>(88);

@

The automatic autoboxing could have been written explicitly, like so:
@example
iOb = new Gen<Integer>(Integer.valueOf(88));
@end example
@noindent but there would be no value to doing it that way.

@subsubheading Showing the Reference's Type

The program then uses @code{Gen}'s instance method to show the type of
@code{ob}, which is an @samp{Integer} in this case.

@<Show Type@>=
iOb.showType();

@

@subsubheading Showing the Reference's Value

The program now obtains the value of @code{ob} by assiging @code{ob} to an
@samp{int} variable.  The return type of @code{getob()} is @samp{Integer},
which unboxes into @samp{int} when assigned to an @samp{int} variable
(@code{v}).  There is no need to cast the return type of @code{getob()} to
@samp{Integer}.  

@<Get Value@>=
int v = iOb.getob();
System.out.println("value: " + v);
System.out.println();

@

@node GenDemo as String
@subsubsection Implementation of Class GenDemo with Type String

@<Create a Gen object for Strings@>=
// Create a Gen object for Strings.
Gen<String> strOb = new Gen<String>("Generics Test");

// Show the type of data used by strOb
strOb.showType();

// Get the value of strOb.  Again, notice
// that no cast is needed.
String str = strOb.getob();
System.out.println("value: " + str);

@

@node Notes about Generics
@section Notes About Generics

@node Reference Types
@subsection Generics Work Only with Reference Types
@cindex generics, only reference types
@cindex generic type argument, reference type
@cindex type wrappers, generics
@cindex auto-boxing, generics
@cindex auto-unboxing, generics

When declaring an instance of a generic type, the type argument passed to the
type parameter must be a reference type.  It cannot be a primitive type, such
as @samp{int} or @samp{char}.

You can use the type wrappers to encapsulate a primitive type.  Java's
autoboxing and auto-unboxing mechanism makes the use of the type wrapper
transparent.  

@node Type Arguments
@subsection Generic Types Differ Based on their Type Arguments
@cindex generic types differ, type arguments

A reference of one specific version of a generic type is not type-compatible
with another version of the same generic type.  In other words, the following
line of code is an error and will not compile:

@example
iOb = strOb; // Gen<Integer> != Gen<String>
@end example

These are references to different types because their type arguments differ.

@node Subtyping
@subsection Generics and Subtyping
@cindex generics, subtyping

Is the following legal?

@example
List<String> ls = new ArrayList<String>(); // 1
List<Object> lo = ls; // 2
@end example

Line 1 is legal.  What about line 2?  This boils down to the question: ``is a
List of String a List of Object.''  Most people instinctively answer,
``Sure!''

Now look at these lines:

@example
lo.add(new Object()); // 3
String s = ls.get(0); // 4: Attempts to assign an Object to a String!
@end example

Here we've aliased @code{ls} and @code{lo}. Accessing @code{ls}, a list of
@code{String}, through the alias @code{lo}, we can insert arbitrary objects
into it. As a result @code{ls} does not hold just @code{Strings} anymore, and
when we try and get something out of it, we get a rude surprise.

The Java compiler will prevent this from happening of course. Line 2 will
cause a compile time error.

The take-away is that, if @code{Foo} is a subtype (subclass or subinterface)
of @code{Bar}, and @code{G} is some generic type declaration, it is not the
case that @code{G<Foo>} is a subtype of @code{G<Bar>}.

@node Type Safety
@subsection How Generics Improve Type Safety
@cindex generics improve type safety
@cindex generics ensure type safety
@cindex generics eliminate casts
@cindex casts, eliminated in generics

Generics automatically ensure the type safety of all operations involving a
generic class, such as @code{Gen}.  They eliminate the need for the coder to
enter cases and to type-check code by hand.

@node Two Type Parameters
@section A Generic Class with Two Type Parameters
@cindex generic class, two type parameters

You can declare more than one type parameter in a generic type.  To specify
two or more type parameters, use a comma-separated list.  When an object is
created, the same number of type arguments must be passed as there are type
parameters.  The type arguments can be the same or different.

@node Two Types Example Code
@subsection Example of Code with Two Type Parameters

@(TwoTypeParameters.java@)=
@<Class TwoGen@>
@<Class SimpGen@>
@

@node Class TwoGen
@subsubsection Class TwoGen

@<Class TwoGen@>=
@<Class Declaration@>
  @<Two Instance Variables Declarations@>
  @<Constructor of Two Parameters@>
  @<Instance Methods Show and Get@>
@

@subsubheading Class Declaration
@cindex generics, two type parameters, declaration
@cindex generics, two type arguments

Notice how @code{TwoGen} is declared.  It specifies two type parameters:
@samp{T} and @samp{V}, separated by a comma.  Because it has two type
parameters, two type arguments must be passed to @code{TwoGen} when an object
is created.

@<Class Declaration@>=
class TwoGen<T, V> {
@

@subsubheading Instance Variables Declarations

@<Two Instance Variables Declarations@>=
T ob1;
V ob2;

@

@subsubheading Constructor
@<Constructor of Two Parameters@>=
TwoGen(T o1, V 02) {
  ob1 = o1;
  ob2 = o2;
}

@

@subsubheading Instance Methods Show and Get
@<Instance Methods Show and Get@>=
void showTypes() {
  System.out.println("Type of T is " + ob1.getClass().getName());
  System.out.println("Type of V is " + ob2.getClass().getName());
}

T getob1() {
  return ob1;
}

V getob2() {
  return ob2;
}

@

@node Class SimpGen
@subsubsection Class SimpGen

Two type arguments must be supplied to the constructor.  In this case, the
two type parameters are @samp{Integer} and @samp{String}.

@<Class SimpGen@>=
class SimpGen {
  public static void main(String args[]) {
    TwoGen<Integer, String> tgObj = new TwoGen<Integer, String>(88, "Generics");

    // Show the types
    tgObj.showTypes();

    // Obtain and show values
    int v = tgObj.getob1();
    System.out.println("value: " + v);

    String str = thObj.getob2();
    System.out.println("value: " + str);
  }
}
@

@node Generic Class General Form
@section The General Form of a Generic Class
@cindex generic class, general form

The generics syntax shown above can be generalized.  Here is the syntax for
declaring a generic class:

@float GeneralForm,GenericClass
@display
class @ii{class-name}<@ii{type-param-list}> @{ @dots{}
@end display

Here is the full syntax for declaring a reference to a generic class and
instance creation:

@display
@ii{class-name}<@ii{type-arg-list}> @ii{var-name} =
  new @ii{class-name}<@ii{type-arg-list}>(@ii{cons-arg-list});
@end display
@caption{General Form for Declaring and Creating a Reference to a Generic
Class}
@shortcaption{General Form Generic Class}
@end float

@node Bounded Types
@section Bounded Types
@cindex generics, bounded types
@cindex bounded types
@cindex upper bound
@cindex @command{extends} clause

Sometimes it can be useful to limit the types that can be passed to a type
parameter.  Java provides @dfn{bounded types}.  When specifying a type
parameter, you can create an upper bound that declares the superclass from
which all type arguments must be derived.  This is accomplished through the
use of an @command{extends} clause when specifying the type parameter:

@display
 <@ii{T} extends @ii{superclass}>
@end display

This specifies that @ii{T} can only be replaced by @ii{superclass} or
subclasses of @ii{superclass}.  Thus, @ii{superclass} defines an inclusive,
upper limit.

@subheading Interface Type as a Bound
@cindex generics, interface as bound
@cindex interface as bound, generics

In addition to using a class type as a bound, you can also use an interface
type.  In fact, youi can specify multiple interfaces as bounds.  Furthermore,
a bound can include both a class type and one or more interfaces.  In this
case, the class type must be specified first.  When a bound includes an
interface type, only type arguments that implement that interface are legal.

When specifying a bound that has a class and an interface, or multiple
interfaces, use the @kbd{&} operator to connnect them.

@example
class Gen<T extends MyClass & MyInterface> @{ @dots{}
@end example

Any type argument passed to @samp{T} must be a subclass of @code{MyClass} and
implement @code{MyInterface}.

@node Wildcard Arguments
@section Using Wildcard Arguments
@cindex generics, wildcard arguments
@cindex wildcard arguments, generics

@node Wildcard Motivation
@subsection Wildcard Motivation
@cindex wildcards, motivation

Consider the problem of writing a routine that prints out all the elements in
a collection. Here's how you might write it in an older version of the
language (i.e., a pre-5.0 release):

@example
void printCollection(Collection c) @{
    Iterator i = c.iterator();
    for (k = 0; k < c.size(); k++) @{
        System.out.println(i.next());
    @}
@}
@end example

And here is a naive attempt at writing it using generics (and the new
@kbd{for loop} syntax):

@example
    for (Object e : c) @{
        System.out.println(e);
    @}
@}
@end example

The problem is that this new version is much less useful than the old
one. Whereas the old code could be called with any kind of collection as a
parameter, the new code only takes @code{Collection<Object>}, which, as we've
just demonstrated, is @emph{not} a supertype of all kinds of collections!

So what is the supertype of all kinds of collections? It's written
@kbd{Collection<?>} (pronounced @dfn{collection of unknown}), that is, a
collection whose element type matches anything. It's called a @dfn{wildcard
type}.  We can write:

@example
void printCollection(Collection<?> c) @{
    for (Object e : c) @{
        System.out.println(e);
    @}
@}
@end example

and now, we can call it with any type of collection.  Notice that inside
@code{printCollection()}, we can still read elements from @code{c} and give
them type @code{Object}. This is always safe, since whatever the actual type
of the collection, it does contain objects. It isn't safe to add arbitrary
objects to it however:

@example
Collection<?> c = new ArrayList<String>();
c.add(new Object()); // Compile time error
@end example

Since we don't know what the element type of @code{c} stands for, we cannot
add objects to it. The @code{add()} method takes arguments of type @code{E},
the element type of the collection. When the actual type parameter is
@code{?}, it stands for some unknown type. Any parameter we pass to
@code{add} would have to be a subtype of this unknown type. Since we don't
know what type that is, we cannot pass anything in. The sole exception is
@code{null}, which is a member of every type.

On the other hand, given a @code{List<?>}, we can call @code{get()} and make
use of the result. The result type is an unknown type, but we always know
that it is an object. It is therefore safe to assign the result of
@code{get()} to a variable of type @code{Object} or pass it as a parameter
where the type @code{Object} is expected.

@node Wildcard Syntax
@subsection Wildcard Syntax
@cindex wildcard syntax

Sometimes type safety can get in the way of perfectly acceptable constructs.
In such cases, there is a @dfn{wildcard} argument that can be used.  The
wildcard argument is specified by the @kbd{?}, and it represents an unknown
type.  It would be used in place of a type parameter, for example:

@example
boolean sameAvg(Stats<?> ob) @{
  if(average() == ob.average())
    return true;

  return false;
@}
@end example

Here, @samp{Stats<?>} matches any @code{Stats} object (@code{Integer},
@code{Double}), allowing any two @code{Stats} objects to have their averages
compared.  The wildcard does not affect what type of @code{Stats} object can
be created.  That is governed by the @command{extends} clause in the
@code{Stats} declaration.  The wildcard simply matches any @emph{valid}
@code{Stats} object.

@node Bounded Wildcards
@subsection Bounded Wildcards
@cindex wildcards, bounded
@cindex bounded wildcards

Wildcard arguments can be bounded in much the same way that a type parameter
can be bounded (the @dfn{bounded wildcard argument}.  A bounded wildcard is
especially important when you are creating a generic type that will operate
on a class hierarchy.

A bounded wildcard specifies either an upper bound or a lower bound for the
type argument.  This enables you to restrict the types of objects upon which
a method will operate.

@subsubheading Upper Bounded Wildcard
@cindex bounded wildcards, upper bound
@cindex upper bounded wildcard

The most common bounded wildcard is the upper bound, which is created using
an @command{extends} clause.In general, to establish an upper bound for a
wildcard, use the following type of wildcard expression:
@cindex bounded wildcards, upper bound
@cindex upper bound wildcard argument

@float GeneralForm,UpperBoundedWildcard
@display
<? extends @ii{superclass}>
@end display
@caption{General Form of Upper Bounded Wildcard Syntax}
@shortcaption{Upper Bounded Wildcard}
@end float

where @ii{superclass} is the name of the class that serves as the upper
bound.  This is an inclusive clause.

@subsubheading Lower Bounded Wildcard
@cindex bounded wildcards, lower bound
@cindex lower bounded wildcard

You can also specify a lower bound for a wildcard by adding a @command{super}
clause to a wildcard declaration.  Here is its general form:

@float GeneralForm,LowerBoundedWildcard
@display
<? super @ii{subclass}>
@end display
@caption{General Form of Lower Bounded Wildcard Syntax}
@shortcaption{Lower Bounded Wildcard}
@end float

Only classes that are superclasses of @ii{subclass} are acceptable arguments

@node Generic Methods
@section Creating a Generic Method
@cindex generic method, creating
@cindex creating generic method

It is possible to declare a generic method that uses one or more type
parameters of its own.  It is also possible to create a generic method that
is enclosed within a non-generic class.

@subheading Generalized Form

@float GeneralForm,GenericMethod
@display
< @ii{type-param-list} > @ii{ret-type} @ii{meth-name} ( @ii{param-list} ) @{ @dots{}
@end display
@caption{General Form for Declaring a Generic Method}
@shortcaption{Generic Method Declaration}
@end float

@node Example of Generic Method
@subsection Example of Generic Method
@cindex generic method, example
@cindex example generic method

The following program declares a non-generic class called @code{GenMethDemo}
and a static @strong{generic method} within that class called @code{isIn()}.
The @code{isIn()} method determines if an object is a member of an array.  It
can be used with any type of object and array as long as the array contains
objects that are compatible with the type of the object being sought.

@(GenMethDemo.java@)=
class GenMethDemo {
  @<Static Method isIn@>
  @<GenMethDemo Main@>
}
@

@node Method isIn
@subsubsection Method isIn()

The @strong{type parameters} are declared @emph{before} the return type of
the method.

@<Static Method isIn@>=
static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {

  for (int i = 0; i < y.length; i++)
    if (x.equals(y[i]) return true;

  return false;
}

@

The type @ii{T} is @strong{upper-bounded} by the @code{Comparable} interface,
which must be of the same type as @ii{T}.  Likewise, the second type, @ii{V},
is also @strong{upper-bounded} by @ii{T}.  Thus, @ii{V} must be either the
same type as @ii{T} or a subclass of @ii{T}.  This relationship enforces that
@code{isIn()} can be called only with arguments that are compatible with each
other.

@cindex generic method, static
@cindex static generic method
While @code{isIn()} is static in this case, generic methods can be either
static or non-static; there is no restriction in this regard.

@subsubheading Explicitly Including Type Arguments
@cindex generic methods, including type arguments

There is generally no need to specify type arguments when calling this method
from within the @code{main} routine.  This is because the type arguments are
automatically discerned, and the types of @ii{T} and @ii{V} are adjusted
accordingly.

Although type inference will be sufficient for most generic method calls, you
can explicitly specify the type argument if needed.  For example, here is how
the first call to @code{isIn()} looks when the type argumetns are specified:

@example
GenMethDemo.<Integer, Integer>isIn(2, nums)
@end example


@node GenMethDemo Main
@subsubsection GenMethDemo Main

@<GenMethDemo Main@>=
public static void main(String args[]) {

  // call isIn() with Integer type
  Integer nums[] = { 1, 2, 3, 4, 5 };

  if ( isIn(2, nums) )
    System.out.println("2 is in nums");

  if ( @isIn(7, nums))
    System.out.println("7 is not in nums");

  System.out.println();

  // call isIn() with String type
  String strs[] = { "one", "two", "three", "four", "five" };

  if ( isIn("two", strs))
    System.out.println("two is in strs");

  if ( !isIn("seven", strs))
    System.out.println("seven is not in strs");

  // call isIn() with mixed types
  // WILL NOT COMPILE! TYPES MUST BE COMPATIBLE
  // if ( isIn("two", nums))
  //    System.out.println("two is in nums");
}

@

@node Generic Constructors
@section Generic Constructors
@cindex generics, generic constructors
@cindex generic constructors

It is possible for constructors to be generic, even if their class is not
(@pxref{generics-constructor}). The syntax is the same (type parameters come
first).

@display
< @ii{type-param-list}> @ii{constructor-name} ( @ii{param-list} ) @{ @dots{}
@end display


@c ****************************************************************************

@node Enumerations
@chapter Enumerations
@cindex Enumerations
@cindex JDK 5
@cindex enumeration object
@cindex data type, enumeration
@cindex enumeration capabilities

Enumerations were added by JDK 5.  In earlier versions of Java, enumerations
were implemented using @code{final} variables.

An @dfn{enumeration} is a list of named constants that define a new data type
and its legal values.  In other words, an enumeration defines a class type.
An @dfn{enumeration object} can only hold values that were declared in the
list.  Other values are not allowed.  An enumeration allows the programmer to
define a set of values that a data type can legally have.

By making enumerations classes, the capabilities of the enumeration are
greatly expanded.  An enumeration can have:

@itemize
@item
constructors
@item
methods
@item
instance variables
@end itemize

@node Enumeration Basics
@section Enumeration Basics
@cindex Enumeration, basics
@cindex keyword, @code{enum}

An enumeration is created using the @code{enum} keyword.

@example
enum Apple @{
     Jonathon, GoldenDel, RedDel, Winesap, Cortland
@}
@end example

@subheading enumeration constants

@cindex enumeration constants
@cindex self-typed constants
The enum constants @samp{Jonathon}, @samp{GoldenDel}, etc. are called
@dfn{enumeration constants}.  The enumeration constants are declared as
@samp{public static final} members of the enum.  Their type is the type of
the enumeration in which they are declared.  These constants are called
@dfn{self-typed}, in which ``self'' refers to the enclosing enumeration.  

@subheading enumeration objects

You can create a variable of an enumeration type.  You do not instantiate an
@code{enum} using @code{new}.  Rather, you declare an @code{enum} variable
like you do for primitive types: @samp{Apple ap}.  Now, the variable
@code{ap} can only hold values of type Apple.

@example
Apple ap;
ap = Apple.RedDel;
@end example

The enum type must be part of the expression.  Enumeration constants can be
compared using the @samp{==} relational operator.  Furthermore, an
enumneration value can be used to control a @code{swith} statement.  The
@code{enum} prefix is not required for switch.

@example
switch(ap) @{
  case Jonathon: ...
  case Winesap: ...
@}
@end example

When an enumeration object is printed, its name is output (without the enum
type): @samp{System.out.println(ap)} would produce @samp{RedDel}.

@part The Java Standard Library

@node Strings
@chapter String Handling
@cindex Strings
@cindex String Handling

@node java Lang
@chapter @file{java.lang}
@cindex @file{java.lang}

Classes and interfaces defined by @file{java.lang}, which is automatically
imported into all programs.  Contains classes and interfaces that are
fundamental to all of Java programming.  Beginning with JDK 9, all of
@file{java.lang} is part of the @file{java.base} module.

@subheading @file{java.lang} includes the following classes
@cindex classed in @file{java.lang}

@itemize
@item Boolean
@item Byte
@item Character
@itemize
@item Character.Subset
@item Character.UnicodeBlock
@end itemize
@item Class
@item ClassLoader
@item ClassValue
@item Compiler
@item Double
@item Enum
@item Float
@item InheritableThreadLocal
@item Integer
@item Long
@item Math
@item Module
@itemize
@item ModuleLayer
@item ModuleLayer.Controller
@end itemize
@item Number
@item Object
@item Package
@item Process
@itemize
@item ProcessBuilder
@item ProcessBuilder.Redirect
@end itemize
@item Runtime
@itemize
@item RuntimePermission
@item Runtime.Version
@end itemize
@item SecurityManager
@item Short
@item StackFramePermission
@item StackTraceElement
@item StackWalker
@item StrictMath
@item String
@itemize
@item StringBuffer
@item StringBuilder
@end itemize
@item System
@itemize
@item System.LoggerFinder
@end itemize
@item Thread
@itemize
@item ThreadGroup
@item ThreadLocal
@end itemize
@item Throwable
@item Void
@end itemize

@subheading @file{java.lang} includes the following interfaces
@cindex interfaces in @file{java.lang}

@itemize
@item Appendable
@item AutoClosable
@item CharSequence
@item Clonable
@item Comparable
@item Iterable
@item ProcessHandle
@itemize
@item ProcessHandle.Info
@end itemize
@item Readable
@item Runnable
@item StackWalker.StackFrame
@item System.Logger
@item Thread.UncaughtExceptionHandler
@end itemize

@node Primitive Wrappers
@section Primitive Type Wrappers
@cindex Primitive Wrappers
@cindex Wrappers, Primitives
@cindex type wrappers

Java uses primitive types for @samp{int}, @samp{char}, etc. for performance
reasons.  These primitives are not part of the object hierarchy; they are
passed by-value, not by reference.  Sometimes you may need to create an
object representation for a primitive type.  To store a primitive in a
class, you need to wrap the primitive type in a class.

Java provides classes that correspond to each of the primitive types.
These classes encapsulate or @dfn{wrap} the primitive types within a
class.  They are commonly referred to as @dfn{type wrappers}.

@node Number
@subsection Number

@node Double and Float
@subsection Double and Float

@node isInfiinite() and isNaN()
@subsection isInfinite() and isNaN()

@node Byte Short Integer Long
@subsection Byte, Short, Integer, Long

@node Numbers to from String
@subsection Converting Numbers to and from String

@node java util Collections
@chapter @file{java.util} --- Part 1: The Collections Framework
@cindex @file{java.util} Collections Framework

@node java util Utility Classes
@chapter @file{java.util} --- Part 2: Utility Classes
@cindex @file{java.util} Utility Classes

@node  java io Input Output
@chapter @file{java.io} --- Input/Output
@cindex @file{java.io}

@node NIO
@chapter NIO
@cindex NIO

@node Networking
@chapter Networking
@cindex Networking

@node Event Handling
@chapter Event Handling
@cindex Event Handling

@node AWT
@chapter AWT: Working with Windows, Graphics, and Text
@cindex AWT
@cindex Windows
@cindex Graphics
@cindex Text

@node AWT Controls
@chapter Using AWT Controls, Layout Managers, and Menus
@cindex AWT Controls
@cindex AWT Layout Managers, Menus

@node Images
@chapter Images
@cindex Images

@node Concurrency
@chapter The Concurrency Utilities
@cindex Concurrency Utilities

@node Streams
@chapter The Stream API
@cindex Stream API
@cindex API, Stream

@node Regular Expressions
@chapter Regular Expressions and Other Packages
@cindex Regular Expressions

@node Swing
@chapter Introducinvg Swing
@cindex Swing

@node The Makefile
@appendix The Makefile
@cindex Makefile, The (appendix)

@(Makefile@)=
@<Makefile CONSTANTS@>
@<Makefile DEFAULTS@>
@<Makefile TANGLE WEAVE@>
@<Makefile CLEAN@>
@

@node Makefile Constants
@appendixsec Makefile Constants
@cindex Constants

@<Makefile CONSTANTS@>=
FILENAME := JavaSE9

@

@node Makefile Defaults
@appendixsec Makefile Default Targets
@cindex Makefile defaults

@<Makefile DEFAULTS@>=
.PHONY: all
all: tangle weave

@

@node Makefile Tangle Weave
@appendixsec Makefile Tangle Weave Targets
@cindex Makefile Tangle
@cindex Makefiel Weave

@<Makefile TANGLE WEAVE@>=
.PHONY: tangle weave jrtangle jrweave
tangle: jrtangle
weave: jrweave

jrtangle: $(FILENAME).twjr
	jrtangle $(FILENAME).twjr

jrweave: $(FILENAME).texi

$(FILENAME).texi: $(FILENAME).twjr
	jrweave $(FILENAME).twjr > $(FILENAME).texi
@

@node Makefile Clean
@appendixsec Makefile Clean Targets
@cindex Makefile Clean targets

@<Makefile CLEAN@>=
.PHONY: clean
clean:
	rm -f *~
	rm -f $(FILENAME).???

@

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@node List of Tables
@unnumbered List of Tables
@listoffloats Table

@node List of General Forms
@unnumbered List of General Forms
@listoffloats GeneralForm

@node Bibliography
@unnumbered Bibliography

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
