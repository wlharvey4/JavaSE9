\input texinfo   @c -*-texinfo-*-

@c %**start of header (This is for running Texinfo on a region.)
@setfilename JavaSE9.info
@settitle About Java SE 9
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH AUGUST, 2018
@set EDITION 0.1

@set TITLE Outline Covering Java SE 9
@set SHORTTITLE Java SE 9 Outline

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@ignore
@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} YYYY, YYYY @*
Full name here @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The FOO program is copyright
@copyright{} YYYY, YYYY by Full name here. It is published under
the conditions of the GNU General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying
@end ignore

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author LOLH

@ignore COPYRIGHT PAGES
@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Full name here @*
Address Line 1 @*
Address Line 2 @*
etc. @*
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@end ignore
@end titlepage

@set DRAFT @i{DRAFT}

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @value{TITLE}.

@c @insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@ignore
PREFATORY MATTER THRU ACKNOWLEDGEMENTS

@node Preface
@c @unnumbered Preface

Text here.

@node Audience
@c @unnumberedsec Intended Audience

Text here.

@node Overview
@c @unnumberedsec What Is Covered

Text and chapter by chapter description here.

@node Conventions
@c @unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@c @unnumberedsec Acknowledgements

@end ignore

@node Java SE 9 Introduction
@chapter Java SE 9 Introduction
@cindex Java SE 9 introduction
@cindex introduction to Java SE 9

@c *****************************************************************************
@node Packages
@chapter Packages
@cindex Packages (chapter)
@cindex containers, packages as
@cindex compartmentalized
@cindex class namespace, compartmentalize
@cindex packages, purposes, prevent collisions
@cindex collisions, prevention
@cindex packages, how stored
@cindex packages, import
@cindex import packages
@cindex hierarchical structure, packages

@ii{Packages} are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file names.
Packages are stored in a heirarchical manner and are explicitly imported into
new class definitions.

@node Packages Intro
@section Introduction to Packages
@cindex Introduction to Packages (section)
@cindex partitioning mechanism
@cindex naming mechanism
@cindex visibility mechanism
@cindex accessibility
@cindex exposure of code

Java provides a mechanism for partitioning the class name space into
manageble chunks: the PACKAGE.  The package is both a naming and a visibility
control mechanism.  In other words, you can use the package mechanism to
define classes inside a package that are not accessible by code outside the
package; and you can define class members that are exposed only to other
members of the same package.

@node Define Packages
@section Defining Packages
@cindex Packages, Defining (section)

To create a package, include the @command{package} command as the first
statement in a Java source file.  Thereafter, any classes declared within
that file will belong to the specified package.  The @command{package}
statement defines a name space in which classes are stored.  Without the
@command{package} statement, classes are put into the default package (which
has no name).

@subheading General Form of @command{package} statement
@cindex package statement, general form

@float GeneralForm,PackageStatement
@display
package @ii{pkg}
@end display
@caption{Package Statement --- General Form}
@end float

@ii{pkg} is the name of the package.  For example:
@cindex package statement, example

@example
package mypackage;
@end example

@subheading File System Directories

Java uses the file system directories to store packages.  Therefore, the
@code{.class} files for any classes you declare to be part of
@code{mypackage} must be stored in a directory called @code{mypackage}.  The
directory name must match the package name exactly.

More than one file can include the same @command{package} statement.  The
@command{package} statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other files
from being part of that same package.  Most real-world packages are spread
across many files.

@subheading Hierarchy of Packages
@cindex packages hierarchy

You can create a hierarch of packages.  To do so, separate each package name
form the one above it by use of a period.  The general form of a multileveled
package statement is:
@cindex package statement, multilevel form

@float GeneralForm,PackageStatementMulti
@display
package @ii{pkg1[.pkg2[.pkg3]]}
@end display
@caption{Package Statement --- Multilevel Form}
@end float

A package hierarchy must be reflected in the file system of your Java
development system.  For example a package declared as:

@example
package a.b.c;
@end example

needs to be stored in directory @code{a/b/c}.

Be sure to choose package names carefully; you cannot rename a package
without renaming the directory in which the classes are stored.

@node Classpath
@section Finding Packages and CLASSPATH
@cindex @env{CLASSPATH} @option{-classpath}
@cindex finding packages
@cindex run-time system
@cindex modules
@cindex module path

Packages are mirrored by directories.  How does the Java run-time system know
where to look for packages?

@table @b
@item @samp{cwd}
By default, the Java run-time system uses the currect working directory as
its starting point.  Thus, if your package is in a subdirectory of the
current directory, it will be found.
@item @env{CLASSPATH}
You can specify a directory path or paths by setting the @env{CLASSPATH}
environment variable.
@item @option{-classpath}
You can use the @option{-classpath} option with @command{java} and
@command{javac} to specify the path to your classes.
@item module path
Beginning with JDK 9, a package can be part of a module, and thus found on
the module path.
@end table

@subheading Example Finding a Package
@cindex finding packages, example

Consider the following package specification:

@example
package mypack;
@end example

In order for programs to find @code{mypack}, the program can be executed from
a directory @strong{immediadely above} @code{mypack}, or the @env{CLASSPATH}
must be set to include the path to @code{mypack} or the @option{-classpath}
option must specify the path to @code{mypack} when the program is run via
@command{java}.

When the second of the above options are used, the class path @strong{must
not include} @code{mypack} itself.  It must simply specify the @ii{path} to
@code{mypack}.  For example, if the path to @code{mypack} is

@example
/MyPrograms/Java/mypack
@end example

then the class path to @code{mypack} is

@example
/MyPrograms/Java
@end example

@node Member Access
@section Packages and Member Access
@cindex access control, packages
@cindex packages, access control
@cindex member access
@cindex access, member

Packages add another dimension to access control.  Classes and packages are
both means of encapsulating and containing the name space and scope of
variables and methods.  @emph{Packages} act as containiners for classes and
other subordinate packages.  @emph{Classes} act as containers for data and
code.  The class is Java's smallest unit of abstraction.  As it relates to
the interplay between classes and packages, Java addresses four categories of
visibility for class members:

@itemize
@item
Subclasses in the same package
@item
Non-subclasses in the same package
@item
Subclasses in different packages
@item
Classes that are neither in the same package nor subclasses
@end itemize

The three access modifiers

@itemize
@item
private
@item
public
@item
protected
@end itemize

provide a variaty of ways to produce many levels of access required by these
categories.
@cindex access control table

@float Table,PackageAccess
@multitable @columnfractions .4 .15 .15 .15 .15
@headitem Category @tab Private @tab None @tab Protected @tab public
@item
Same Class @tab Yes @tab Yes @tab Yes @tab Yes
@item
Same package subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Same package non-subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Different package subclass @tab No @tab No @tab Yes @tab Yes
@item
Different package noni-subclass @tab No @tab No @tab No @tab Yes
@end multitable
@caption {Package Access Table --- Shows all combinations of the access
control modifiers}
@shortcaption{Package Access Table}
@end float

@node Importing
@section Importing Packages
@cindex packages, importing
@cindex importing packages

Java includes the @command{import} statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be referred to
directly, using only its name.  The @command{import} statement is a
convenience to the programmer and is not technically needed to write a
complete Java program.

In a Java source file, @command{import} statements occur immediately
following the @command{package} statement (if one exists) and before any
class definitions.  This is the general form of the @command{import}
statement:
@cindex import statement, general form and example

@float GeneralForm,Import
@display
import @ii{pkg1}[.@ii{pkg2}].(@ii{classname} | *);
@end display
@caption{Import Statement --- General Form}
@end float

Here, @ii{pkg1} is the name of a top-level package, and @ii{pkg2} is the name
of a subordinate package inside the outerpackage separated by a dot
(@t{.}).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit @file{classname} or a star (@t{*}), which
indicates that the Java compile should import the entire package.

@example
import java.util.Date;
imort java.io.*;
@end example

@cindex standard Java classes, imported implicitly
@cindex @file{java.lang}
All of the standard Java SE classes included with Java begin with the name
@file{java}.  The basic language functions are stored in a package called
@file{java.lang}.  Normally, you have to import every package or class that
you want to use, but since Java is useless without much of the functionality
in @file{java.lang}, it is implicitly imported by the compiler for all
programs.  This is equivalent to the following line being at the top of all
your programs:

@example
import java.lang.*;
@end example

@cindex import is optional
@cindex fully qualified name
The @command{import} statement is @emph{optional}.  Any place you use a class
name, you can use its @emph{fully qualified name}, which includes its full
package hierarchy.

@cindex imported packages must be public
When a package is imported, only those items within the package declared as
@command{public} will be available to non-subclasses in the importing code.

@c *****************************************************************************
@node Interfaces
@chapter Interfaces
@cindex Interfaces (chapter)

@node Introduction to Interfaces
@section Interfaces Introduction
@cindex interfaces, introduction
@cindex keyword interface
@cindex abstract class
@cindex interface, implement
@cindex polymorphism, one interface multiple methods

Using the keyword @command{interface}, you can fully abstract a class'
interface from its implementation.  That is, using @command{interface}, you
can specify what a class must do, but not how to do it.  Interfaces are
syntactically similar to classes, but they lack instance variables, and, as a
general rule, their methods are declared without any body.  Once it is
defined, any number of classes can implement an @command{interface}.  Also,
one class can implement any number of interfaces.  To implement an interfce,
a class must provide the complete set of methods required by the interface.
Each class is free to determine the details of its own implementation.  By
providing the @command{interface} keyword, Java allws you to fully utilize
the ``one interface, multiple methods'' aspect of polymorphism.

@cindex dynamic method resolution
@cindex run-time
@cindex compile time
@cindex method signatures compatible
@cindex static environment
Interfaces are designed to support @dfn{dynamic method resolution} at run
time.  Normally, in order for a method to be called from one class to
another, both classes need to be present at compile time so the Java compiler
can check to ensure that the method signatures are compatible.  This
requirement by itself makes for a static and nonextensible classing
environment.  Inevitably in a system like this, functionality gets pushed up
higher and higher in the class hierarchy so that the mechanisms will be
available to more and more subclasses.  Interfaces are designed to avoid this
problem.  @emph{They disconnect the definition of a method or set of methods
from the inheritance hierarchy.}  Since interfaces are in a different
hierarchy from classes, it is possible for classes that are unrelated in
terms of class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.

@node Defining Interfaces
@section Defining Interfaces
@cindex interfaces, defining

An interface is defined much like a class.  Here is a simplified general form
of an interface definition:
@cindex interface definition, simplified general form

@float GeneralForm,InterfaceSimple
@display
@ii{access} interface @ii{name} @{
  @ii{return-type method-name1}(@ii{parameter-list});
  @ii{return-type method-name2}(@ii{parameter-list});

  @ii{type final-varname1} = @ii{value}
  @ii{type final-varname2} = @ii{value}
  @dots{}
  @ii{return-type method-nameN}(@ii{parameter-list});
  @ii{type final-varnameN} = @ii{value}
@}
@end display
@caption{Interface Definition --- Simplified General Form}
@end float

@cindex interface default access, no modified
@cindex interface public access
@cindex abstract methods, interface
@cindex interface methods, abstract methods
When no access modifier is included, then default access results, and the
interface is only available to other members of the package in which it is
declared.  When it is declared as @command{public}, the interface can be used
by code outside its package.  In this case, the interface mst be the only
public interface declared in the file, and the file must have the same name
as the interface.  The methods that are declared have no bodies.  They end
with a semicolon after the parameter list.  They are, essentially, abstract
methods.  Each class that includes such an interface must implement all of
the methods.

@subheading Variable Declarations inside Interfaces
@cindex interface variable declarations

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly @command{final} and @command{static},
meaning they cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly @command{public}.

@node Implementing Interfaces
@section Implementing Interfaces
@cindex interfaces, implementing
@cindex @command{implements} clause

Once an interface has been defined, one or more classes can implement that
interface.  To implement an interface, include the @command{implements}
clause in a class definition, and then create the methods required by the
interface.  The general form of a class that includes the
@command{implements} clause looks like this:

@float GeneralForm,ClassImplementsInterface
@display
class @ii{clasname} [extends @ii{superclass}] [implements @ii{interface} [,@ii{interface}@dots{}] @{
  @ii{class-body}
@}
@end display
@caption{Class Implementing Interface --- General Form}
@end float

@cindex interface method defintion, declared @command{public}
The methods that implement an interface must be declared @command{public}.
The type signature of the implementing method must match exactly the type
signature specified in the @command{interface} definition.

It is both permissible and common for classes that implement interfaces to
define additional members of their own.

@node Interface References
@section Accessing Implementations Through Interface References
@cindex interface references, accessing implementations
@cindex object references, interfaces
@cindex interfaces, key feature, reference look-ups
@cindex dynamic dispatch, interface method look-ups
@cindex dispatch through an interface

You can declare variables as object references that use an interface rather
than a class type.  Any instance of any class that implements the declared
interface can be referred to by such a variable.  When you call a method
through one of these references, the correct version will be called based on
the actual instance of the interface being referred to.  This is one of the
key features of interfaces.  The method to be executed is looked up
dynamically at run-time, allowing classes to be created later than the code
which calls methods on them.  The calling code can dispatch through an
interface without having to know anything about the ``callee.''  This process
is similar to using a superclass reference to access a subclass object.

@node Partial Implementations
@section Partial Implementations
@cindex interface, partial implementation

If a class includes an interface but does not implement the methds required
by that interface, then that class must be declared as @command{abstract}.
Any class that inherits the abstract class must implement the interface or be
declared @command{abstract} itself.

@node Nested Interfaces
@section Nested Interfaces
@cindex interfaces, nested
@cindex nested interfaces
@cindex member interfaces

An interface can be declared a member of a class or another interface.  Such
an interface is called a @dfn{member interface} or a @dfn{nested interface}.
A nested interface can be declared as @command{public}, @command{private}, or
@command{protected}.  This differs from a top-level interface, which must
either be declared as @command{public} or use the default access level.  When
a nexted interface is used outside of its enclosing scope, it must be
qualified by the name of the class or interface of which it is a member.
Thus, outside of the class or interface in which a nested interface is
declared, its name must be fully qualified.

@node Applying Interfaces
@section Applying Interfaces
@cindex intefaces, applying

See detailed example @dots{}

@node Variables in Interfaces
@section Variables in Interfaces
@cindex interfaces, final variables in
@cindex interfaces, shared constants

You can use interfaces to import shared constants into multiple classes by
simply declaring an interface that contains variables that are initialized to
the desired values.  When you include that interface in a class (when you
``implement'' the interface), all of those variable names will be in scope as
constants.  If an interface contains no methods, then any class that includes
such an interface doesn't actually implement anything.  It is as if that
class were importing this constant fields into the class name space as
@command{final} variables.

@node Extending Interfaces
@section Interfaces Can Be Extended
@cindex interfaces, extending
@cindex interfaces, inheriting
@cindex @command{extents}, with interfaces
@cindex extending interfaces
@cindex inheriting interfaces

One interface can inherit another by use of the keyword @command{extends}.
The syntax is the same as for inheriting classes.  When a class implements an
interface that inherits another interface, it must provide implementations
for all methods required by the interface inheritance chain.

@node Default Interface Methods
@section Default Interface Methods
@cindex index interface, default methods
@cindex default methods, interface
@cindex abstract methods, interface
@cindex interface, traditional form
@cindex JDK 8, default method in interface

Prior to JDK 8, an interface could not define any implementation whatsoever.
This meant that for all previous versions of Java, the methods specified by
an interface were abstract, constaining no body.  This is the traditional
form of an interface.  The release of JDK 8 changed this by adding a new
capability to @command{interface} called the @dfn{default method}.  A default
method lets you define a default implementation for an interface method.  It
is possible for an interface method to provide a body, rather than being
abstract.

@cindex default method, interface, motivation
@cindex preexisting code, default method, interface
A primary motivation for the default method was to provide a means by which
interfaces could be expanded without breaking existing code.  There must be
implementations for all methods defined by an interface.  If a new method
were added to a popular, widely used interface, then the addition of that
method would break existing code because no implementation would be found for
that new method.  The default method solves this problem by supplying an
implementation that willbe used if no other implementation is explicitly
provided.  Thus, the addition of a default method will not cause preexisting
code to break.

Another motivation for the default method was the desire to specify methods
in an interface that are, essentially, optional, depending on how the
interface is used.

@subheading Interfaces Do No Maintain State and Cannot Be Created
@cindex interfaces, key aspect, no state
@cindex difference between class and interface

It is important to point out that the addition of default methods does not
change a key aspect of @command{interface}: its inability to maintain state
information.  An interface still cannot have instance variables, for example.
Thus, @strong{the defining difference between an interface and a class is
that a class can maintain state information, but an interface cannot.}
Furthermore, it is still not possible to create an instance of an interface
by itself.  It must be implemented by a class.

@node Interface Static Methods
@section Use Static Methods in an Interface
@cindex interface, static method
@cindex static method, interface
@cindex method, static, interface
@cindex JDK 8, static interface method

Another capability added to interface by JDK 8 is the ability to define one
or more @command{static} methods.  Like @command{static} methods in a class,
a @command{static} method defined by an interface can be called independently
of any object.  Thus, no implementation of the interface is necessary, and no
instance of the interface is required, in order to call a @command{static}
method.  Instead, a @command{static} method is called by specifying the
interface name, followed by a period, followed by the method name.  Here is
the general form:

@float GeneralForm,InterfaceStaticMethod
@display
@ii{InterfaceName.staticMethodName}
@end display
@caption{Interface Static Method, Calling}
@end float

Notice that this is similar to the way that a @command{static} method in a
class is called.  However, @command{static} interface methods are not
inherited by either an implementing class or a subinterface.

@node Private Interface Methods
@section Private Interface Methods
@cindex interface methods, private
@cindex JDK 9, private interface method

Beginning with JDK 9, an interface can include a private method.  A private
interface method can be called only by a default method or another private
method defined by the same interface.  Because a private interface method is
specified @command{private}, it cannot be used by code outside the interface
in which it is defined.  This restriction includes subinterfaces because a
private inteface method is not inherited by a subinterface.

The key benefit of a private interface method is that it lets two or more
default methods use a common piece of code, thus avoiding code duplication.

@c ****************************************************************************
@node The Makefile
@appendix The Makefile
@cindex Makefile, The (appendix)

@(Makefile@)=
@<Makefile CONSTANTS@>
@<Makefile DEFAULTS@>
@<Makefile TANGLE WEAVE@>
@<Makefile CLEAN@>
@

@node Makefile Constants
@appendixsec Makefile Constants
@cindex Constants

@<Makefile CONSTANTS@>=
FILENAME := JavaSE9

@

@node Makefile Defaults
@appendixsec Makefile Default Targets
@cindex Makefile defaults

@<Makefile DEFAULTS@>=
.PHONY: all
all: tangle weave

@

@node Makefile Tangle Weave
@appendixsec Makefile Tangle Weave Targets
@cindex Makefile Tangle
@cindex Makefiel Weave

@<Makefile TANGLE WEAVE@>=
.PHONY: tangle weave jrtangle jrweave
tangle: jrtangle
weave: jrweave

jrtangle: $(FILENAME).twjr
	jrtangle $(FILENAME).twjr

jrweave: $(FILENAME).texi

$(FILENAME).texi: $(FILENAME).twjr
	jrweave $(FILENAME).twjr > $(FILENAME).texi
@

@node Makefile Clean
@appendixsec Makefile Clean Targets
@cindex Makefile Clean targets

@<Makefile CLEAN@>=
.PHONY: clean
clean:
	rm -f *~
	rm -f $(FILENAME).???

@

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs


@node List of Tables
@unnumbered List of Tables
@listoffloats Table

@node List of General Forms
@unnumbered List of General Forms
@listoffloats GeneralForm

@node Bibliography
@unnumbered Bibliography

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
