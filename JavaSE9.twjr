\input texinfo   @c -*-texinfo-*-

@c %**start of header (This is for running Texinfo on a region.)
@setfilename JavaSE9.info
@settitle About Java SE 9
@deftypefnnewline on
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH OCTOBER, 2018
@set TITLE Outline Covering Java SE 9
@set SHORTTITLE Java SE 9 Outline
@set EDITION 0.1
@set VERSION 0.3.1

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@c @synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@ignore
@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} YYYY, YYYY @*
Full name here @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The FOO program is copyright
@copyright{} YYYY, YYYY by Full name here. It is published under
the conditions of the GNU General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying
@end ignore

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author LOLH

@ignore COPYRIGHT PAGES
@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Full name here @*
Address Line 1 @*
Address Line 2 @*
etc. @*
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@end ignore
@end titlepage

@set DRAFT @i{DRAFT}

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| Version @value{VERSION} @| @thispage
@end iftex




@c *****************************************************************************

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @value{TITLE}.

@c @insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@ignore
PREFATORY MATTER THRU ACKNOWLEDGEMENTS

@node Preface
@c @unnumbered Preface

Text here.

@node Audience
@c @unnumberedsec Intended Audience

Text here.

@node Overview
@c @unnumberedsec What Is Covered

Text and chapter by chapter description here.

@node Conventions
@c @unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@c @unnumberedsec Acknowledgements

@end ignore




@c *****************************************************************************

@part The Java Language

@node Java SE 9 Introduction
@chapter Java SE 9 Introduction
@cindex Java SE 9 introduction
@cindex introduction to Java SE 9




@c *****************************************************************************

@node Classes
@chapter Classes
@cindex Classes

The class is the logical construct upon which the Java language is built
because it defines the shape and nature of an object, and therefore forms
the basis for object-oriented programming in Java.

@c -----------------------------------------------------------------------------

@node Class Fundamentals
@section Class Fundamentals
@cindex Class fundamentals
@cindex class, new data type
@cindex template, class
@cindex object, class
@cindex instance, class

A @dfn{class} defines a new data type.  Once defined, this new type can be
used to create objects of that type.  A class is therefore a @i{template}
for an object, and an @dfn{object} is an @i{instance} of a class.
@i{Object} and @i{instance} are often used interchangeably.

@node General Form
@subsection General Form of a Class
@cindex class, general form

When you define a class, you declare its exact form and nature.  You do this
by specifying the data that it contains and the code that operates on that
data.  A class is declared by use of the @code{class} keyword.

@float GeneralForm,ClassDeclaration
@display
class @ii{classname} @{
  @ii{type instance-variable1};
  @ii{type instance-variable2};
  @dots{}
  @ii{type instance-variableN};

  @ii{type method-name1} (@ii{parameter-list} @{
    @ii{body of method}
  @}

  @ii{type method-name2} (@ii{parameter-list} @{
    @ii{body of method}
  @}
  @dots{}
  @ii{type method-nameN} (@ii{parameter-list} @{
    @ii{body of method}
  @}
@}
@end display
@caption{Class Declaration --- General Form}
@end float

@cindex instance variables
@cindex methods
@cindex members
The data, or variables, defined within a class are called @dfn{instance variables}.
The code is contained within @dfn{methods}.  Collectively, the methods and
variables defined within a class are called @dfn{members} of the class.
In most cases, the instance variables are acted upon and accessed by the
methods defined for that class.  As a general rule, it is the methods that
determine how a class' data can be used.

Each instance of the class (that is, each object of the class) contains its
own copy of the instance variables.  The data for one object is separate and
unique from the data for another.  Changes to the instance variables of one
object have no effect on the instance variables of another.

@cindex @samp{main()} method, class
Java classes do not need to have a @samp{main()} method; you only need to
specify one if that class is the starting point for the program.

@cindex dot operator
In general, you use the @dfn{dot operator} to access both the instance
variables and the methods within an object.  Although commonly referred to
as the dot @emph{operator}, the formal specification for Java categorizes
the @t{.} as a @emph{separator}.

@c -----------------------------------------------------------------------------

@node Declaring Objects
@section Declaring Objects
@cindex objects, declaring
@cindex @command{new} operator
@cindex run time, dynamic allocation
@cindex dynamic allocation, run time
@cindex constructor

Because a class creates a new data type, you can use this type to declare
objects of that type.  Obtaining objects of a class is a two-step process.

@enumerate
@item
Declare a variable of the class type; this variable does not define an
object.  Instead, it is simply a variable that can @emph{refer} to an object.
@item
Acquire an actual, physical copy of the object and assign it to the
variable; you can do this using the @command{new} operator.  The
@command{new} operator dynamically allocates (at run time) memory for an
object, and returns a reference to to.  This reference is (essentially) the
address in memory of the object allocated by @command{new}.  This reference
is then stored in the variable.  In Java, all class objects must be
dynamically allocated.
@end enumerate

@heading Example Declaration, Allocation, and Assignment

@example
Box mybox; // 1. declare a variable
mybox = new Box(); // 2. allocate a Box object
@end example

These two declarations can be combined into a single declaration, and
usually are:

@example
Box mybox = new Box();
@end example

The @code{mybox} variable simply holds the memory address of the actual
@code{Box} object.  The class name followed by parenthese specifies the
@dfn{constructor} for the class.

@c -----------------------------------------------------------------------------

@node Methods
@section Methods
@cindex Methods

@heading General Form of a Method Declaration

@float GeneralForm,MethodDeclaration
@display
@ii{type name} (@ii{parameter-list}) @{
  @ii{body of method}
@}
@end display
@caption{Method Declaration --- General Form}
@end float

@cindex type, method
@cindex name, method
@cindex parameter list, method

@ii{type} specifies the type of data returned by the method.  This can be
any valid type, including class types that you create.  If the method does
not return a value, its return type must be @code{void}.

@dfn{name} is the name of the method.  This can be any legal identifier.

@dfn{parameter-list} is a sequence of type and identifier pairs separated by
commas.  @dfn{Parameters} are essentially variables that receive the value
of the arguments passed to the method when it is called.  If the method has
no parameters, then the parameter list will be empty.

Methods that have a return type other than @code{void} return a value to the
calling routine using a @dfn{return statement}:

@display
return @ii{value}
@end display

where @ii{value} is the value returned.

@c -----------------------------------------------------------------------------

@node Constructors
@section Constructors
@cindex Constructors

Java allows objects to initialize themselves when they are created.  This
automatic initialization is performed through the use of a constructor.

A @dfn{constructor} initializes an object immediately upon creation.  It has
the same name as the class in which it resides and is syntactically similar
to a method.  Once defined, the constructor is automatically called when the
object is created, before the @command{new} operator completes.
Constructors have no return type.  It is the constructor's job to initialize
the internal state of an object so that the code creating an instance will
have fully initialized, usable object immediately.

@node this Keyword
@section The @code{this} Keyword
@cindex @code{this} Keyword

Sometimes a method will need to refer to the object that invoked it.  To
allow this, Java defines the @code{this} keyword.  @code{this} can be used
inside any method to refer to the @emph{current} object.  That is,
@code{this} is always a refernce to the object on which the method was
invoked.  You can use @code{this} anywhere a reference to an object of the
current class' type is permitted.

@node Instance Variable Hiding
@subsection Instance Variable Hiding
@cindex hiding, instance variables

It is illegal to declare two local variables with the same name inside the
same or enclosing scope.  However, you can have local variables, including
formal parameters to methods, which overlap with the names of the class'
instance variables.  For these cases, the local variables @emph{hide} the
instance variables of the same name.

Because @code{this} lets you refer directly to the object, you can use it to
resolve any namespace collisions that might occur between instance variables
and local variables.  So, @kbd{this.width = width} is an example of a local
variable (@kbd{width}) hiding an instance variable (also @kbd{width}), with
@code{this} allowing an assignment between them.

@c -----------------------------------------------------------------------------

@node Stack Class
@section A Stack Class
@cindex Stack Class

To see a practical application of object-oriented programming, here is one
of the archetypal examples of encapsulation: the stack.  A @dfn{stack}
stores data using @emph{first-in, last-out} ordering.  That is, a stack is
like a stack of plates on a table --- the first plate put down on the table
is the last plate to be used.  Stacks are controlled through two operations
traditionally called @dfn{push} and @dfn{pop}.  To put an item on top of the
stack, you will use @command{push}.  To take an item off the stack, you will
use @command{pop}.  It is easy to encapsulate the entire stack mechanism.

Here is a class called @code{Stack} that implements a stack for up to ten
integers, plus test class called @code{TestStack}:

@heading Stack.java
@pindex @file{Stack.java}

@(Stack.java@)=
class Stack {
  @<Stack Instance Variables@>
  @<Stack Constructor@>
  @<Stack Instance Methods@>
}

@

@heading TestStack.java
@pindex @file{TestStack.java}

@(TestStack.java@)=
class TestStack {
  @<TestStack Main Method@>
}

@

@node Stack Instance Variables
@subsection Stack Instance Variables

@<Stack Instance Variables@>=
int[] stck = new int[10];
int tos;

@

@node Stack Constructor Node
@subsection Stack Constructor Subsection

@<Stack Constructor@>=
// initialize top-of-stack tos
Stack() {
  tos = -1;
}

@

@node Stack Instance Methods Node
@subsection Stack Instance Methods Subsection

@<Stack Instance Methods@>=
@<Stack Push@>
@<Stack Pop@>
@

@node Stack Push and Pop Node
@subsubsection Stack Push and Pop Subsubsection

@<Stack Push@>=
// Push an item onto the stack
void push(int item) {
  if (tos == 9)
    System.out.println("Stack is full.");
  else
    stck[++tos] = item;
}

@

@<Stack Pop@>=
// Pop an item from the stack
int pop() {
  if (tos < 0) {
    System.out.println("Stack underflow.");
    return 0;
  } else
    return stck[tos--];
  }
}

@

@node Stack TestStack Node
@subsection Stack TestStack Subsection

@<TestStack Main Method@>=
public static void main(String[] args) {
  Stack mystack1 = new Stack();
  Stack mystack2 = new Stack();

  // push some numbers onto the stack
  for (int i = 0; i < 10; i++)
    mystack1.push(i);
  for (int i = 10; i < 20; i++)
    mystack2.push(i);

  // pop those numbers off the stack
  System.out.println("Stack in mystack1:");
  for (int i = 0; i < 10; i++)
    System.out.println(mystack1.pop());

  System.out.println("Stack in mystack2:");
  for (int i + 0; i < 10; i++)
    System.out.println(mystack2.pop());
}

@





@c *****************************************************************************

@node Methods and Classes
@chapter Methods and Classes
@cindex Methods and Classes

This chapter examines several topics relating to methods and classes,
including

@itemize
@item
overloading
@item
parameter passing
@item
recursion
@item
access control
@item
keywords @code{static} and @code{final}
@item
@code{String} class
@item
Arrays
@item
nested and inner classes
@item
command-line arguments and varargs
@end itemize

@c -----------------------------------------------------------------------------


@node Overloading Methods
@section Overloading Methods
@cindex overloading methods
@cindex methods, overloading
@cindex overload, overloaded
@cindex polymorphism, overloading of methods
@cindex overloading, automatic type conversion
@cindex @emph{one interface, multiple methods}

It is possible to define two or more methods within the same class that share
the same name as long as their parameter declarations are different.  When
this is the case, the methods are said to be @dfn{overloaded}, and the
process is referred to as @dfn{method overloading}.  Method overloading is
one of the ways that Java supports polymorphism.

When an overloaded method is invoked, Java uses the type and number of
arguments as its guide to determine which version of the overloaded method to
actually call.  Thus, overloaded methods must differ in the type or number of
their parameters.  While overloaded methods may have different return types,
thei return type alone is inusfficient to distinguish two versions of a
method.  When Java encounters a call to an overloaded method, it simply
executes the version of the method whose parameters match the arguments used
in the call.

The match between arguments and parameters need not always be exact.  In some
cases,Java's automatic type conversions can play a role in overload
resolution.  For example, if there is a method with one @code{double}
parameter, and that method is invoked with a single @code{int} argument,
then, when no exact match is found, Java will automatically convert the
integer into a @code{double}, and this conversion will be used to resolve the
call.  Java will employ automatic type conversion only if no exact match is
found.

Method overloading supports polymorphism because it is one way that Java
implements the @emph{one interface, multiple methods} paradigm.  That is,
Java does not need to rename each similar method just because it has a
slightly different parameter requirements.  The value of overloading is that
it allows related methods to be accessed by use of a common name,
representing the @emph{general action} that is being performed, and leaves to
the compiler the choice of the right @emph{specific} version for a particular
circumstance.  The programmer need only remember the general operation being
performed.  Through the application of polymorphism, several names have been
reduced to one.  Overloading can help manage greater complexity.


@c .....................................

@node Overloading Constructors
@subsection Overloading Constructors
@cindex overloading constructors
@cindex constructors, overloading

You can also overload constructor methods.  


@c -----------------------------------------------------------------------------

@node Objects as Parameters
@section Objects as Parameters
@cindex objects as parameters
@cindex parameters, as objects

It is both correct and common to pass objects to methods as well as primitive
types.  One of the most common uses of object parameters involves
constructors.  Frequently you will want to construct a new object so that it
is initially the same as some existing object.  To do this, you must define a
constructor that takes an object of its class as a parameter.  Providng many
forms of constructors is usually required to allow objects to be constructed
in a convenient and efficient manner.


@c -----------------------------------------------------------------------------

@node Argument Passing
@section Argument Passing
@cindex argument passing

In general, there are two ways that a computer language can pass an argument
to a subroutine:

@enumerate
@item
call-by-value
@item
call-by-reference
@end enumerate

Java uses call-by-value to pass all arguments, although the precise effect
differs between whether a primitive type or a reference type is passed.

When you pass a primitive type to a method, it is passed by value.  Thus, a
copy of the argument is made, and what occurs to the parameter that receives
the argument has no effect outside the method.

When you pass an object to a method, the situation changes; objects are
passed by what is effectively call-by-reference.  When you pass a variable of
a class type, you pass a reference to the method and the parameter receiving
it will refer to the same object.  This effectively means that objects act as
if they are passed to methods by use of call-by-reference.  Changes to the
object inside the method @emph{do} affect the object used as an argument.
However, when an object reference is passed to a method, the reference itself
is passed by use of call-by-value; therefore, that reference will continue to
refer to the object, even though the object itself may be modified.


@c -----------------------------------------------------------------------------

@node Returning Objects
@section Returning Objects
@cindex objects, returning from methods
@cindex objects, dynamical allocation
@cindex objects, references to

A method can return any type of data, including class types that you create.

Since all objects are dynamically allocated using @command{new}, you don't
need to worry about an object going out-of-scope because the method in which
it was created terminates.  The object will continue to exist as long as
there is a reference to it somewhere in your program.  When there are no
references to it, the object will be reclaimed the next time garbage
collection takes place.


@c -----------------------------------------------------------------------------

@node Recursion
@section Recursion
@cindex recursion, recursive
@cindex iteration, iterative
@cindex stack overun, recursion
@cindex stack exhaustion, recursion

@dfn{Recursion} is the process of defining something in terms of itself.  In
programming, it is also what allows a method to call itself.  A method that
calls itself is said to be @dfn{recursive}.

When a method calls itself, new local variables and parameters are allocated
storage on the stack, and the method code is executed with these new
variables from the start.  As each recursive call returns, the old local
variables and parameters are removed from the stack, and execution resumes at
the point of the call inside the method.

Recursive versions of many routines may execute a bit slower than the
iterative equivalent because of the added overhead of the additional method
calls.  A large number of recursive calls to a method could cause a stack
overrun.  Because storage for parameters and local varibles is on the stack
and each new call creates a new copy of these variables, it is possible that
the stack could be exhausted.  If this occurs, the Java run-time system will
cause an exception.

The main advantage to recursive methods is that they can be used to create
clearer and simpler versions of several algorithms than can their iterative
relatives.  For example, the QuickSort sorting algorithm is quite difficult
to implement in an iterative way.  Also, some types of AI-related algorithms
are most easily implemented using recursive solutions.


@c -----------------------------------------------------------------------------

@node Access Control
@section Access Control
@cindex access control, single class
@cindex encapsulation, access control
@cindex access modifiers

Encapsulation provides another important attribute besides linking data with
code: @dfn{access control}.  Through encapsulation, you can control what
parts of a program can access the members of a class.  By controlling access,
you can prevent misuse.  Thus, when correctly implemented, a class creates a
@emph{black box} which may be used, but the inner workings of which are not
open to tampering.  The classes introduced earlier do not completely meet
this goal.  For example, the @code{Stack} class provides the methods
@code{push()} and @code{pop()} as a controlled interface to the stack, this
interface is not enforced --- it is possible for another part of the program
to bypass these methods and access the stack directly.  This could lead to
trouble.

How a member can be accessed is determined by the @dfn{access modifier}
attached to its declaration.  Java supplies a rich set of access modifiers.
Some aspects of access control are related mostly to inheritance or packages
(and now modules).  Those ideas will be discussed later.  Here, let's examine
access control as it relates to a single class.

@subheading Access Modifiers
@cindex public access modifier
@cindex private access modifier
@cindex protected access modifier
@cindex default access level

Java's access modifiers are:

@itemize
@item
public
@item
private
@item
protected (applies only to inheritance)
@item
default access level
@end itemize

@subsubheading @code{public} vs @code{private} Access

When a member of a class is modified by @code{public}, then that member can
be accessed by any other code.  When a member of a class is specified as
@code{private}, then that member can only be accessed by other members of its
class.  Thus, the method @code{main()} is always preceded by the
@code{public} modifier.  It must be called by code that is outside the
program --- the Java run-time system.

@subheading Default Access --- No Access Modifier

When no access modifier is used, then by default the member of a class is
public within its own package, but cannot be accessed outside of its
package.  In the classes developed so far, all members of a class have used
the @code{default} access mode.  However, this is typically not what you will
want to be the case.  Usually, you will want to restrict access to the data
members of a class --- allowing access only through methods.  There will also
be times when you will want to define methods that are private to a class.

@subheading Access Modifier Syntax

An access modifier precedes the rest of a member's type specification.  That
is, it must begin a member's declaration statement.  As an example:

@example
public int i;
private double j;

private int myMethod(int a, char b) @{
  @dots{}
@}
@end example

@subheading Access Control and Inheritance

Consult the chapter on @ref{Inheritance} for more on the topic of access
control in relation to inheritance.

@c ........................................

@node Improved Stack Class
@subsection An Improved @code{Stack} Class
@cindex @code{Stack} class, improved

@subheading StackImproved.java
@pindex @file{StackImproved.java}

Compare this code with that of @ref{Stack Class}.  @footnote{Notice how all
of the prior code except what is changed can easily be reused using
TexiWebJr's modular system.}

@(StackImproved.java@)=
class StackImproved {
  @<Stack Private Instance Variables@>
  @<Stack Constructor@>
  @<Stack Instance Methods@>
}

@

@subheading Stack Private Instance Variables

@<Stack Private Instance Variables@>=
/* Now, both stck and tos are private.  This means
   that they cannot be accidentally or maliciously
   altered in a way that would be harmful to the stack.
 */

private int[] stck = new int[10];
private int tos;

@

Now both @code{stck}, which holds the stack, and @code{tos}, which is the
index of the top of the stack, are specified as @code{private}.  This means
that they cannot be accessed or altered except through @code{push()} and
@code{pop()}.  Making @code{tos} private, for example, prevents other parts
of your program from inadvertently setting it to a value that is beyond the
end of the @code{stck} array.  In other words, the following code, added to
the end of the @code{TestStack.java} program (@pxref{TestStack-Main-Method}),
would be illegal and the program would not compile:

@example
mystack1.tos = -2;
mystack2.stck[3] = 100;
@end example


@c -----------------------------------------------------------------------------

@node static Keyword
@section @code{static} Keyword
@cindex @code{static} Keyword
@cindex keyword @code{static}
@cindex @code{static} members

There will be times when you want to define a class member that will be used
independently of any object of that class.  Normally, a class member must be
accessed in conjunction with an object of its class.  However, it is possible
to create a member that can be used by itself without reference to a specific
instance.  To create such a member, precede its declaration with the keyword
@code{static}.  When a member is declared @code{static}, it can be accessed
before any objects of its class are created, and without reference to any
object.

You can declare both methods and variables to be @code{static}.  Instance
variables declared as @code{static} are essentially global variables.  When
objects of its class are declared, no copy of a @code{static} variable is
made.  Instead, all instances of the class share the same @code{static}
variable.

@subheading Restrictions on @code{static} Methods
@cindex static restrictions on methods

Methods declared as @code{static} have several restrictions:

@itemize
@item
they can only directly call other @code{static} methods of their class;
@item
they can only directly access @code{static} variables of their class;
@item
they cannot refer to @code{this} or @code{super} in any way;
@end itemize

@subheading @code{static} Block
@cindex @code{static} initialization block

If you need to do computation in order to initialize your @code{static}
variables, you can declare a @code{static} block that gets executed exactly
once, when the class is first loaded (@dfn{static initialization block}).

@example
class UseStatic @{
  static int a = 3;
  static int b;

  static @{
    b = a * 4;
  @}
@}
@end example

As soon as the @code{UseStatic} class is loaded, all of the @code{static}
statements are run.  First, @code{a} is set to @samp{3}, then the
@code{static} block executes and initializes @code{b} to @samp{a * 4} or
@samp{12}.  Then @code{main()} is called (not shown).

@subheading Use of @code{static} Members Outside Their Class
@cindex global members

Outside of the class in which they are defined, @code{static} methods and
variables can be used independently of any object.  To do so, you need only
specify the name of their class followed by the dot operator:
@slanted{classname.method()}.  @slanted{classname} is the name of the class
in which the @code{static} method is declared.  A @code{static} variable can
be accessed in the same way.  This is how Java implements a controlled
version of global methods and global variables.


@c -----------------------------------------------------------------------------

@node final Keyword
@section @code{final} Keyword
@cindex @code{final} Keyword
@cindex keyword @code{final}
@cindex constant, @code{final} variable

A field can be declared as @code{final}.  Doing so prevents its contents from
being modified, making it, esentially, a constant.  This means that you must
initialize a @code{final} field when it is declared.  You can do this in one
of two ways: when it is declared, or within a constructor.

In addition to fields, both method parameters and local variables can be
declared as @code{final}.  Declaring a parameter as @code{final} prevents it
from being changed within the method.  Declaring a local variable
@code{final} prevents it from being assigned a value more than once.

The keyword @code{final} can also be applied to methods, but its meaning is
different than when applied to variables.  This usage of @code{final} is
described in the next chapter (@pxref{Inheritance}).


@c -----------------------------------------------------------------------------

@node Arrays 2
@section Arrays Revisited
@cindex Arrays
@cindex arrays as objects
@cindex @code{length} instance variable

Arrays are implemented as objects.  Because of this, there is a special array
attribute that you will want to take advantage of.  Specifically, the size of
an array---that is, the number of elements that an array can hold---is found
in its @code{length} instance variable.  All arrays have this variable, and
it will always hold the size of the array.  Keep in mind that the value of
@code{length} has nothing to do with the number of elements that are actually
in use.  It only reflects the number of elements taht the array is designed
to hold.

@c -----------------------------------------------------------------------------

@node Nested and Inner Classes
@section Nested and Inner Classes
@cindex nested classes
@cindex static and non-static nested classes
@cindex inner classes
@cindex classes, nested and inner
@cindex inner classes, event handling
@cindex anonymous inner classes
@cindex inner classes, anonymous

It is possible to define a class within another class; such classes are known
as @dfn{nested classes}.  The scope of a nested class is bounded by the scope
of its enclosing class.  A nested class does not exist independently of its
enclosing class.  A nested class has access to the members, including private
members, of the enclosing class.  However,the enclosing class does not have
access to the members of the nested class.  A nested class that is declared
directly within its enclosing class scope is a member of its enclosing
class.  It is also possible to declare a nested class that is local to a
block.

@heading Static Nested Class

There are two types of nested class: @dfn{static} and @dfn{inner}.  A
static nested class is one that has the @code{static} modifer applied.
Because it is static, it must access the non-static members of its enclosing
class through an object.  That is, it cannot refer to non-static members of
its enclosing class directly.  Static nested classes are seldom used.

@heading Inner Class

The most important type of nested class is the @dfn{inner} class.  An inner
class is a non-static nested class.  It has access to all of the variables
and methods of its outer class and may refer to them directly in the same way
that other non-static members of the outer class do.

An instance of an inner class can be created only in the context of its
enclosing class.  The Java compiler will report an error otherwise.  In
general, an inner class instance is often creaed by code within its enclosing
scope.

It is possible to define inner classes within any block scope, including
within the block defined by a method or even within the body of a @code{for}
loop.

@heading Handling Events

While nested classes are not applicable to all situations, they are
particularly helpful when handling events.  @xref{Event Handling}.  There are
also @dfn{anonymous inner classes}, inner classes that don't have a name.

@c -----------------------------------------------------------------------------

@node String Class
@section The @code{String} Class
@cindex @code{String} Class
@cindex class @code{String}

Every string you create is an object of type @code{String}.  Even string
constants are @code{String} objects.  For example, in the statement
@kbd{System.out.println("This is a String, too");}, the quote is a
@code{String} object.  

Objects of type @code{String} are immutable; once a @code{String} object is
created, its contents cannot be altered.  Java defines peer classes of
@code{String}, called @code{StringBuffer} and @code{StringBuilder}, which
allow strings to be altered, so all of the normal string manipulations are
still available.

@heading Constructing @code{String} Objects and Concatenating @code{Strings}
@cindex @code{String} construction
@cindex @code{String} concatenation
@cindex @code{String} operator @kbd{+}

Strings can be constructed in a variable of ways.  The easiest is to use a
statement:

@example
String myString = "this is a test";
@end example

Java defines one operator for @code{String} objects: @kbd{+}.  It is used to
concatenate two strings.

@example
String myString = "I" + " like " + "Java.";
@end example

@heading @code{String} Methods
@cindex @code{String} methods
@cindex @code{equals()}
@cindex @code{length()}
@cindex @code{charAT()}

The @code{String} class contains several methods that you can use.

@itemize
@item
boolean @code{equals(@slanted{secondStr})}
@item
int @code{length()}
@item
char @code{charAt(@slanted{index})}
@end itemize


@c -----------------------------------------------------------------------------

@node Command-Line Arguments
@section Using Command-Line Arguments
@cindex command-line arguments
@cindex arguments, command-line

Sometimes you will want to pass information into a program when you run it.
This is accomplished by passing @dfn{command-line arguments} to
@code{main()}.  A command-line argument is the informatino that directly
follows the program's name on the command line when it is executed.  To
access the command-line arguments inside a Java program, access the
@code{String} arguments passed to the @code{args} parameter of
@code{main()}.  The first command-line argument is stored at @code{args[0]},
the second at @code{args[1]}, and so on.  All command-line arguments are
passed as strings.  You must convert numeric values to their internal forms
manually.  @xref{java.lang}.

@c -----------------------------------------------------------------------------

@node Varargs
@section Varargs: Variable-Length Arguments
@cindex varargs
@cindex variable-length arguments
@cindex arguments, varargs
@cindex variable-arity method
@cindex varargs method
@cindex method, varargs

Beginning with JDK 5, Java has included a feature that simplifies the
creation of methods that need to take a variable number of arguments.  This
feature is called @dfn{varargs} and it is short for @dfn{variable-length
arguments}.  A method that takes a variable number of arguments is called a
@dfn{variable-arity method}, or simply @dfn{varargs method}.

A variable-length argument is specified by three period (@dots{}).  For
example: @kbd{static void vaTest (int @dots{} v) @{}.  This syntax tells the
compiler that @code{vaTest()} can be called with zero or more arguments.  As
a result, @code{v} is implicitly declared as an array of type @code{int[]}.
Thus, inside @code{vaTest()}, @code{v} is accessed using the normal array
syntax. 

A method can have @emph{normal} parameters along with a variable-length
parameter, but the variable-length parameter must be the final parameter
declared by the method.  Further, there can be only one varargs parameter.

@example
int doIt(int a, int b, double c, int @dots{} vals) @{
@end example

After the first three arguments, any remaining arguments are passed to
@code{vals}.  

@heading Overloading Vararg Methods
@cindex vararg overloading
@cindex vararg ambiguity

You can overload a method that takes a variable-length argument (i.e., it can
be given a different type, or additional parameters can be included, or a non
varargs parameter).

Note that unexpected errors can result when overloading a method that takes a
variable-length argument.  These errors involve ambiguity because it is
possible to create an ambiguous call to an overloaded varargs method.  In
such a case, the program will not compile.  While each individual method
declaration might be valid, the call might yet be ambiguous.





@c *****************************************************************************

@node Inheritance
@chapter Inheritance
@cindex Inheritance
@cindex superclass
@cindex subclass
@cindex hierarchical classifications

Inheritance is a cornerstone of object-oriented programming because it allows
the creation of hierarchical classifications.  Using inheritance, you can
create a general class that defines traits common to a set of related items.
This class can then be inherited by other, more specific classes, each adding
those things that are unique to them.

A class that is inherited is called a @dfn{superclass}.  The class that does
the inheriting is called a @dfn{subclass}.  A subclass is a specialized
version of a subclass.  It inherits all of the members defined by the
superclass and adds its own, unique elements.


@c -----------------------------------------------------------------------------

@node Inheritance Basics
@section Inheritance Basics
@cindex inheritance basics
@cindex keyword @code{extends}
@cindex @code{extends} keyword

To @emph{inherit} a class, incorporate the definition of one class into
another by using the @code{extends} keyword.

@example
class A @{@dots{}@}
class B extends A @{@dots{}@}
@end example

A subclass will include all of the members of its superclass.  The subclass
can directly reference all of the members of the superclass as well.
Subclasses can be superclasses of other subclasses.

@heading General Form of a Subclass Inheriting a Superclass

@float GeneralForm,Subclass
@display
class @ii{subclass-name} extends @ii{superclass-name} @{
  @ii{body of class}
@}
@end display
@caption{Subclass General Form}
@end float

A subclass can have only one superclass.  Java does not support the
inheritance of multiple superclasses into a single subclass.

@c ....................................

@node Member Access and Inheritance
@subsection Member Access and Inheritance
@cindex inheritance, member access
@cindex member access, inheritance
@cindex @code{private} and inheritance

Although a subclass includes all of the members of its superclass, it cannot
access those members of the superclass that have been declared as
@code{private}.  A class member that has been declared as @code{private} will
remain private to its class.  It is not accessible by any code outside its
class, including subclasses.

A major advantage of inheritance is that once you have created a superclass
that defines the attributes commoin to a set of objects, it can be used to
create any number of more specific subclasses.  Each subclass can precisely
tailor its own classification.

@c ....................................

@node Superclass Referencing Subclass
@subsection A Superclass Variable Can Reference a Subclass Object
@cindex superclass referencing subclass
@cindex reference variable, superclass

A reference variable of a superclass can be assigned a reference to any
subclass derived from that superclass.  

It is important to understand that itis the @emph{type of the reference
variable} --- not the type of the object that it refers to --- that
determines what members can be accessed.  That is, when a reference to a
subclass object is assigned to a superclass reference variable, you will have
access @emph{only} to those parts of the object defined by the superclass.
The superclass has no knowledge of what a subclass adds to it.


@c *****************************************************************************

@node Using super
@section Using @code{super}
@cindex @code{super}, using

Whenever a subclass needs to refer to its immediate superclass, it can do so
by use of the keyword @code{super}.  @code{super} has two general forms.  The
first calls the superclass' constructor.  The second is used to access a
member of the superclass that has been hidden by a member of a subclass.

@c .....................................

@node super Calling Superclass Constructor
@subsection Using @code{super} to Call Superclass Constructors
@cindex @code{super} calling superclass constructors

A subclass can call a constructor defined by its superclass by use of the
following form of @code{super}:

@float GeneralForm,SuperCallingConstructor
@display
super(@ii{arg-list});
@end display
@caption{@code{super} Calling a Constructor}
@end float

@ii{arg-list} specifies any arguments needed by the constructor in the
superclass.  @code{super()} must always be the first statement executed
inside a subclass' constructor.  @code{super()} can be called using any form
defined by the superclass.

@c .....................................

@node super Referencing Superclass
@subsection @code{super} Referencing Superclass
@cindex @code{super} referencing superclass
@cindex member hiding

The second form of @code{super} acts somewhat like @code{this}, except that
it always refers to the superclass of the subclass in which it is used.

@float GeneralForm,SuperReferencingSuperclass
@display
super.@ii{member}
@end display
@caption{@code{super} Referencing its Superclass}
@end float

@ii{member} can be either a method or an instance variable.  This form of
@code{super} is most applicable to situations in which member names of a
subclass hide members by the same name in the superclass.

@example
i = super.i;
@end example

@code{super} allows access to the @code{i} defined in the superclass.
@code{super} can also be used to call methods that are hidden by a subclass.


@c -----------------------------------------------------------------------------

@node Multilevel Hierarchy
@section Creating a Multilevel Hierarchy
@cindex multilevel hierarchy
@cindex hierarchy, multilevel, creating
@cindex hierarchy, files

You can build hierarchies that contain as many layers of inheritance as you
like.  It is acceptable to use a subclass as a superclass of another.  Each
subclass inherits all of the traits found in all of its superclasses.

@code{super} always refers to the constructor in the closest superclass.

While an entire class hierarchy can be created in a single file, the
individual classes (superclasses and subclasses) can be placed into their own
files and compiled separately.  Using separate files is the norm, not the
exception, in creating class hierarchies.


@c -----------------------------------------------------------------------------

@node Constructors Executed
@section When Constructors are Executed
@cindex hierarchy, constructors executed

In a class hierarchy, constructors complete their execution in order of
derivation, from superclass to subclass.


@c -----------------------------------------------------------------------------

@node Method Overriding
@section Method Overriding
@cindex method overriding
@cindex overriding, method
@cindex overload versus override

In a class hierarchy, when a method in a subclass has the same name and type
signature as a method in its superclass, then the method in the subclass is
said to @dfn{override} the method in the superclass.  When an overriden
method is called from within its subclass, it will always refer to the
version of that method defined by the subclass.  The version of the method
defined by the superclass will be hidden.

If you wish to access the superclass version of an overridden method, you can
do so by using @code{super}.

Method overriding occurs @emph{only} when the names and the type signatures
of the two methods are identical.  If they are not, then the two methods are
simply overloaded (no name hiding takes place).


@c -----------------------------------------------------------------------------

@node Dynamic Method Dispatch
@section Dynamic Method Dispatch
@cindex dynamic method dispatch
@cindex polymorphism, run-time

Method overriding forms the basis for one of Java's most powerful concepts:
@dfn{dynamic method dispatch}.  This is a meachanism by which a call to an
overridden method is resolved at run time, rather than compile time.  This is
important because this is how Java implements run-time polymorphism.

A superclass reference variable can refer to a subclass object.  Java
uses this fact to resolve calls to overridden methods at run time.
When an overridden method is called through a superclass reference,
Java determines which version of that method to execute based upon the
type of the object being referred to at the time the call occurs.
Thus, this determination is made at run time.  When different types of
objects are referred to, different versions of an overridden method
will be called.  In other words, @emph{it is the type of the object
being referred to} (not the type of the reference variable) that
determines which version of an overridden method will be executed.
Therefore, if a superclass contains a method that is overridden by a
subclass, then when different types of objects are referred to through
a superclass reference variable, different versions of the method are
executed.

@c .....................................

@node Why Overridden Methods
@subsection Why Overridden Methods?
@cindex polymorphism, dynamic run-time
@cindex one interface, many methods polymorphism

Overridden methods allow Java to support run-time polymorphism.  Polymorphism
is essential to object-oriented programming for one reason: it allows a
general class to specify methods that will be common to all of its
derivatives, while allowing subclasses to define the specific implementation
of some or all of those methods.  Overridden methods are another way that
Java implements the ``one interface, multiple methods'' aspect of
polymorphism.

Successfully applying polymorphism is understanding that the superclasses and
subclasses form a hierarchy which moves from lesser to greater
specialization.  Used correctly, the superclass provides all elements that a
subclass can use directly.  It also defines those methods that the derived
class must implement on its own.  This allows the subclass the flexibility to
define its own methods, yet still enforces a consistent interface.  Thus, by
combining inheritance with overridden methods, a superclass can define the
general form of the methods that will be used by all of its subclasses.

Dynamic, run-time polymorphism is one of the most powerful mechanisms that
object-oriented design brings to bear on code reuse and robustness.  The
ability of existing code libraries to call methods on instances of new
classes without recompiling while maintaining a clean abstract interface is a
profoundly powerful tool.

@c .....................................

@node Applying Method Overriding
@subsection Applying
@pindex @file{FindAreas.java}

Let's look at a practical example that uses method overriding.  The following
program creates a superclass called @code{Figure} that stores the dimensions
of a two-dimensional object.  It also defines a method called @code{area()}
that computes the area of an object.  The program derives two subclasses from
@code{Figure}.  The first is @code{Rectangle} and the second is
@code{Triangle}.  Each of these subclasses overrides @code{area()} so that it
returns the area of a rectangle and a triangle respectively.

@(FindAreas.java @)=
@<FindAreas SuperClass Figure @>
@<FindAreas SubClass Rectangle @>
@<FindAreas SubClass Triangle @>
@<FindAreas Main Class @>

@

@subsubheading Output

The output from the program should be:

@example
Inside Area for Rectangle.
Area is 45
Inside Area for Triangle.
Area is 40
Area for Figure is undefined.
Area is 0
@end example

Through the dual mechanisms of inheritance and run-time polymorphism, it is
possible to define one consistent interface that is used by several
different, yet related, types of objects.  In this case, if an object is
derived from @code{Figure}, then its area can be obtained by calling
@code{area()}. The interface to this operation is the same no matter what
type is being used.

@c .....................................

@node FindAreas SuperClass Figure Node
@subsubsection FindAreas Superclass Figure Section

@<FindAreas SuperClass Figure @>=
class Figure {
  @<Figure Instance Variable Declarations @>
  @<Figure Constructor @>
  @<Figure Area Method Declaration @>
}

@

@subsubheading Figure Instance Variable Declarations

@<Figure Instance Variable Declarations @>=
double dim1;
double dim2;

@

@subsubheading Figure Constructor

@<Figure Constructor @>=
Figure (double 1, double b) {
  dim1 = a;
  dim2 = b;
}

@

@subsubheading Figure Area Method Declaration

It will be this method that will be overridden by the two subclasses; while
this method will not produce any output, each of the subclasses will provide
a formula for their own area and output that number, even though the same
method (@code{area()}) is being called in each case from the same variable.

@<Figure Area Method Declaration @>=
double area() {
  System.out.println("Area for Figure is undefined.");
  return 0;
}

@

@c .....................................

@node FindAreas SubClass Rectangle Node
@subsubsection FindAreas SubClass Rectangle Section

@<FindAreas SubClass Rectangle @>=
class Rectangle extends Figure {
  @<Rectangle Constructor @>
  @<Rectangle Area Method Declaration @>
}

@

@subsubheading Rectangle Constructor

@<Rectangle Constructor @>=
Rectangle (double a, double b) {
  super(a, b);
}

@

@subsubheading Rectangle Area Method Declaration

@<Rectangle Area Method Declaration @>=
// override area for rectangle
double area() {
  System.out.println("Inside Area for Rectangle.";
  return dim1 * dim2;
}

@

@c .....................................

@node FindAreas SubClass Triangle Node
@subsubsection FindAreas SubClass Triangle Section

@<FindAreas SubClass Triangle @>=
class Triangle extends Figure {
  @<Triangle Constructor @>
  @<Triangle Area Method Declaration @>
}

@

@subsubheading Triangle Constructor

@<Triangle Constructor @>=
Triangle (double a, double b) {
  super(a, b);
}

@

@subsubheading Triangle Area Method Declaration

@<Triangle Area Method Declaration @>=
// override area for right triangle
double area () {
  System.out.println("Inside Area for Triangle.");
  return dim1 * dim2 / 2;
}

@

@c .....................................


@node FindAreas Main Class Node
@subsubsection FindAreas Main Class Section

@<FindAreas Main Class @>=
class FindAreas {
  @<FindAreas Main Method Declaration @>
}

@

@subsubheading FindAreas Main Method Declaration

@<FindAreas Main Method Declaration @>=
public static void main (String[] args[]) {
  @<Create Basic Figure Objects @>
  @<Create Basic Figure Reference Variable @>
  @<Call Overridden Methods One By One @>
}

@

@subsubheading Create Basic Figure Objects

@<Create Basic Figure Objects @>=
Figure f = new Figure(10, 10);
Rectangle r = new Rectangle(9, 5);
Triangle t = new Triangle(10, 8);

@

@subsubheading Create Basic Figure Reference Variable

This superclass reference variable @code{Figure figref} will hold,
alternately, references to each of the classes and will call the method
@code{area()} on each, producing a different result each time.  This is the
essence of method overriding and dynamic method dispatch.

@<Create Basic Figure Reference Variable @>=
Figure figref;

@

@subsubheading Call Overridden Methods One By One

@<Call Overridden Methods One By One @>=
figref = r;
System.out.println("Area is " + figref.area());

figref = t;
System.out.println("Area is " + figref.area());

figref = f;
System.out.println("Area is " + figref.area());

@


@c -----------------------------------------------------------------------------

@node Using Abstract Classes
@section Using Abstract Classes
@cindex abstract class, inheritance
@cindex abstract method
@cindex @code{abstract} type modifier

There are situations in which you will want to define a superclass that
declares the structure of a given abstraction without providing a complete
implementation of every method.  That is, sometimes you will wnat to create a
superclass that only defines a generalized form that will be shared by all of
its subclasses, leaving it to each subclass to fill in the details.  Such a
class determines the nature of the methods that the subclasses must
implement.  One way this situation can occur is when a superclass is unable
to create a meaningful implementation for a method.  This is the case with
@code{Figure} in the preceding example.  The definition of @code{area()} is
simply a placeholder.  It will not compute and display the area of any type
of object.

It is not uncommon for a method to have no meaningful definition in the
context of its superclass.  Java's solution to this problem is the
@dfn{abstract method}.

You can require that certain methods be overridden by subclasses by
specifying the @code{abstract} type modifier.  These methods are sometimes
referred to as @dfn{subclasser responsibility} because they have no
implementation specified in the superclass.  Thus, a subclass must override
them --- it cannot simply use the version defined in the superclass.

To declare an abstract method, use the general form:

@float GeneralForm,AbstractMethodDeclaration
@display
abstract @ii{type} @ii{name} (@ii{parameter-list});
@end display
@caption{Abstract Method Declaration---General Form}
@end float

@noindent No method body is present.

Any class that contains one or more abstract methods must also be declared
abstract.  To declare a class abstract, simply use the @code{abstract}
keyword in front of the @code{class} keyword at the beginning of the class
declaration.  There can be no objects of an abstract class.  That is, an
abstract class cannot be directlyi instantiated with the @code{new}
operator.  You cannot declare abstract constructors or abstract static
methods.  Any subclass of an abstract class must either implement all of the
abstract methods in the superclass, or be declared @code{abstract} itself.
Abstract classes can include fully implemented methods.

@heading Abstract Classes Can Be Reference Variables
@cindex run-time polymorphism, abstract class

Although abstract classes cannot be used to instantiate objects, they can be
used to create object references, because Java's approach to run-time
polymorphism is implemented thruogh the use of superclass references.  Thus,
it must be possible to create a reference to an asbtract class so that it can
be used to point to a subclass object.  

@c .....................................

@node Improved Figure Class
@subsection Improved Figure Class
@pindex @file{AbstractAreas.java}

Using the abstract class, you can improve the @code{Figure} class.  Since
there is no meaningful concept of area for an undefined two-dimensional
figure, the following version of the program declares @code{area()} as
abstract inside @code{Figure}.  This means that all classes derived from
@code{Figure} must override @code{area()}.

@(AbstractAreas.java @)=
@<AbstractAreas Abstract Class Figure @>
@<FindAreas SubClass Rectangle @>
@<FindAreas SubClass Triangle @>
@<AbstractAreas Main Class @>

@

@c _____________________________________

@node AbstractAreas Abstract Class Figure Node
@subsubsection AbstractAreas Abstract Class Figure Section

Notice that much of this class stays the same as the original @code{Figure}
code, but includes two @code{abstract} declarations, one for the class, and
one for the @code{area()} method declaration.

@<AbstractAreas Abstract Class Figure @>=
abstract class Figure {
  @<Figure Instance Variable Declarations @>
  @<Figure Constructor @>
  @<AbstractAreas Abstract Area Method Declaration @>
}

@

@subsubheading AbstractAreas Abstract Area Method Declaration

@<AbstractAreas Abstract Area Method Declaration @>=
// areas is now an abstract method
abstract double area ();

@

@c .....................................

@node AbstractAreas Main Class
@subsubsection Abstract Main Class

@<AbstractAreas Main Class @>=
class AbstractAreas {
  @<AbstractAreas Main Method Declaration @>
}

@

@subsubheading AbstractAreas Main Method Declaration

@<AbstractAreas Main Method Declaration @>=
public static void main (String[] args) {
  @<Create Basic Figure Objects Except Figure @>
  @<Create Basic Figure Reference Variable @>
  @<Call Overridden Methods One By One Except Figure @>
}

@

@subsubheading Create Basic Figure Objects Except Figure

The only difference here is that because the superclass Figure is now
abstract, it cannot be instantiated using @code{new}.  It can, however, be
used as a reference variable, and so the declaration @kbd{Figure figref;} is
still valid and does not change from the prior implementation.  @strong{This
is the essence of run-time polymorphism and dynamic method dispatch.}

@<Create Basic Figure Objects Except Figure @>=
// abstract class Figure cannot be instantiated
// Figure f = new Figure (10, 10);
Rectangle r = new Rectangle (9, 5);
Triangle t = new Triangle (10, 8);

@

@subsubheading Call Overridden Methods One By One Except Figure

The only difference here is that, because there is no @code{Figure} object,
it cannot be referenced.

@<Call Overridden Methods One By One Except Figure @>=
figref = r;
System.out.println("Area is " + figref.area());

figref = t;
System.out.println("Area is " + figref.aread());

// there is no Figure object, so this will not work.
// figref = f;

@


@c -----------------------------------------------------------------------------

@node final with Inheritance
@section Using @code{final} with Inheritance
@cindex @code{final} with inheritance

The keyword @code{final} has three uses.

@enumerate
@item
create the equivalent of a name constant.
@item
prevent overriding
@item
prevent inheritance
@end enumerate

@c .....................................

@node final to Prevent Overriding
@subsection Using @code{final} to Prevent Overriding
@cindex @code{final} to prevent overriding
@cindex inline, inlining
@cindex late binding
@cindex early binding
@cindex binding, late, early
@cindex performance enhancement, inlining

There will be times when you want to prevent overriding from occurring.  To
disallow a method from being overridden, specify @code{final} as a modifier
at the start of its declaration.  Methods declared as @code{final} cannot be
overridden.

Methods declared as @code{final} can sometimes provide a performance
enhancement.  The compiler is free to @dfn{inline} calls to them because it
knows they will not be overridden by a subclass.  Inlining is an option only
with @code{final} methods.  Normally, Java resolves calls to methods
dynamically, at run time.  This is called @dfn{late binding}.  However, since
@code{final} methods cannot be overridden, a call to one can be resolved at
compile time.  This is called @dfn{early binding}.

@c .....................................

@node final to Prevent Inheritance
@subsection Using @code{final} to Prevent Inheritance
@cindex @code{final} to prevent inheritance

Sometimes you will want to prevent a class from being inherited.  To do this,
precede the class declaration with @code{final}.  Declaring a class as
@code{final} implicitly declares all of its methods as @code{final} also.


@c -----------------------------------------------------------------------------

@node Object Class
@section The Object Class
@cindex Object class

There is one special class, @code{Object}, defined by Java.  All other
classes are subclasses of @code{Object}.  That is, @code{Object} is a
superclass of all other classes.  This means that a reference variable of
type @code{Object} can refer to an object of any other class.  Also, since
arrays are implemented as classes, a variable of type @code{Object} can also
refer to any array.

@heading @code{Object} Methods

@code{Object} defines the following methods; this means they are available in
every object.

@ftable @code
@item Object clone()
Creates a new object that is the same as the object being cloned.
@item boolean equals(Object @slanted{object})
Determines whether one object is equal to another.
@item void finalize()
Called before an unused object is recycled.  (Deprecated by JDK 9).
@item Class<?> getClass()
Obtains the class of an object at run time.
@item int hashCode()
Returns the hash code associated with the invoking object.
@item void notify()
Resumes execution of a thread waiting on the invoking object.
@item void notifyAll()
Resumes execution of all threads waiting on the invoking object.
@item String toString()
Returns a string that describes the object.
@item void wait()
@itemx void wait(long @slanted{milliseconds})
@itemx void wait(long @slanted{millisconds}, int @slanted{nanoseconds})
Waits on another thread of execution
@end ftable

The methods
@itemize
@item
@code{getClass()}
@item
@code{notify()}
@item
@code{notifyAll()}
@item
@code{wait()}
@end itemize

@noindent are declared as @code{final}.  You may override the others.

However, notice two methods now:
@cindex @code{equals()}
@cindex @code{toString()}

@table @code
@item equals()
compares two objects; returns @code{true} if the objects are equal, and
@code{false} if not; the precise definition of equality can vary, depending
on the type of objects being compared.
@item toString()
returns a string that contains a description of the object on which it is
called; this method is automatically called when an object is output using
@code{println()}; many classes override this method; doing so allows them to
tailor a description specifically for the types of objects that they create.
@end table





@c *****************************************************************************

@node Packages
@chapter Packages
@cindex Packages (chapter)
@cindex containers, packages as
@cindex compartmentalized
@cindex class namespace, compartmentalize
@cindex packages, purposes, prevent collisions
@cindex collisions, prevention
@cindex packages, how stored
@cindex packages, import
@cindex import packages
@cindex hierarchical structure, packages

@ii{Packages} are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file names.
Packages are stored in a hierarchical manner and are explicitly imported into
new class definitions.


@c -----------------------------------------------------------------------------

@node Packages Intro
@section Introduction to Packages
@cindex Introduction to Packages (section)
@cindex partitioning mechanism
@cindex naming mechanism
@cindex visibility mechanism
@cindex accessibility
@cindex exposure of code

Java provides a mechanism for partitioning the class namespace into
manageble chunks: the @dfn{PACKAGE}.  The package is both a naming and
a visibility control mechanism.  In other words, you can use the
package mechanism to define classes inside a package that are not
accessible by code outside the package; and you can define class
members that are exposed only to other members of the same package.

@c -----------------------------------------------------------------------------

@node Defining Packages
@section Defining Packages
@cindex Packages, Defining (section)
@cindex @command{package} command
@cindex default package
@cindex package statement
@cindex package namespace

To create a package (``define'' a package), include the
@command{package} command as the first statement in a Java source
file.  Thereafter, any classes declared within that file will belong
to the specified package.  The @command{package} statement defines a
namespace in which classes are stored.  Without the @command{package}
statement, classes are put into the @file{default} package (which has
no name).

@subheading General Form of @command{package} statement
@cindex package statement, general form

@float GeneralForm,PackageStatement
@display
package @ii{pkg}
@end display
@caption{Package Statement --- General Form}
@end float

@ii{pkg} is the name of the package.  For example:
@cindex package statement, example

@example
package mypackage;
@end example

@subheading File System Directories
@cindex packages stored in file system

Java uses the file system directories to store packages.  Therefore, the
@code{.class} files for any classes you declare to be part of
@code{mypackage} must be stored in a directory called @code{mypackage}.  The
directory name must match the package name exactly.

More than one file can include the same @command{package} statement.  The
@command{package} statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other files
from being part of that same package.  Most real-world packages are spread
across many files.

@subheading Hierarchy of Packages
@cindex packages hierarchy
@cindex hierarchy of packages

You can create a hierarch of packages.  To do so, separate each package name
form the one above it by use of a period.  The general form of a multileveled
package statement is:
@cindex package statement, multilevel form

@float GeneralForm,PackageStatementMulti
@display
package @ii{pkg1[.pkg2[.pkg3]]}
@end display
@caption{Package Statement --- Multilevel Form}
@end float

A package hierarchy must be reflected in the file system of your Java
development system.  For example a package declared as:

@example
package a.b.c;
@end example

needs to be stored in directory @file{a/b/c}.

@cindex package renaming
Be sure to choose package names carefully; you cannot rename a package
without renaming the directory in which the classes are stored.


@c -----------------------------------------------------------------------------

@node Classpath
@section Finding Packages and CLASSPATH
@cindex @env{CLASSPATH} @option{-classpath}
@cindex finding packages
@cindex run-time system, finding packages
@cindex modules, packages
@cindex module path
@cindex JDK 9, package part of module

Packages are mirrored by directories.  How does the Java run-time system know
where to look for packages?

@table @b
@item @samp{cwd}
By default, the Java run-time system uses the currect working directory as
its starting point.  Thus, if your package is in a subdirectory of the
current directory, it will be found.
@item @env{CLASSPATH}
You can specify a directory path or paths by setting the @env{CLASSPATH}
environment variable.
@item @option{-classpath}
You can use the @option{-classpath} option with @command{java} and
@command{javac} to specify the path to your classes.
@item module path
Beginning with JDK 9, a package can be part of a module, and thus found on
the @file{module path}.
@end table

@subheading Example Finding a Package
@cindex packages, finding, example

Consider the following package specification:

@example
package mypack;
@end example

In order for programs to find @code{mypack}, the program can be executed from
a directory @strong{immediadely above} @code{mypack}, or the @env{CLASSPATH}
must be set to include the path to @code{mypack} or the @option{-classpath}
option must specify the path to @code{mypack} when the program is run via
@command{java}.

When the second or third of the above options is used, the @file{class
path} @strong{must not include} @file{mypack} itself.  It must simply
specify the @file{path} to just above @file{mypack}.  For example, if
the path to @file{mypack} is

@example
/MyPrograms/Java/mypack
@end example

then the class path to @code{mypack} is

@example
/MyPrograms/Java
@end example


@c -----------------------------------------------------------------------------

@node Member Access
@section Packages and Member Access
@cindex access control, packages
@cindex packages, access control
@cindex member access
@cindex access, member

Packages add another dimension to access control.  Classes and packages are
both means of encapsulating and containing the name space and scope of
variables and methods.  @emph{Packages} act as containiners for classes and
other subordinate packages.  @emph{Classes} act as containers for data and
code.  The class is Java's smallest unit of abstraction.  As it relates to
the interplay between classes and packages, Java addresses four categories of
visibility for class members:

@itemize
@item
Subclasses in the same package
@item
Non-subclasses in the same package
@item
Subclasses in different packages
@item
Classes that are neither in the same package nor subclasses
@end itemize

The three access modifiers

@itemize
@item
private
@item
public
@item
protected
@end itemize

provide a variaty of ways to produce many levels of access required by these
categories.
@cindex access control table

@float Table,PackageAccess
@multitable @columnfractions .4 .15 .15 .15 .15
@headitem Category @tab Private @tab None @tab Protected @tab public
@item
Same Class @tab Yes @tab Yes @tab Yes @tab Yes
@item
Same package subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Same package non-subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Different package subclass @tab No @tab No @tab Yes @tab Yes
@item
Different package noni-subclass @tab No @tab No @tab No @tab Yes
@end multitable
@caption {Package Access Table --- Shows all combinations of the access
control modifiers}
@shortcaption{Package Access Table}
@end float


@c -----------------------------------------------------------------------------

@node Importing
@section Importing Packages
@cindex packages, importing
@cindex importing packages

Java includes the @command{import} statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be referred to
directly, using only its name.  The @command{import} statement is a
convenience to the programmer and is not technically needed to write a
complete Java program.

In a Java source file, @command{import} statements occur immediately
following the @command{package} statement (if one exists) and before any
class definitions.  This is the general form of the @command{import}
statement:
@cindex import statement, general form and example

@float GeneralForm,Import
@display
import @ii{pkg1}[.@ii{pkg2}].(@ii{classname} | *);
@end display
@caption{Import Statement --- General Form}
@end float

Here, @ii{pkg1} is the name of a top-level package, and @ii{pkg2} is the name
of a subordinate package inside the outerpackage separated by a dot
(@t{.}).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit @file{classname} or a star (@t{*}), which
indicates that the Java compiler should import the entire package.

@example
import java.util.Date;
imort java.io.*;
@end example

@cindex standard Java classes, imported implicitly
@cindex @file{java.lang}
All of the standard Java SE classes included with Java begin with the name
@file{java}.  The basic language functions are stored in a package called
@file{java.lang}.  Normally, you have to import every package or class that
you want to use, but since Java is useless without much of the functionality
in @file{java.lang}, it is implicitly imported by the compiler for all
programs.  This is equivalent to the following line being at the top of all
your programs:

@example
import java.lang.*;
@end example

@cindex import is optional
@cindex fully qualified name
The @command{import} statement is @emph{optional}.  Any place you use a class
name, you can use its @emph{fully qualified name}, which includes its full
package hierarchy.

@cindex imported packages must be public
When a package is imported, only those items within the package declared as
@command{public} will be available to non-subclasses in the importing code.




@c *****************************************************************************

@node Interfaces
@chapter Interfaces
@cindex Interfaces (chapter)
@cindex interfaces, introduction
@cindex keyword interface
@cindex abstract class
@cindex interface, implement
@cindex polymorphism, one interface multiple methods

Using the keyword @command{interface}, you can fully abstract a class'
interface from its implementation.  That is, using @command{interface}, you
can specify what a class must do, but not how to do it.  Interfaces are
syntactically similar to classes, but they lack instance variables, and, as a
general rule, their methods are declared without any body.  Once it is
defined, any number of classes can implement an @command{interface}.  Also,
one class can implement any number of interfaces.  To implement an interfce,
a class must provide the complete set of methods required by the interface.
Each class is free to determine the details of its own implementation.  By
providing the @command{interface} keyword, Java allws you to fully utilize
the ``one interface, multiple methods'' aspect of polymorphism.

@cindex dynamic method resolution
@cindex run-time
@cindex compile time
@cindex method signatures compatible
@cindex static environment
Interfaces are designed to support @dfn{dynamic method resolution} at run
time.  Normally, in order for a method to be called from one class to
another, both classes need to be present at compile time so the Java compiler
can check to ensure that the method signatures are compatible.  This
requirement by itself makes for a static and nonextensible classing
environment.  Inevitably in a system like this, functionality gets pushed up
higher and higher in the class hierarchy so that the mechanisms will be
available to more and more subclasses.  Interfaces are designed to avoid this
problem.  @emph{They disconnect the definition of a method or set of methods
from the inheritance hierarchy.}  Since interfaces are in a different
hierarchy from classes, it is possible for classes that are unrelated in
terms of class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.


@c -----------------------------------------------------------------------------

@node Defining Interfaces
@section Defining Interfaces
@cindex interfaces, defining

An interface is defined much like a class.  Here is a simplified general form
of an interface definition:
@cindex interface definition, simplified general form

@float GeneralForm,InterfaceSimple
@display
@ii{access} interface @ii{name} @{
  @ii{return-type method-name1}(@ii{parameter-list});
  @ii{return-type method-name2}(@ii{parameter-list});

  @ii{type final-varname1} = @ii{value}
  @ii{type final-varname2} = @ii{value}
  @dots{}
  @ii{return-type method-nameN}(@ii{parameter-list});
  @ii{type final-varnameN} = @ii{value}
@}
@end display
@caption{Interface Definition --- Simplified General Form}
@end float

@cindex interface default access, no modified
@cindex interface public access
@cindex abstract methods, interface
@cindex interface methods, abstract methods
When no access modifier is included, then default access results, and the
interface is only available to other members of the package in which it is
declared.  When it is declared as @command{public}, the interface can be used
by code outside its package.  In this case, the interface must be the only
public interface declared in the file, and the file must have the same name
as the interface.  The methods that are declared have no bodies.  They end
with a semicolon after the parameter list.  They are, essentially, abstract
methods.  Each class that includes such an interface must implement all of
the methods.

@subheading Variable Declarations inside Interfaces
@cindex interface variable declarations

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly @command{final} and @command{static},
meaning they cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly @command{public}.

@node Implementing Interfaces
@section Implementing Interfaces
@cindex interfaces, implementing
@cindex @command{implements} clause

Once an interface has been defined, one or more classes can implement that
interface.  To implement an interface, include the @command{implements}
clause in a class definition, and then create the methods required by the
interface.  The general form of a class that includes the
@command{implements} clause looks like this:

@float GeneralForm,ClassImplementsInterface
@display
class @ii{clasname} [extends @ii{superclass}] [implements @ii{interface} [,@ii{interface}@dots{}] @{
  @ii{class-body}
@}
@end display
@caption{Class Implementing Interface --- General Form}
@end float

@cindex interface method defintion, declared @command{public}
The methods that implement an interface must be declared @command{public}.
The type signature of the implementing method must match exactly the type
signature specified in the @command{interface} definition.

It is both permissible and common for classes that implement interfaces to
define additional members of their own.


@c -----------------------------------------------------------------------------

@node Interface References
@section Accessing Implementations Through Interface References
@cindex interface references, accessing implementations
@cindex object references, interfaces
@cindex interfaces, key feature, reference look-ups
@cindex dynamic dispatch, interface method look-ups
@cindex dispatch through an interface

You can declare variables as object references that use an interface rather
than a class type.  Any instance of any class that implements the declared
interface can be referred to by such a variable.  When you call a method
through one of these references, the correct version will be called based on
the actual instance of the interface being referred to.  This is one of the
key features of interfaces.  The method to be executed is looked up
dynamically at run-time, allowing classes to be created later than the code
which calls methods on them.  The calling code can dispatch through an
interface without having to know anything about the ``callee.''  This process
is similar to using a superclass reference to access a subclass object.


@c -----------------------------------------------------------------------------

@node Partial Implementations
@section Partial Implementations
@cindex interface, partial implementation

If a class includes an interface but does not implement the methds required
by that interface, then that class must be declared as @command{abstract}.
Any class that inherits the abstract class must implement the interface or be
declared @command{abstract} itself.


@c -----------------------------------------------------------------------------

@node Nested Interfaces
@section Nested Interfaces
@cindex interfaces, nested
@cindex nested interfaces
@cindex member interfaces

An interface can be declared a member of a class or another interface.  Such
an interface is called a @dfn{member interface} or a @dfn{nested interface}.
A nested interface can be declared as @command{public}, @command{private}, or
@command{protected}.  This differs from a top-level interface, which must
either be declared as @command{public} or use the default access level.  When
a nexted interface is used outside of its enclosing scope, it must be
qualified by the name of the class or interface of which it is a member.
Thus, outside of the class or interface in which a nested interface is
declared, its name must be fully qualified.


@c -----------------------------------------------------------------------------

@node Applying Interfaces
@section Applying Interfaces
@cindex intefaces, applying

See detailed example @dots{}


@c -----------------------------------------------------------------------------

@node Variables in Interfaces
@section Variables in Interfaces
@cindex interfaces, final variables in
@cindex interfaces, shared constants

You can use interfaces to import shared constants into multiple classes by
simply declaring an interface that contains variables that are initialized to
the desired values.  When you include that interface in a class (when you
``implement'' the interface), all of those variable names will be in scope as
constants.  If an interface contains no methods, then any class that includes
such an interface doesn't actually implement anything.  It is as if that
class were importing this constant fields into the class name space as
@command{final} variables.


@c -----------------------------------------------------------------------------

@node Extending Interfaces
@section Interfaces Can Be Extended
@cindex interfaces, extending
@cindex interfaces, inheriting
@cindex @command{extents}, with interfaces
@cindex extending interfaces
@cindex inheriting interfaces

One interface can inherit another by use of the keyword @command{extends}.
The syntax is the same as for inheriting classes.  When a class implements an
interface that inherits another interface, it must provide implementations
for all methods required by the interface inheritance chain.


@c -----------------------------------------------------------------------------

@node Default Interface Methods
@section Default Interface Methods
@cindex index interface, default methods
@cindex default methods, interface
@cindex abstract methods, interface
@cindex interface, traditional form
@cindex JDK 8, default method in interface

Prior to JDK 8, an interface could not define any implementation whatsoever.
This meant that for all previous versions of Java, the methods specified by
an interface were abstract, constaining no body.  This is the traditional
form of an interface.  The release of JDK 8 changed this by adding a new
capability to @command{interface} called the @dfn{default method}.  A default
method lets you define a default implementation for an interface method.  It
is possible for an interface method to provide a body, rather than being
abstract.

@cindex default method, interface, motivation
@cindex preexisting code, default method, interface
A primary motivation for the default method was to provide a means by which
interfaces could be expanded without breaking existing code.  There must be
implementations for all methods defined by an interface.  If a new method
were added to a popular, widely used interface, then the addition of that
method would break existing code because no implementation would be found for
that new method.  The default method solves this problem by supplying an
implementation that willbe used if no other implementation is explicitly
provided.  Thus, the addition of a default method will not cause preexisting
code to break.

Another motivation for the default method was the desire to specify methods
in an interface that are, essentially, optional, depending on how the
interface is used.

@subheading Interfaces Do No Maintain State and Cannot Be Created
@cindex interfaces, key aspect, no state
@cindex difference between class and interface

It is important to point out that the addition of default methods does not
change a key aspect of @command{interface}: its inability to maintain state
information.  An interface still cannot have instance variables, for example.
Thus, @strong{the defining difference between an interface and a class is
that a class can maintain state information, but an interface cannot.}
Furthermore, it is still not possible to create an instance of an interface
by itself.  It must be implemented by a class.


@c -----------------------------------------------------------------------------

@node Interface Static Methods
@section Use Static Methods in an Interface
@cindex interface, static method
@cindex static method, interface
@cindex method, static, interface
@cindex JDK 8, static interface method

Another capability added to interface by JDK 8 is the ability to define one
or more @command{static} methods.  Like @command{static} methods in a class,
a @command{static} method defined by an interface can be called independently
of any object.  Thus, no implementation of the interface is necessary, and no
instance of the interface is required, in order to call a @command{static}
method.  Instead, a @command{static} method is called by specifying the
interface name, followed by a period, followed by the method name.  Here is
the general form:

@float GeneralForm,InterfaceStaticMethod
@display
@ii{InterfaceName.staticMethodName}
@end display
@caption{Interface Static Method, Calling}
@end float

Notice that this is similar to the way that a @command{static} method in a
class is called.  However, @command{static} interface methods are not
inherited by either an implementing class or a subinterface.


@c -----------------------------------------------------------------------------

@node Private Interface Methods
@section Private Interface Methods
@cindex interface methods, private
@cindex JDK 9, private interface method

Beginning with JDK 9, an interface can include a private method.  A private
interface method can be called only by a default method or another private
method defined by the same interface.  Because a private interface method is
specified @command{private}, it cannot be used by code outside the interface
in which it is defined.  This restriction includes subinterfaces because a
private inteface method is not inherited by a subinterface.

The key benefit of a private interface method is that it lets two or more
default methods use a common piece of code, thus avoiding code duplication.




@c *****************************************************************************

@node I/O
@chapter I/O
@cindex I/O
@cindex @file{java.io}
@cindex input/output system
@cindex @code{try-with-resources}

This chapter introduces @file{java.io}, which supports Java's basic
input/output system, including file I/O.  Support for I/O comes from Java's
core API libraries, not from language keywords.  In this chapter the
foundation of this subsystem is introduced so that you can see how it fits
into the larger context of the Java programming and execution environment.
This chapter also looks at the @code{try-with-resources} statement.

@c -----------------------------------------------------------------------------

@node I/O Basics
@section I/O Basics
@cindex I/O Basics
@cindex text-based console programs
@cindex console I/O

Most real applications of Java are not text-based, console programs.  Rather,
they are either graphically oriented programs that rely on one of Java's
graphical user interface (GUI) frameworks, such as Swing, the AWT, or JavaFX,
for user interaction, or they are Web applications.  Text-based console
programs do not constitute an important use for Java in the real world.
Java's support for console I/O is limited and somewhat awkword to use.
Text-based console I/O is just not that useful in real-world Java
programming.

Java does, however, provide strong, flexible support for I/O as it relates to
files and networks.  Java's I/O system is cohesive and consistent.  A general
overview of I/O is presented here.  A detailed description is found in
chapters describing the Java Library: @xref{java.io --- Input/Output} and
@xref{java.nio --- NIO}.


@c .....................................

@node Streams
@subsection Streams
@cindex Streams
@cindex stream definition
@cindex Java I/O system
@cindex stream, input
@cindex stream, output
@cindex input stream
@cindex output stream
@cindex @file{java.io} package
@cindex package, @file{java.io}

Java programs perform I/O through streams.  A @dfn{stream} is an abstraction
that either produces or consumes information.  A stream is linked to a
physical device by the Java I/O system.  All streams behave in the same
manner, even if the actual physical device to which they are linked differ.
Thus, the same I/O classes and methods can be applied to different types of
devices.  This means that an input stream can abstract many different kinds
of input; from a disk file, a keyboard, or a network socket.  Likewise, an
output stream may refer to the console, a disk file, or a network
connection.  Java implements streams within class hierarchies defined in the
@file{java.io} package.

@c .....................................

@node Byte Streams Character Streams
@subsection Byte Streams and Character Streams
@cindex Byte Streams, definition
@cindex Character Streams, definition
@cindex Streams, Character
@cindex binary data, reading and writing
@cindex Unicode
@cindex internationalization, character streams

Java defines two types of streams:

@itemize
@item
byte streams
@item
character streams
@end itemize


@dfn{Byte streams} provide a convenient means for handling input and output
of bytes.  Byte streams are used when reading or writing binary data.
@dfn{Character streams} provide a convenient means for handling input  and
output of characters.  They use Unicode and therefore can be
internationalized.  In some cases, character streams are more efficient than
byte streams.

The original version of Java (Java 1.0) did not include character streams and
thus all I/O was byte-oriented.  Character streams were added by Java 1.1 and
certain byte-oriented classes and methods were deprecated.

At the lowest level, all I/O is still byte-oriented.  The character-based
streams simply provide a convenient and efficient means for handling
characters.  

@c _____________________________________

@node Byte Stream Class
@subsubsection The Byte Stream Class
@cindex Byte Stream Class
@cindex Stream Class, Byte

Byte streams are defined by using two class hierarchies.  At the top are two
abstract classes:

@itemize
@item
@file{InputStream}
@item
@file{OutputStream}
@end itemize

Each of these abstract classes has several concrete subclasses that handle
the differences among various devices, such as disk files, network
connnections, and memory buffers.  The byte stream classes in @file{java.io}
are shown in @ref{ByteStreamClasses}.

To use the stream classes, you must import @file{java.io}.

@float Table,ByteStreamClasses
@table @file
@item BufferedInputStream
@itemx BufferedOutputStream
Buffered input and output streams
@item ByteArrayInputStream
@itemx ByteArrayOutputStream
Input and Output streams that read from and write to a byte array
@item DataInputStream
@itemx DataOutputStream
Input and Output streams that contain methods for reading and writing the
Java standard data types
@item FileInputStream
@itemx FileOutputStream
Input and Output streams that read from and write to a file
@item FilterInputStream
@itemx FilterOutputStream
Implements @file{InputStream} and @file{OutputStream}
@item InputStream
@itemx OutputStream
Abstract classes that describe stream input and output
@item ObjectInputStream
@itemx ObjectOutputStream
Input and Output streams for objects
@item PipedInputStream
@itemx PipedOutputStream
Input and Output pipe
@item PrintStream
Output stream that contains @code{print()} and @code{println()}
@item PushbackInputStream
Input stream that allows bytes to be returned to the input stream
@item SequenceInputStream
Input stream that is a combination of two or more input streams that will be
read sequentially, one after the other
@end table
@caption{The Byte Stream Classes in @file{java.io}}
@end float

The abstract classes @file{InputStream} and @file{OutputStream} define
several key methods that the other stream classes implement.  Two of the most
important are:

@cindex @code{read()}, @file{InputStream} abstract class
@cindex @code{write()}, @file{OutputStream} abstract class

@itemize
@item
@code{read()}
@item
@code{write()}
@end itemize

@noindent which respectively read and write bytes of data.  Each has a form
that is abstract and must be overridden by derived stream classes.

@c _____________________________________

@node Character Stream Class
@subsubsection The Character Stream Class
@cindex Character Stream Class
@cindex Stream Class, Character
@cindex @file{Reader} abstract class
@cindex @file{Writer} abstract class
@cindex Unicode character streams
@cindex @file{java.io}
@cindex Unicode character streams
@cindex character streams, Unicode

Character streams are defined by using two class hierarchies.  At the top are
two abstract classes:

@itemize
@item
@file{Reader}
@item
@file{Writer}.
@end itemize

These abstract classes handle Unicode character streams.  Java has several
concrete subclasses of these.  The character stream classes in @file{java.io}
are shown in @ref{CharacterStreamClasses}.

@float Table,CharacterStreamClasses
@table @file
@item BufferedReader
@itemx BufferedWriter
Buffered input and output character streams
@item CharArrayReader
@itemx CharArrayWriter
Input and Output streams that read and write to and from a character array
@item FileReader
@itemx FileWriter
Input and Output streams that read from and write to a file
@item FilterReader
@itemx FilterWriter
Filtered read and writer
@item InputStreamReader
@itemx OutputStreamWriter
Input and Output streams that translate bytes to characters
@item LineNumberReader
Input stream that counts lines
@item PipedReader
@itemx PipedWriter
Input and Output pipes
@item PrintWriter
Output stream that contains @code{print()} and @code{println()}
@item PushbackReader
Input stream that allows characters to be return to the input stream
@item Reader
@itemx Writer
Abstract clases tha describe character stream input and output
@item StringReader
@itemx StringWriter
Input and output streams that read from and write to a string
@end table
@caption{The Character Stream I/O Classes in @file{java.io}}
@end float

The abstract classes @file{Reader} and @file{Writer} define several key
methods that the other stream classes implement.  Two of the most important
methods are:

@cindex @code{read()}, @file{Reader}
@cindex @code{write()}, @file{Writer}

@itemize
@item
@code{read()}
@item
@code{write()}
@end itemize

@noindent which read and write characters of data, respectively.  Each has a
form that is abstract and must be overridden by derived stream classes.

@c _____________________________________

@node Predefined Streams
@subsubsection The Predefined Streams
@cindex Predefined Streams
@cindex Streams, Predefined
@cindex @file{System} class
@cindex stream variables, predefined
@cindex @code{in}
@cindex @code{out}
@cindex @code{err}

The @file{java.lang} package defines a class called @file{System}, which
encapsulates several aspects of the run-time environment.  System contains
three predefined stream variables:

@enumerate
@item
@code{in} (standard input), an object of type @file{InputStream}
@item
@code{out} (standard output), an object of type @file{PrintStream}
@item
@code{err} (standard error), an object of type @file{PrintStream}
@end enumerate

@noindent These fields are declared as @code{public}, @code{static}, and
@code{final} within @file{System}.  This means that they can be used by any
other part of your program and without reference to a specific @file{System}
object.  While these are all byte streams, they can be wrapped within
character-based streams, if desired.


@c -----------------------------------------------------------------------------

@node Reading Console Input
@section Reading Console Input
@cindex Reading Console Input
@cindex console input, reading
@cindex internationalization, character streams
@cindex character-based stream
@cindex stream, character-based

For commercial applications, the preferred method of reading console input is
to use a character-oriented stream.  This makes your program easier to
internationalize and maintain.

@subheading @code{System.in} Wrapped in @file{BufferedReader}
@cindex @code{System.in}
@cindex @file{BufferedReader}
@cindex @file{Reader} abstract class
@cindex @file{InputStreamReader} concrete subclass
@cindex @file{InputStream}

Console input is accomplished by reading from @code{System.in}  To obtain a
character-based stream that is attached to the console, wrap @code{System.in}
in a @file{BufferedReader} object.  @file{BufferedReader} supports a buffered
input stream.  A commonly-used constructor is:

@display
BufferedReader(Reader @ii{inputReader})
@end display


@noindent Here, @ii{inputReader} is the stream that is linked to the instance
of @file{BufferedReader} that is being created.  @file{Reader} is the
abstract class.  One of its concrete subclasses is @file{InputStreamReader},
which converts bytes to characters.  To obtain a @file{InputStreamReader}
object that is linked to @code{System.in}, use the following constructor:

@display
InputStreamReader(InputStream @ii{inputStream})
@end display

Because @code{System.in} refers to an object of type @file{InputStream}, it
can be used for @ii{inputStream}.  Putting it all together, the following
line of code creates a @file{BufferedReader} that is connected to the
keyboard:

@example
BufferedReader br = new BufferedReader(
  new InputStreamReader(System.in));
@end example

@noindent After this statement executes, @code{br} is a character-based
  stream that is linked to the console through @code{System.in}.  


@c .....................................

@node Reading Characters
@subsection Reading Characters
@cindex characters, reading
@cindex reading characters
@cindex @code{read()}, from @file{BufferedReader}

To read a character from a @file{BufferedReader}, use @code{read()}.  The
version of @code{read()} that we will be using is

@display
int read() throws IOException
@end display

@noindent Each time that @code{read()} is called, it reads a character from
the input stream and returns it as an integer value. @footnote{Note that
@code{System.in} is line buffered by default; this means that no input is
actually passed to the program until the user presses @key{enter}.  This does
not make @code{file} particularly valuable for interactive console input.}
It returns -1 when an attempt is made to read at the end of the stream.  It
can throw an @code{IOException}.

@subsubheading Program Demonstrating Reading Characters from Console
@pindex @file{BRRead.java}

The following program demonstrates @code{read()} by reading characters from
the console until the user types a ``q''.  Any I/O exceptions that might be
generated are simply thrown out of @code{main()}.  In more sophisticated
applications, you can handle the exceptions explicitly.

@(BRRead.java@)=
@<Import java.io@>
class BRRead {
  public static void main(String[] args[]) throws IOException {
    @<BRRead BufferedReader Constructor@>
    @<BRRead Enter Characters@>
  }
}

@

@c _____________________________________

@node Import java.io
@subsubsection Import @file{java.io}
@cindex import @file{java.io}

@<Import java.io@>=
import java.io.*;

@

@c _____________________________________

@node BRRead BufferedReader Constructor Node
@subsubsection BRRead BufferedReader Constructor Section
@cindex BRRead BufferedReader Constructor

@<BRRead BufferedReader Constructor@>=
BufferedReader br = new BufferedReader(
  new InputStreamReader(System.in));
  
@

@c _____________________________________

@node BRRead Enter Characters Node
@subsubsection BRRead Enter Characters Section
@cindex BRRead Enter Characters

@<BRRead Enter Characters@>=
char c;
do {
  c = (char) br.read();
  System.out.println(c);
} while (c != 'q');

@


@c .....................................

@node Reading Strings
@subsection Reading Strings
@cindex strings, reading
@cindex reading strings

To read a string frmo the keyboard, use the version of @code{readLine()} that
is a member of the @file{BufferedReader} class.  Its general form is:

@display
String readLine() throws IOException
@end display

@noindent It returns a @code{String} object.

@subsubheading Program Demonstrating Reading a String from Console
@pindex @file{BRReadLines.java}

The following program demonstrates @file{BufferedReader} and the
@code{readLine()} method; the program reas and displays lines of text until
the word ``stop'' is entered.

@(BRReadLines.java@)=
@<Import java.io@>

class BRReadLines {
  public static void main(String[] args) throws IOException {
    @<BRReadLines BufferedReader Constructor@>
    @<BRReadLines Enter Lines@>
  }
}

@

@c _____________________________________

@node BRReadLines BufferedReader Constructor
@subsubsection BRReadLines BufferedReader Constructor
@cindex BRReadLines BufferedReader Constructor

@<BRReadLines BufferedReader Constructor@>=
// create a BufferedReader using System.in
BufferedReader br = new BufferedReader(
  new InputStreamReader(System.in))

@

@c _____________________________________

@node BRReadLines Enter Lines
@subsubsection BRReadLines Enter Lines
@cindex BRReadLines Enter Lines

@<BRReadLines Enter Lines@>=
String str;

System.out.println("Enter lines of text.");
System.out.println("Enter 'stop' to quit.");

do {
  str = br.readLine();
  System.out.println(str);

} while (!str.equals("stop"));

@


@c -----------------------------------------------------------------------------

@node Writing Console Output
@section Writing Console Output
@cindex Writing Console Output
@cindex @file{PrintStream} as byte stream
@cindex @file{OutputStream} as byte stream abstract class
@cindex @code{print()}, from @file{PrintStream}
@cindex @code{println()}, from @file{PrintStream}
@cindex @code{System.out} as byte stream
@cindex @code{write()} low-level method

The methods

@itemize
@item
@code{print()}
@item
@code{println()}
@end itemize

@noindent are defined by the class @file{PrintStream} (which is the type of
object referenced by @code{System.out}).  Remember, @code{System.out} is a
byte stream, but is acceptable for simple program output.  A character-based
alternative is described in the next section.

Because @file{PrintStream} is an output stream (type byte) derived from
@file{OutputStream} (an abstract byte stream class), it also implements the
low-level method @code{write()}.  Thus, @code{write()} can be used to write
to the console.  The simplest form of @code{write()} defined by
@file{PrintStream} is here:

@display
void write(int @ii{byteval})
@end display

This method writes the byte specified by @ii{byteval}.  Although @ii{byteval}
is declared as in integer, only the low-order eight bits are written.

Here is a short example that uses @code{write()} to output the character
``A'' followed by a newline to the screen:

@example
//Demonstrate System.out.write()
class WriteDemo @{
  public static void main (String[] args) @{
    int b;
    b = 'A';
    System.out.write(b);
    System.out.write('\n');
  @}
@}
@end example
@cindex @code{write()} example


@c -----------------------------------------------------------------------------

@node PrintWriter Class
@section The PrintWriter Class
@cindex @file{PrintWriter} Class, character-based stream
@cindex character-based stream class, @file{PrintWriter}
@cindex internationalization of output to console

Using @file{System.out} to write to the console is probably best for
debugging purposes or for sample programs.  For real-world programs, the
recommended method of writing to the console when using Java is through a
@file{PrintWriter} stream.  @file{PrintWriter} is one of the character-based
classes.  User a character-based class for console output makes
internationalizing your program easier.

@c .................................

@node PrinterWriter Constructors
@subsection @file{PrintWriter} Constructors
@cindex @file{PrintWriter} constructor
@cindex @code{print()} and @code{println()}, @file{PrintWriter} class
@cindex @code{flushingOn}
@cindex flushing
@cindex @code{toString()}, @file{PrintWriter}

@file{PrintWriter} defines several constructors.  Here is one:

@display
PrintWriter(OutputStream @ii{outStream}, boolean @ii{flusingOn})
@end display

@ii{outputStream} is an object of type @file{OutputStream}, and
@ii{flushingOn} controls whether Java flushes the output stream every time a
@code{println} method is called.  If @ii{flushingOn} is @code{true}, flushing
automatically takes place.  If @code{false}, flushing is not automatic.

@file{PrintWriter} supports @code{print()} and @code{println()} methods.  You
can use these methods in the same way you used them with @code{System.out}.
If an argument is not a simple type, the @file{PrintWriter} methods call the
object's @code{toString()} method and then display the result.  

@subheading Writing to the Console with a @file{PrintWriter}

To write to the console by using a @file{PrintWriter}, specify
@code{System.out} for the output stream and automatic flushing.

@example
PrintWriter pw = new PrintWriter(System.out, true);
@end example

@c .................................

@node Demonstration Using PrintWriter
@subsection Demonstration Using a @file{PrintWriter} for Console Output
@cindex demonstration using @file{PrintWriter}
@pindex @file{PrintWriterDemo.java}

@(PrinterWriterDemo.java@)=
@<Import java.io@>

public class PrintWriterDemo {
  public static void main (String[] args) {
    @<PrintWriterDemo PrintWriter Constructor@>
    @<PrintWriterDemo Printing To Console@>
  }
}

@

@c _________________________________

@node PrintWriterDemo PrintWriter Constructor
@subsubsection PrintWriterDemo PrintWriter Constructor

@<PrintWriterDemo PrintWriter Constructor@>=
PrintWriter pw = new PrintWriter (System.out, true);

@

@c _________________________________

@node PrintWriterDemo Printing To Console
@subsubsection PrintWriterDemo Printing To Console

@<PrintWriterDemo Printing To Console@>=
pw.println("This is a string");
int i = -7;
pw.println(i);
double d = 4.5e-7;
pw.println(d);

@

@c .................................

@node PrintWriter Concluding Comments
@subsection @file{PrintWriter} Concluding Comments

There is nothing wrong with using @file{System.out} to write simple text
output to the console.  Using a @file{PrintWriter} makes your real-world
applications easier to internationalize.  There is no other adavantage gained
by using a @file{PrintWriter} in the simple programs, however.

@c -----------------------------------------------------------------------------

@node Reading and Writing Files
@section Reading and Writing Files
@cindex Files, Reading and Writing

Java provides a number of classes and methods that allow you to read and
write files.  The purpose of this section is to introduce the basic
techniques that read from and write to a file.  Although byte streams are
used, these techniques can be adapted to the character-based streams.

@.....................................

@node FileInputStream and FileOutputStream
@subsection @file{FileInputStream} and @file{FileOutputStream}
@cindex @file{FileInputStream}
@cindex @file{FileOutputStream}

Two of the most often-used stream classes are:

@itemize
@item
@file{FileInputStream}
@item
@file{FileOutputStream}
@end itemize

@noindent which create byte streams linked to files.

@subheading Open a File
@cindex file, open

To open a file, create an object of one of these clases, specifying the name
of the file as an argument to the constructor.  We will use the following
constructors:

@display
FileInputStream(String @ii{fileName}) throws FileNotFoundException
FileOutputStream(String @ii{fileName}) throws FileNotFoundException
@end display

Note that when an output file is opened, any preexisting file by the same
name is destroyed.

@subheading Close a File
@cindex file, close
@cindex @code{close()}

When you are done with a file, you must close it.  This is done by calling
the @code{close()} method, which is implemented by both
@file{FileInputStream} and @file{FileOutputStream}.

@display
void close() throws IOException
@end display

@noindent Closing a file releases the system resources allocated to the
file.  Failure to close a file can result in ``memory leaks'' because of
unused resources remaining allocated.

@subheading @file{AutoClosable Interface}
@cindex @file{AutoClosable interface}

Beginning with JDK 7, the @code{close()} method is specified by the
@file{AutoCloseable} interface in @file{java.lang}.  @file{AutoCloseable} is
inherited by the @file{Closable} interface in @file{java.io}.  Both
interfaces are implemented by the stream classes, including
@file{FileInputStream} and @file{FileOutputStream}.

@subheading Try With Resources

There are two basic approaches you can use to close a file.  The first is the
traditional approach, in which @code{close()} is called explicitly when the
file is no longer needed.  This is the approach used by all versions of Java
prior to JDK 7.

The second is to use the @code{try-with-resources} statement added by JDK 7,
which automatically closes a file when it is no longer needed.  In this
approach, no explicit call to @file{close()} is executed.

@subheading Reading From A File
@cindex file, read from
@cindex @code{read()}

To read from a file, you can use a version of @code{read()} that is defined
within @file{FileInputStream}.

@display
int read() throws IOException
@end display

@noindent Each time that it is called, it reads a single byte from the file
and returns the byte as an integer value.  @code{read()} returns -1 when an
attempt is made to read at the end of the stream.

@subheading Writing to a File
@cindex write to a file
@cindex file, write to
@cindex @code{write()}, @file{FileOutputStream} class

To write to a file, you can use the @code{write()} method defined by
@file{FileOutputStream}.  Its simplest form is:

@display
void write(int @ii{byteval} throws IOException
@end display

This method writes the byte specified by @ii{byteval} to the file.  Although
@ii{byteval} is declared as an integer, only the low-order eight bits are
written to th file.

@c .....................................

@node Demonstration Reading From a File
@subsection Demonstration Reading From a File
@cindex reading from file demonstration
@pindex @file{ShowFile.java}

The following program uses @code{read()} to input and display the contents of
a file that contains ASCII test.  The name of the file is specified as a
command-line argument.

@(ShowFile.java@)=
@<ShowFile Initial Comments@>
@<Import java.io@>
class ShowFile {
  public static void main (String[] args) {
    @<ShowFile Instance Variable Declarations@>
    @<ShowFile Open a File@>
    @<ShowFile Read a File@>
    @<ShowFile Close a File@>
  }
}

@

@c _____________________________________

@node ShowFile Initial Comments
@subsubsection ShowFile Initial Comments

@<ShowFile Initial Comments@>=
/* Display a text file.
   To use this program, specify the name
   of the file that you want to see.
   For example, to see a file called TEST.TXT,
   use the following command line:

   java ShowFile TEST.TXT
 */
 
@

@c _____________________________________

@node ShowFile Instance Variable Declarations
@subsubsection ShowFile Instance Variable Declarations

@<ShowFile Instance Variable Declarations@>=
int i;
FileInputstream fin;

@

@c _____________________________________

@node ShowFile Open a File
@subsubsection ShowFile Open a File

Notice all of the @code{try/catch} blocks that handle the I/O errors that
might occur.  Each I/O operation is monitored for exceptions, and if an
exception occurs, it is handled.


@<ShowFile Open a File@>=
// First, confirm that a filename has been specified.
if (args.length != 1) {
  System.out.printli("Usage: ShowFile filename");
  return;
}

// Attempt to open the file
try {
  fin = new FileInputStream(args[0]);
} catch (FileNotFoundException e) {
  System.out.println("Cannot Open File");
  return;
}

@

@c _____________________________________

@node ShowFile Read a File
@subsubsection ShowFile Read a File

@<ShowFile Read a File@>=
// At this point, the file is open and can be read.
// The following reads characters until EOF is encountered.
try {
  do {
    i = fin.read();
    if (i != -1) System.out.print ((char) i);
  } while (i != -1);
} catch (IOException e) {
  System.out.println("Error Reading File");
}

@

@c _____________________________________

@node ShowFile Close a File
@subsubsection ShowFile Close a File

@<ShowFile Close a File@>=
// Close the file
try {
  fin.close();
} catch (IOException e) {
  System.out.println("Error Closing File");
}

@

@c _____________________________________

@node close() Within finally
@subsubsection @code{close()} Within @code{finally} Block
@cindex @code{close()} Within @code{finally}

Although the preceding example closes the file stream after the file is read,
there is a variation that is often useful.  The variation is to call
@code{close()} within a @code{finally} block.  In this approach, all of the
methods that access the file are contained within a @code{try} block, and the
@code{finally} block is used to close the file.  This way, no matter how the
@code{try} block terminates, the file is closed.
@pindex @file{ShowFileAlt.java}

One advantage tothis approach in general is that if the code that accesses a
file terminates because of some non-I/O related exception, the file is still
closed by the @code{finally} block.

Here is how the @code{try} block that reads the file can be recode:

@(ShowFileAlt.java@)=
@<ShowFile Initial Comments@>
@<Import java.io@>
class ShowFileAlt {
  public static void main (String[] args) {
    @<ShowFile Instance Variable Declarations@>
    @<ShowFile Open a File@>
    @<ShowFileAlt Read a File@>
    @<ShowFile Close a File@>
  }
}

@

@subsubheading ShowFileAlt Read a File

@<ShowFileAlt Read a File@>=
try {
  do {
    i = fin.read();
    if (i != -1) System.out.print ((char) i);
  } while (i != -1);
} catch (IOException e) {
  System.out.println("Error Reading File.");
} finally {
  // Close the file on the way out of the block.
  try {
    fin.close();
  } catch (IOException e) {
    System.out.println ("Error Closing File.");
  }
}

@


@c .....................................

@node Demonstration Reading From File with Single try
@subsection Demonstration Reading From a File with a Single @code{try} Block

Sometimes it's easier to wrap the portions of a program that open a file and
access the file within a single @code{try} block (rather than separating the
two) and then use a @code{finally} block to close the file.

Here is another way to write the @file{ShowFile} program:

@(ShowFileSingleTry@)=
@<ShowFile Initial Comments@>
@<ShowFileSingleTry Additional Initial Comment@>
@<Import java.io@>
class ShowFileSingleTry {
  public static void main (String[] args) {
    @<ShowFile Instance Variable Declarations@>
    @<ShowFile Open a File@>
    @<ShowFileSingleTry Read a File@>
  }
}

@

@c _____________________________________

@node ShowFileSingleTry Additional Initial Comment
@subsubsection ShowFile SingleTry Additional Initial Comment

@<ShowFileSingleTry Additional Initial Comment@>=
/* This variation wraps the code that opens and
   accesses the file within a single try block.
   The file is closed by the finally block.
 */

@

@c _____________________________________

@node ShowFileSingleTry Read a File
@subsubsection ShowFileSingleTry Read a File

In this approach, @code{fin} is initialized to @code{null}.  In the
@code{finally} block, the file is closed only if @code{fin} is not
@code{null}.  This works because @code{fin} will be non-@code{null} only if
the file is successfully opened.  Thus, @code{close()} is not called if an
exception occurrs while opening the file.

@<ShowFileSingleTry Read a File@>=
// The following code opens a file, reads characters until EOF
// is encountered, and then closes the file via a finally block.

try {
  fin = new FileInputStream(args[0]);

  do {
    i = fin.read();
    if (i != -1) System.out.print((char) i);
  } while (i != -1);

} catch (FileNotFoundException e) {
  System.out.println("File Not Found.");

} catch (IOException e) {
  System.out.println("An I/O Error Occurred");

} finally {
  // Close file in all cases
  try {
    if (fin != null) fin.close();
  } catch (IOException e) {
    System.out.println("Error Clsoing File");
  }
}

@

@subsubheading More Compact Catch Code

It is possible to make the @code{try/catch} sequence a bit more compact.
Because @file{FileNotFoundException} is a subclass of @file{IOException}, it
need not be caught separately.  Here is the sequence recoded to eliminate
catching @file{FileNotFoundException}.  In this case, the standard exception
message, which describes the error, is displayed.

@example
@} catch (IOException e) @{
  System.out.println("I/O Error: " + e);
@} finally @{
  try @{
    if (fin != null) fin.close();
  @} catch (IOException e) @{
    System.out.println("Error Closing File");
  @}
@}
@end example

In this approach, any error, including an error opening the file, is simply
handled by the single @code{catch} statement.  This approach may not be
appropriate in cases in which you want to deal separately with  a failure to
open a file, such as might be caused by a mis-typed filename.  In such a
situation, you might want to prompt for the correct name before entering a
@code{try} block that accesses the file.

The next example uses @code{write()} to copy a file.

@c .....................................

@node Demonstration Writing to a File
@subsection Demonstration Writing to a File
@cindex write to file demonstration
@cindex exceptions for I/O errors
@pindex @file{CopyFile.java}

This example uses @code{write()} to copy a file.

Notice that all potential I/O errors are handled in the programs by the use
of exceptions.  This differs from some computer languages that use error
codes to report file errors.  They enable Java to easily differentiate the
end-of-file condition from file errors when input is being performed.

@(CopyFile.java@)=
@<CopyFile Initial Comments@>
@<Import java.io@>
class CopyFile {
  public static void main (String[] args) {
    @<CopyFile Instance Variable Declarations@>
    @<CopyFile Check For 2 Files@>
    @<CopyFile Copy a File@>
  }
}

@

@c _____________________________________

@node CopyFile Initial Comments
@subsubsection CopyFile Initial Comments

@<CopyFile Initial Comments@>=
/* Copy a file
   To use this program, specify the name
   of the source file and the destination file.
   For example, to copy a file called FIRST.TXT
   to a file called SECOND.TXT, use the following
   command line.

   java CopyFile FIRST.TXT SECOND.TXT
 */

@

@c _____________________________________

@node CopyFile Instance Variable Declarations
@subsubsection CopyFile Instance Variable Declarations

@<CopyFile Instance Variable Declarations@>=
int i;
FileInputStream fin = null;
FileOutputStream fout = null;

@

@c _____________________________________

@node CopyFile Check for 2 Files
@subsubsection CopyFile Check for 2 Files

@<CopyFile Check For 2 Files@>=
// First, confirm that both files have been specified
if (args.length != 2) {
  System.out.println("Usage: CopyFile from to");
  return;
}

@

@c _____________________________________

@node CopyFile Copy a File
@subsubsection CopyFile Copy a File

Notice that there are two separate @code{try} blocks used when closing the
files.  This ensures that both files are closed, even if the call to
@code{fin.close()} throws an exception.

@<CopyFile Copy a File@>=
// Copy a file
try {
  // Attempt to open the files
  fin = new FileInputStream(args[0]);
  fout = new FileOutputStream(args[1]);

  do {
    i = fin.read();
    if (i != -1) fout.write(i);
  } while (i != -1);
  
} catch (IOException e) {
  System.out.println("I/O Error: " + e);

} finally {
  try {
    if (fin != null) fin.close();
  } catch (IOException e2) {
    System.out.println("Error Closing Input File");
  }

  try {
    if (fout != null) fout.close();
  } catch (IOException e2) {
    System.out.println("Error Closing Output File");
  }
}

@


@c -----------------------------------------------------------------------------

@node Automatically Closing Files
@section Automatically Closing Files
@cindex @code{try-with-resources}
@cindex automatic resource management
@cindex ARM

JDK 7 added a feature that offers another way to manage resources,such as
file streams, by automating the closing process.  This feature, sometimes
referred to as @dfn{automatic resource management}, or @acronym{ARM} for
short, is based on an expanded version of the @code{try} statement.  This
form of @code{try} is called the @code{try-with-resources} statement.
The principal advantage of automatic resource management is that it prevents
situations in which a file (or other resource) is inadvertently not released
after it is no longer needed.

Here is its general form:

@float GeneralForm,AutomaticResourceManagement
@display
try (@ii{resource-specification}) @{
  // use the resource
@}
@end display
@caption{General Form Automatic Resource Management}
@end float

Typically, @ii{resource-specification} is a statement that declares and
initializes, such as a file stream.  It consists of a variable declaration in
which the variable is initialized with a reference to the object begin
managed.  When the @code{try} block ends, the resource is automatically
released.  In the case of a file, this means that the file is automatically
closed.  This form of @code{try} can also include @code{catch} and
@code{finally} clauses.  A resource declared in the @code{try} statement is
implicitly @code{final}.  This means that you can't assign to the resource
after it has been created.  The scope of the resource is limited to the
@code{try-with-resources} statement.

Beginning with JDK 9, it is also possible for the resource specification of
the @code{try} to consist of a variable that has been declared and
initialized earlier in the program.  However, that variable must be
effectively final, which means that it has not been assigned a new value
after being given its initial value.

@subheading @file{AutoCloseable} Interface

The @code{try-with-resources} statement can be used only with those
resources that implement the @file{AutoCloseable} interface defined by
@file{java.lang}.  This interface defines the @code{close()} method.
@file{AutoCloseable} is inherited by the @file{Closeable} interface in
@file{java.io}.  Both interfaces are implmented by the stream classes.  Thus,
@code{try-with-resources} can be used when working with streams,
including file streams.

@subheading Multiple Resources
@cindex @code{try-with-resources} multiple resources

You can manage more than one resource within a single @code{try} statement.
Simply separate each resource specification with a semicolon.


@c .....................................

@node Demonstration of Automatically Closing a File
@subsection Demonstration of Automatically Closing a File
@pindex @file{ShowFileTryWR.java}

Here is a reworked verion of the @file{ShowFile} program using
@code{try-with-resources}.

@(ShowFileTryWR.java@)=
@<ShowFileTryWR Initial Comments@>
@<Import java.io@>
class ShowFileTryWR {
  public static void main (String[] args) {
    @<ShowFileTryWR Instance Variable Declaration@>
    @<ShowFileTryWR Check CL Args@> @<Number 1@> @<ShowFileTryWR Check CL Args End@>
    @<ShowFileTryWR Open a File TryWR@>
  }
}

@

@c _____________________________________

@node ShowFileTryWR Initial Comments
@subsubsection Initial Comments

@<ShowFileTryWR Initial Comments@>=
/* This version of teh ShowFile program uses a try-with-resources
   statement to automatically close a file after it is no longer needed.
 */

@

@c _____________________________________

@node ShowFileTryWR Instance Variable Declarations
@subsubsection Instance Variable Declaration

@<ShowFileTryWR Instance Variable Declaration@>=
int i;

@

@c _____________________________________

@node ShowFileTryWR Check CL Args
@subsubsection Check CL Args

@<ShowFileTryWR Check CL Args@>=
// First, confirm that a filename has been specified.
if (args.length !=
@

@<ShowFileTryWR Check CL Args End@>=
) {
  System.out.println("Usage: ShowFile filename");
  return;
}

@

@<Number 1@>=
1
@

@c _____________________________________

@node ShowFileTryWR Open a File TryWR
@subsubsection Open a File TryWR

@cartouche
Pay special attention to how the file is opened within the @code{try}
statement.  The resource-specification portion of the @code{try} declares a
@file{FileInputStream} called @code{fin}, which is then assigned a reference
to the file opened by its constructor.  Therefore, here, the variable
@code{fin} is local to the @code{try} block, being created when the
@code{try} is entered.  When the @code{try} is left, the stream associated
with @code{fin} is automatically closed by an implicit call to
@code{close()}.  Since you don't call @code{close()} explicitly, you can't
forget to close the file.  This is a key advantage of using
@code{try-with-resources}.
@end cartouche

@ifinfo
@noindent ================================================================================
@end ifinfo


@<ShowFileTryWR Open a File TryWR@>=
/* The following code uses a try-with-resources statement to open
   a file and then automatically close it when the try block is left. */

try (FileInputStream fin = new FileInputStream(args[0])) {

  do {
    i = fin.read();
    if (i != -1) System.out.print((char) i);
  } while (i != -1);

} catch (FileNotFoundException e) {
  System.out.println("File Not Found.");

} catch (IOException e) {
  System.out.println("An I/O Error Occurred.");
}

@

@c .....................................

@node Demonstration of Multiple Resources
@subsection Demonstration of Multiple Resources
@pindex @file{CopyFileMultTryWR.java}

The following program shows an example of handling multiple resources in a
single @code{try} statement.  It reworks the @code{CopyFile} program shown
earlier so that it uses a single @code{try-with-resources} statement to
manage both @code{fin} and @code{fout}.

@(CopyFileMultTryWR.java@)=
@<CopyFileMultTryWR Initial Comments@>
@<Import java.io@>
class CopyFileMultTryWR {
  public static void main (String[] args) throws IOException {
    @<ShowFileTryWR Instance Variable Declaration@>
    @<ShowFileTryWR Check CL Args@> @<Number 2@> @<ShowFileTryWR Check CL Args End@>
    @<CopyFileMultTryWR Manage Two Files@>
  }
}

@

@<Number 2@>=
2
@

@c _____________________________________

@node CopyFileMultTryWR Initial Comments
@subsubsection CopyFileMultTryWR Initial Comments

@<CopyFileMultTryWR Initial Comments@>=
/* A version of CopyFile that uses try-with-resources.
   It demonstrates two resources (in this case files) being
   managed by a single try statement
 */

@

@c _____________________________________

@node CopyFileMultTryWR Manage Two Files
@subsubsection CopyFileMultTryWR Manage Two Files

@cartouche
Note how the input and output files are opened within the @code{try} block.
After this block ends, both @code{fin} and @code{fout} will have been
closed.  This code is much shorter.  The ability to streamline source code is
a side-benefit of automatic resouce management.
@end cartouche

@ifinfo
@noindent ================================================================================
@end ifinfo


@<CopyFileMultTryWR Manage Two Files@>=
// Open and manage two files via the try statement.
try (FileInputStream fin = new FileInputStream(args[0]);
     FileOutputStream fout = new FileOutputStream(args[1])) {

  do {
    i = fin.read();
    if (i != -1) fout.write(i);
  } while (i != -1);

} catch (IOException e) {
  System.out.println("I/O Error: " + e);
}

@



@c *****************************************************************************

@node Miscellaneous Java Keywords
@chapter Miscellaneous Java Keywords
@cindex @code{volative}
@cindex @code{instanceof}
@cindex @code{native}
@cindex @code{strictfp}
@cindex @code{assert}

This chapter looks at several more Java keywords:


@itemize
@item
@code{volatile}
@item
@code{instanceof}
@item
@code{native}
@item
@code{strictfp}
@item
@code{assert}
@end itemize



@c -----------------------------------------------------------------------------

@node transient and volatile Modifiers
@section The @code{transient} and @code{volative} Modifiers


@c -----------------------------------------------------------------------------

@node Using instanceof
@section Using @code{instanceof}


@c -----------------------------------------------------------------------------

@node strictfp
@section @code{strictfp}


@c -----------------------------------------------------------------------------

@node Native Methods
@section Native Methods


@c -----------------------------------------------------------------------------

@node Using assert
@section Using @code{assert}


@c -----------------------------------------------------------------------------

@node Static Import
@section Static Import


@c -----------------------------------------------------------------------------

@node Overloaded Constructors with this
@section Invoking Overloaded Constructors Through @code{this()}


@c -----------------------------------------------------------------------------

@node Compact API Profiles
@section Compact API Profiles



@c *****************************************************************************

@node Generics
@chapter Generics
@cindex Generics (chapter)
@cindex generics, introduction
@cindex J2SE 5.0
@cindex Collections Framework
@cindex collections, generics
@cindex type abstraction, generics
@cindex abstract over types

@dfn{Generics}, introduced in J2SE 5.0, allows a type or method to operate on
objects of various types while providing compile-time type safety.  It adds
compile-time type safety to the Collections Framework and eliminates the need
of casting.  In other words, generics allow you to abstract over types.

Through the use of generics, it is possible to create classes, interfaces,
and methods that will work in a type-safe manner with various kinds of data.
Many algorithms are logically the same no matter what type of data they are
being applied to.  For example, the mechanism that supports a stack is the
same whether that stack is storing items of type @command{Integer},
@command{String}, @command{Object}, or @command{Thread}.  With generics, you
can define an algorithm once, independently of any specific type of data, and
then apply that algorithm to a wide variety of data types without any
additional effort.

Perhaps the one feature of Java that has been most significantly affected by
generics is the @cite{Collections Framework}.  A @dfn{collection} is a group
of objects.  The Collections Framework defines several classes, such as lists
and maps, that manage collections.  The collection classes have always been
able to work with any type of object.  The benefit that generics adds is that
the collection classes can now be used with complete type safety.

This chapter describes the syntax, theory, and use of generics.  It also
shows how generics provide type safety for some previously difficult cases.


@c -----------------------------------------------------------------------------

@node Motivation
@section Motivation for Generics
@cindex generics, motivation

@subheading Code Fragment Without Generics

Here is a typical code fragment abstracting over types by using @code{Object}
and type casting.

@example
List myIntList = new LinkedList(); // 1
myIntList.add(new Integer(0)); // 2
Integer x = (Integer) myIntList.iterator().next(); // 3
@end example

The cast on line 3 is annoying, although essential.  The compiler can
guarantee only that an @code{Object} will be returned by the iterator.  This
therefore adds both clutter and the possibility of a run-time error.

@subheading Code Fragment with Generics

Generics allow a programmer to mark their intent to restrict a list to a
particular data type.  Here is a version of the same code that uses generics.

@example
List<Integer> myIntList = new LinkedList<Integer>(); // 1'
myIntList.add(new Integer(0)); // 2'
Integer x = myIntList.iterator().next(); // 3'
@end example
@cindex generic interface
@cindex type parameter
@cindex type correctness
@cindex compile-time type check
@cindex generics, motivation, readability and robustness

In line 1, the type declaration for the variable @code{myIntList} specifies
that it is to hold a @code{List} of @code{Integer}s: @samp{List<Integer>}.
@code{List} is a @dfn{generic interface} that takes a @dfn{type parameter}
(@code{Integer}).  The type parameter is also specified when creating the
@code{List} object (@samp{new LinkedList<Integer>()}).  Also, the cast on
line 3 is gone.

So has this just moved the clutter around, from a type cast to a type
parameter?  No, because this has given the compiler the ability to check the
type correctness of the program @emph{at compile-time}.  When we say that
@code{myIntList} is declared with type @code{List<Integer>}, this tells us
something about the variable @code{myIntList}, which holds true wherever and
whenever it is used, and the compiler will guarantee it.  In contrast, the
cast tells us something the programmer thinks is true at a single point in
the code.

The net effect, especially in large programs, is improved readability and
robustness.


@c -----------------------------------------------------------------------------

@node What are Generics
@section What Are Generics
@cindex generics, what they are
@cindex parameterized types
@cindex generic class, method
@cindex @command{Object} type
@cindex type safety, generics
@cindex casts, generics, automatic, implicit
@cindex generics, casts

The term @dfn{generics} means @i{parameterized types}.  Parameterized types
are important because they enable you to create classes, interfaces, and
methods in whicht the type of data upon which they operate is specified as a
parameter.  Using generics, it is possible to create a single class, for
example, that automatically works with different types of data.  A class,
interface, or method that operates on a parameterized type is called
@dfn{generic}, as in @i{generic class} or @i{generic method}.

Java has always given the ability to create generalized classes, interfaces,
and methods by operating through references of type @code{Object}.
Generics added the type safety that was lacking.  They also streamlined the
process, because it is no longer necessary to explicitly employ casts to
translate between @code{Object} and the type of data that is being operate
upon.  Wtih generics, all casts are automatic and implicit.

@node Simple Generics Example
@section A Simple Generics Example
@cindex generics example
@cindex example, generics
@cindex generic class
@pindex @file{SimpleGenerics.java}

The following program defines two classes.  The first is the generic class
@code{Gen}, and the second is @code{GenDemo}, which uses @code{Gen}.

@(SimpleGenerics.java@)=
@<Class Gen@>
@<Class GenDemo@>
@

@c .....................................

@node Class Gen<T>
@subsection Class Gen<T>
@cindex generic class
@cindex parameter, generic class
@cindex type parameter, generic class
@cindex parameterized type

This is a simple generic class.  The class @code{Gen} is declared with a
parameter of @samp{<T>}:

@example
class Gen<T> @{
@end example

@samp{T} is the name of a @dfn{type parameter}.  This name is used as a
placeholder for the actual type that will be passed to @code{Gen} when an
object is created.  Thus, @samp{T} is used within @code{Gen} whenever the
type parameter is needed.

Notice that @samp{T} is contained within @samp{< >}.  This syntax can be
generalized.  Whenever a type parameter is being declared, it is specified
within angle brackets.

Because @code{Gen} uses a type parameter, @code{Gen} is a @emph{generic
class}, which is also called a @emph{parameterized type}.

@subsubheading Outline of Class Gen<T>

Class @code{Gen} contains four parts:

@itemize
@item
an instance variable declaration
@item
a constructor
@item
a method returning the instance variable
@item
a method describing the type of the instance variable
@end itemize

@<Class Gen@>=
class Gen<T> {
  @<Instance Variable ob of Type T@>
  @<Constructor taking parameter of Type T@>
  @<Method returning object of type T@>
  @<Method showing type of T@>
}
@

@subsubheading Implementation of Class Gen<T>

@samp{T} is used to declare an object called @code{ob}.  @samp{T} is a
placeholder for the actual type that will be specified when a @code{Gen}
object is created.  Thus, @code{ob} will be an object of the type passed to
@samp{T}.  

@<Instance Variable ob of Type T@>=
T ob;	// declare an object of type T

@

@subsubheading The Constructor
@anchor{generics-constructor}

Here is the constructor for @code{Gen}.  Notice that its parameter, @code{o},
is of type @samp{T}.  This means that the actual type of @code{o} is
determined by the type passed to @samp{T} when a @code{Gen} object is
created.  Because both the parameter @code{o} and the member variable
@code{ob} are of type @samp{T}, they will both be the same actual type when
a @code{Gen} object is created.

@<Constructor taking parameter of Type T@>=
// Pass the constructor a reference to
// an object of type T
Gen (T o) {
  ob = o;
}

@

@subsubheading Instance Methods @code{getob()} and @code{showType()}

The type parameter @samp{T} can also be used to specify the return type of a
method, as here in @code{getob()}.  Because @code{ob} is also of type
@samp{T}, its type is compatible wih the return type specified by
@code{getob()}.  

@<Method returning object of type T@>=
// Return ob
T getob() {
  return ob;
}

@

@cindex @code{Class}
@cindex @code{Object}
@cindex @code{getClass()}, defined in @code{Object}
@cindex @code{Class} object, from @code{getClass()}
@cindex @code{getName()}, defined in @code{Class}
@cindex class name, from @code{getName()}

The method @code{showType()} displays the type of @samp{T} by calling
@code{getName()} on the @code{Class} object return by the call to
@code{getClass()} on @code{ob}.   The @code{getClass()} method is defined
by @code{Object} and is thus a member of @emph{all} class types.  It returns
a @code{Class} object that corresponds to the type of the class of the
object on which it is called.  @code{Class} defines the @code{getName()}
method, which returns a string representation of the class name.

@<Method showing type of T@>=
// Show type of T
void showType() {
  System.out.println("Type of T is " + ob.getClass().getName();
}

@


@c .....................................

@node Class GenDemo
@subsection Class GenDemo
@cindex generic code, demonstrating an implementation
@cindex erasure
@cindex type erasure

The @code{GenDemo} class demonstrates the generic @code{Gen} class.

But first, take note: The Java compiler does not actually create different
versions of @code{Gen}, or of any other generic class.  The compiler removes
all generic type information, substituting the necessary casts, to make your
code @strong{behave as if} a specific version of @code{Gen} were created.
There is really only one version of @code{Gen} that actually exists.

The process of removing generic type information is called @dfn{type
erasure}.  

@code{GenDemo} first creates a version of @code{Gen} for integers and calls
the methods defined in @code{Gen} on it.  It then does the same for a String
object.

@<Class GenDemo@>=
// Demonstrate the generic class
class GenDemo {
  public static void main(String args[]) {
    @<Create a Gen object for Integers@>
    @<Create a Gen object for Strings@>
  }
}

@

@c _____________________________________

@node GenDemo as Integer
@subsubsection Implementation of Class GenDemo with Type Integer
@cindex generic reference, creating
@cindex type argument, passed to type parameter

@<Create a Gen object for Integers@>=
@<Integer Type Parameter@>
@<Reference to Integer Instance@>
@<Show Type@>
@<Get Value@>
@

@subsubheading Integer Type Declaration
@cindex generic reference to Integer

A reference to an Integer is declared in @code{iOb}.  Here, the type
@samp{Integer} is specified within the angle brackets after @code{Gen}.
@samp{Integer} is a @dfn{type argument} that is passed to @code{Gen}'s type
parameter, @samp{T}.  This effectively creates a version of @code{Gen} in
which all references to @samp{T} are translated into references to
@samp{Integer}.  Thus, @code{ob} is of type @samp{Integer}, and the return
type of @code{getob()} is of type @samp{Integer}.

@<Integer Type Parameter@>=
Gen<Integer> iOb;

@

@subsubheading Reference Assignment
@cindex generic reference assignment to Integer
@cindex generic type checking
@cindex generics, compile-time error, mismatched types
@cindex generics, type safety benefit
@cindex autoboxing in generic reference

The next line assigns to @code{iOb} a reference to an instance of an
@samp{Integer} version of the @code{Gen} class.  When the @code{Gen}
constructor is called, the type argument @samp{Integer} is also specified.
This is because the type of the object (in this case @code{iOb} to which the
reference is being assigned is of type @code{Gen<Integer>}.  Thus, the
reference returned by @command{new} must also be of type
@code{Gen<Integer>}.  If it isn't, a compile-time error will result.  This
type checking is one of the main benefits of generics because it ensures type
safety.  

Notice the use of autoboxing to encapsulate the value 88 within an Integer
object.

@<Reference to Integer Instance@>=
iOb = new Gen<Integer>(88);

@

The automatic autoboxing could have been written explicitly, like so:
@example
iOb = new Gen<Integer>(Integer.valueOf(88));
@end example
@noindent but there would be no value to doing it that way.

@subsubheading Showing the Reference's Type

The program then uses @code{Gen}'s instance method to show the type of
@code{ob}, which is an @samp{Integer} in this case.

@<Show Type@>=
iOb.showType();

@

@subsubheading Showing the Reference's Value

The program now obtains the value of @code{ob} by assiging @code{ob} to an
@samp{int} variable.  The return type of @code{getob()} is @samp{Integer},
which unboxes into @samp{int} when assigned to an @samp{int} variable
(@code{v}).  There is no need to cast the return type of @code{getob()} to
@samp{Integer}.  

@<Get Value@>=
int v = iOb.getob();
System.out.println("value: " + v);
System.out.println();

@

@c _____________________________________

@node GenDemo as String
@subsubsection Implementation of Class GenDemo with Type String

@<Create a Gen object for Strings@>=
// Create a Gen object for Strings.
Gen<String> strOb = new Gen<String>("Generics Test");

// Show the type of data used by strOb
strOb.showType();

// Get the value of strOb.  Again, notice
// that no cast is needed.
String str = strOb.getob();
System.out.println("value: " + str);

@


@c -----------------------------------------------------------------------------

@node Notes about Generics
@section Notes About Generics

@c .....................................

@node Reference Types
@subsection Generics Work Only with Reference Types
@cindex generics, only reference types
@cindex generic type argument, reference type
@cindex type wrappers, generics
@cindex auto-boxing, generics
@cindex auto-unboxing, generics

When declaring an instance of a generic type, the type argument passed to the
type parameter must be a reference type.  It cannot be a primitive type, such
as @samp{int} or @samp{char}.

You can use the type wrappers to encapsulate a primitive type.  Java's
autoboxing and auto-unboxing mechanism makes the use of the type wrapper
transparent.  

@c .....................................

@node Type Arguments
@subsection Generic Types Differ Based on their Type Arguments
@cindex generic types differ, type arguments

A reference of one specific version of a generic type is not type-compatible
with another version of the same generic type.  In other words, the following
line of code is an error and will not compile:

@example
iOb = strOb; // Gen<Integer> != Gen<String>
@end example

These are references to different types because their type arguments differ.

@c .....................................

@node Subtyping
@subsection Generics and Subtyping
@cindex generics, subtyping

Is the following legal?

@example
List<String> ls = new ArrayList<String>(); // 1
List<Object> lo = ls; // 2
@end example

Line 1 is legal.  What about line 2?  This boils down to the question: ``is a
List of String a List of Object.''  Most people instinctively answer,
``Sure!''

Now look at these lines:

@example
lo.add(new Object()); // 3
String s = ls.get(0); // 4: Attempts to assign an Object to a String!
@end example

Here we've aliased @code{ls} and @code{lo}. Accessing @code{ls}, a list of
@code{String}, through the alias @code{lo}, we can insert arbitrary objects
into it. As a result @code{ls} does not hold just @code{Strings} anymore, and
when we try and get something out of it, we get a rude surprise.

The Java compiler will prevent this from happening of course. Line 2 will
cause a compile time error.

The take-away is that, if @code{Foo} is a subtype (subclass or subinterface)
of @code{Bar}, and @code{G} is some generic type declaration, it is not the
case that @code{G<Foo>} is a subtype of @code{G<Bar>}.

@c .....................................

@node Type Safety
@subsection How Generics Improve Type Safety
@cindex generics improve type safety
@cindex generics ensure type safety
@cindex generics eliminate casts
@cindex casts, eliminated in generics

Generics automatically ensure the type safety of all operations involving a
generic class, such as @code{Gen}.  They eliminate the need for the coder to
enter cases and to type-check code by hand.


@c -----------------------------------------------------------------------------

@node Two Type Parameters
@section A Generic Class with Two Type Parameters
@cindex generic class, two type parameters

You can declare more than one type parameter in a generic type.  To specify
two or more type parameters, use a comma-separated list.  When an object is
created, the same number of type arguments must be passed as there are type
parameters.  The type arguments can be the same or different.

@c .....................................

@node Two Types Example Code
@subsection Example of Code with Two Type Parameters
@pindex @file{TwoTypeParameters.java}

@(TwoTypeParameters.java@)=
@<Class TwoGen@>
@<Class SimpGen@>
@

@c _____________________________________

@node Class TwoGen
@subsubsection Class TwoGen

@<Class TwoGen@>=
@<Class Declaration@>
  @<Two Instance Variables Declarations@>
  @<Constructor of Two Parameters@>
  @<Instance Methods Show and Get@>
@

@subsubheading Class Declaration
@cindex generics, two type parameters, declaration
@cindex generics, two type arguments

Notice how @code{TwoGen} is declared.  It specifies two type parameters:
@samp{T} and @samp{V}, separated by a comma.  Because it has two type
parameters, two type arguments must be passed to @code{TwoGen} when an object
is created.

@<Class Declaration@>=
class TwoGen<T, V> {
@

@subsubheading Instance Variables Declarations

@<Two Instance Variables Declarations@>=
T ob1;
V ob2;

@

@subsubheading Constructor
@<Constructor of Two Parameters@>=
TwoGen(T o1, V 02) {
  ob1 = o1;
  ob2 = o2;
}

@

@subsubheading Instance Methods Show and Get
@<Instance Methods Show and Get@>=
void showTypes() {
  System.out.println("Type of T is " + ob1.getClass().getName());
  System.out.println("Type of V is " + ob2.getClass().getName());
}

T getob1() {
  return ob1;
}

V getob2() {
  return ob2;
}

@

@c _____________________________________

@node Class SimpGen
@subsubsection Class SimpGen

Two type arguments must be supplied to the constructor.  In this case, the
two type parameters are @samp{Integer} and @samp{String}.

@<Class SimpGen@>=
class SimpGen {
  public static void main(String args[]) {
    TwoGen<Integer, String> tgObj =
      new TwoGen<Integer, String>(88, "Generics");

    // Show the types
    tgObj.showTypes();

    // Obtain and show values
    int v = tgObj.getob1();
    System.out.println("value: " + v);

    String str = thObj.getob2();
    System.out.println("value: " + str);
  }
}
@


@c -----------------------------------------------------------------------------

@node Generic Class General Form
@section The General Form of a Generic Class
@cindex generic class, general form

The generics syntax shown above can be generalized.  Here is the syntax for
declaring a generic class:

@float GeneralForm,GenericClass
@display
class @ii{class-name}<@ii{type-param-list}> @{ @dots{}
@end display

Here is the full syntax for declaring a reference to a generic class and
instance creation:

@display
@ii{class-name}<@ii{type-arg-list}> @ii{var-name} =
  new @ii{class-name}<@ii{type-arg-list}>(@ii{cons-arg-list});
@end display
@caption{General Form for Declaring and Creating a Reference to a Generic
Class}
@shortcaption{General Form Generic Class}
@end float


@c -----------------------------------------------------------------------------

@node Bounded Types
@section Bounded Types
@cindex generics, bounded types
@cindex bounded types
@cindex upper bound
@cindex @command{extends} clause

Sometimes it can be useful to limit the types that can be passed to a type
parameter.  Java provides @dfn{bounded types}.  When specifying a type
parameter, you can create an upper bound that declares the superclass from
which all type arguments must be derived.  This is accomplished through the
use of an @command{extends} clause when specifying the type parameter:

@display
 <@ii{T} extends @ii{superclass}>
@end display

This specifies that @ii{T} can only be replaced by @ii{superclass} or
subclasses of @ii{superclass}.  Thus, @ii{superclass} defines an inclusive,
upper limit.

@subheading Interface Type as a Bound
@cindex generics, interface as bound
@cindex interface as bound, generics

In addition to using a class type as a bound, you can also use an interface
type.  In fact, youi can specify multiple interfaces as bounds.  Furthermore,
a bound can include both a class type and one or more interfaces.  In this
case, the class type must be specified first.  When a bound includes an
interface type, only type arguments that implement that interface are legal.

When specifying a bound that has a class and an interface, or multiple
interfaces, use the @kbd{&} operator to connnect them.

@example
class Gen<T extends MyClass & MyInterface> @{ @dots{}
@end example

Any type argument passed to @samp{T} must be a subclass of @code{MyClass} and
implement @code{MyInterface}.


@c -----------------------------------------------------------------------------

@node Wildcard Arguments
@section Using Wildcard Arguments
@cindex generics, wildcard arguments
@cindex wildcard arguments, generics

@c .....................................

@node Wildcard Motivation
@subsection Wildcard Motivation
@cindex wildcards, motivation

Consider the problem of writing a routine that prints out all the elements in
a collection. Here's how you might write it in an older version of the
language (i.e., a pre-5.0 release):

@example
void printCollection(Collection c) @{
    Iterator i = c.iterator();
    for (k = 0; k < c.size(); k++) @{
        System.out.println(i.next());
    @}
@}
@end example

And here is a naive attempt at writing it using generics (and the new
@kbd{for loop} syntax):

@example
    for (Object e : c) @{
        System.out.println(e);
    @}
@}
@end example

The problem is that this new version is much less useful than the old
one. Whereas the old code could be called with any kind of collection as a
parameter, the new code only takes @code{Collection<Object>}, which, as we've
just demonstrated, is @emph{not} a supertype of all kinds of collections!

So what is the supertype of all kinds of collections? It's written
@kbd{Collection<?>} (pronounced @dfn{collection of unknown}), that is, a
collection whose element type matches anything. It's called a @dfn{wildcard
type}.  We can write:

@example
void printCollection(Collection<?> c) @{
    for (Object e : c) @{
        System.out.println(e);
    @}
@}
@end example

and now, we can call it with any type of collection.  Notice that inside
@code{printCollection()}, we can still read elements from @code{c} and give
them type @code{Object}. This is always safe, since whatever the actual type
of the collection, it does contain objects. It isn't safe to add arbitrary
objects to it however:

@example
Collection<?> c = new ArrayList<String>();
c.add(new Object()); // Compile time error
@end example

Since we don't know what the element type of @code{c} stands for, we cannot
add objects to it. The @code{add()} method takes arguments of type @code{E},
the element type of the collection. When the actual type parameter is
@code{?}, it stands for some unknown type. Any parameter we pass to
@code{add} would have to be a subtype of this unknown type. Since we don't
know what type that is, we cannot pass anything in. The sole exception is
@code{null}, which is a member of every type.

On the other hand, given a @code{List<?>}, we can call @code{get()} and make
use of the result. The result type is an unknown type, but we always know
that it is an object. It is therefore safe to assign the result of
@code{get()} to a variable of type @code{Object} or pass it as a parameter
where the type @code{Object} is expected.

@c .....................................

@node Wildcard Syntax
@subsection Wildcard Syntax
@cindex wildcard syntax

Sometimes type safety can get in the way of perfectly acceptable constructs.
In such cases, there is a @dfn{wildcard} argument that can be used.  The
wildcard argument is specified by the @kbd{?}, and it represents an unknown
type.  It would be used in place of a type parameter, for example:

@example
boolean sameAvg(Stats<?> ob) @{
  if(average() == ob.average())
    return true;

  return false;
@}
@end example

Here, @samp{Stats<?>} matches any @code{Stats} object (@code{Integer},
@code{Double}), allowing any two @code{Stats} objects to have their averages
compared.  The wildcard does not affect what type of @code{Stats} object can
be created.  That is governed by the @command{extends} clause in the
@code{Stats} declaration.  The wildcard simply matches any @emph{valid}
@code{Stats} object.

@c .....................................

@node Bounded Wildcards
@subsection Bounded Wildcards
@cindex wildcards, bounded
@cindex bounded wildcards

Wildcard arguments can be bounded in much the same way that a type parameter
can be bounded (the @dfn{bounded wildcard argument}.  A bounded wildcard is
especially important when you are creating a generic type that will operate
on a class hierarchy.

A bounded wildcard specifies either an upper bound or a lower bound for the
type argument.  This enables you to restrict the types of objects upon which
a method will operate.

@c _____________________________________

@subsubheading Upper Bounded Wildcard
@cindex bounded wildcards, upper bound
@cindex upper bounded wildcard

The most common bounded wildcard is the upper bound, which is created using
an @command{extends} clause.In general, to establish an upper bound for a
wildcard, use the following type of wildcard expression:
@cindex bounded wildcards, upper bound
@cindex upper bound wildcard argument

@float GeneralForm,UpperBoundedWildcard
@display
<? extends @ii{superclass}>
@end display
@caption{General Form of Upper Bounded Wildcard Syntax}
@shortcaption{Upper Bounded Wildcard}
@end float

where @ii{superclass} is the name of the class that serves as the upper
bound.  This is an inclusive clause.

@c _____________________________________

@subsubheading Lower Bounded Wildcard
@cindex bounded wildcards, lower bound
@cindex lower bounded wildcard

You can also specify a lower bound for a wildcard by adding a @command{super}
clause to a wildcard declaration.  Here is its general form:

@float GeneralForm,LowerBoundedWildcard
@display
<? super @ii{subclass}>
@end display
@caption{General Form of Lower Bounded Wildcard Syntax}
@shortcaption{Lower Bounded Wildcard}
@end float

Only classes that are superclasses of @ii{subclass} are acceptable arguments


@c -----------------------------------------------------------------------------

@node Generic Methods
@section Creating a Generic Method
@cindex generic method, creating
@cindex creating generic method

It is possible to declare a generic method that uses one or more type
parameters of its own.  It is also possible to create a generic method that
is enclosed within a non-generic class.

@subheading Generalized Form

@float GeneralForm,GenericMethod
@display
< @ii{type-param-list} > @ii{ret-type} @ii{meth-name} ( @ii{param-list} ) @{ @dots{}
@end display
@caption{General Form for Declaring a Generic Method}
@shortcaption{Generic Method Declaration}
@end float

@c .....................................

@node Example of Generic Method
@subsection Example of Generic Method
@cindex generic method, example
@cindex example generic method
@pindex @file{GenMethDemo.java}

The following program declares a non-generic class called @code{GenMethDemo}
and a static @strong{generic method} within that class called @code{isIn()}.
The @code{isIn()} method determines if an object is a member of an array.  It
can be used with any type of object and array as long as the array contains
objects that are compatible with the type of the object being sought.

@(GenMethDemo.java@)=
class GenMethDemo {
  @<Static Method isIn@>
  @<GenMethDemo Main@>
}
@

@c _____________________________________

@node Method isIn
@subsubsection Method isIn()

The @strong{type parameters} are declared @emph{before} the return type of
the method.

@<Static Method isIn@>=
static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {

  for (int i = 0; i < y.length; i++)
    if (x.equals(y[i]) return true;

  return false;
}

@

The type @ii{T} is @strong{upper-bounded} by the @code{Comparable} interface,
which must be of the same type as @ii{T}.  Likewise, the second type, @ii{V},
is also @strong{upper-bounded} by @ii{T}.  Thus, @ii{V} must be either the
same type as @ii{T} or a subclass of @ii{T}.  This relationship enforces that
@code{isIn()} can be called only with arguments that are compatible with each
other.

@cindex generic method, static
@cindex static generic method
While @code{isIn()} is static in this case, generic methods can be either
static or non-static; there is no restriction in this regard.

@subsubheading Explicitly Including Type Arguments
@cindex generic methods, including type arguments

There is generally no need to specify type arguments when calling this method
from within the @code{main} routine.  This is because the type arguments are
automatically discerned, and the types of @ii{T} and @ii{V} are adjusted
accordingly.

Although type inference will be sufficient for most generic method calls, you
can explicitly specify the type argument if needed.  For example, here is how
the first call to @code{isIn()} looks when the type argumetns are specified:

@example
GenMethDemo.<Integer, Integer>isIn(2, nums)
@end example

@c _____________________________________

@node GenMethDemo Main
@subsubsection GenMethDemo Main

@<GenMethDemo Main@>=
public static void main(String args[]) {

  // call isIn() with Integer type
  Integer nums[] = { 1, 2, 3, 4, 5 };

  if ( isIn(2, nums) )
    System.out.println("2 is in nums");

  if ( @isIn(7, nums))
    System.out.println("7 is not in nums");

  System.out.println();

  // call isIn() with String type
  String strs[] = { "one", "two", "three", "four", "five" };

  if ( isIn("two", strs))
    System.out.println("two is in strs");

  if ( !isIn("seven", strs))
    System.out.println("seven is not in strs");

  // call isIn() with mixed types
  // WILL NOT COMPILE! TYPES MUST BE COMPATIBLE
  // if ( isIn("two", nums))
  //    System.out.println("two is in nums");
}

@


@c -----------------------------------------------------------------------------

@node Generic Constructors
@section Generic Constructors
@cindex generics, generic constructors
@cindex generic constructors

It is possible for constructors to be generic, even if their class is not
(@pxref{generics-constructor}). The syntax is the same (type parameters come
first).

@display
< @ii{type-param-list}> @ii{constructor-name} ( @ii{param-list} ) @{ @dots{}
@end display




@c *****************************************************************************

@node Enumerations
@chapter Enumerations
@cindex Enumerations
@cindex JDK 5
@cindex @command{final}, traditional enums
@cindex enumeration object
@cindex data type, enumeration
@cindex enumeration capabilities

Enumerations were added by JDK 5.  In earlier versions of Java, enumerations
were implemented using @command{final} variables.

An @dfn{enumeration} is a list of named constants that define a new data type
and its legal values.  In other words, an enumeration defines a class type.
An @dfn{enumeration object} can only hold values that were declared in the
list.  Other values are not allowed.  An enumeration allows the programmer to
define a set of values that a data type can legally have.

By making enumerations classes, the capabilities of the enumeration are
greatly expanded.  An enumeration can have:

@itemize
@item
constructors
@item
methods
@item
instance variables
@end itemize

@node Enumeration Basics
@section Enumeration Basics
@cindex Enumeration, basics
@cindex keyword, @code{enum}

An enumeration is created using the @code{enum} keyword.

@example
enum Apple @{
     Jonathon, GoldenDel, RedDel, Winesap, Cortland
@}
@end example

@subheading enumeration constants

@cindex enumeration constants
@cindex self-typed constants
The enum constants @samp{Jonathon}, @samp{GoldenDel}, etc. are called
@dfn{enumeration constants}.  The enumeration constants are declared as
@samp{public static final} members of the enum.  Their type is the type of
the enumeration in which they are declared.  These constants are called
@dfn{self-typed}, in which ``self'' refers to the enclosing enumeration.  

@subheading enumeration objects
@cindex enumeration variable
@cindex variable, enum type
@cindex enum variable, declare

You can create a variable of an enumeration type.  You do not
instantiate an @code{enum} using @command{new}.  Rather, you declare
an @code{enum} variable like you do for primitive types: @samp{Apple
ap}.  Now, the variable @code{ap} can only hold values of type
@samp{Apple}.

@example
Apple ap;
ap = Apple.RedDel;
@end example

The @code{enum} type (i.e., @code{Apple}) must be part of the expression.

@subheading Comparing for Equality; Switch
@cindex enumeration comparison
@cindex equality, enum types
@cindex @code{==}
@cindex @command{switch} statement, enum types

Two enumeration constants can be compared for equality using the @code{==}
relational operator.  Furthermore, an enumneration value can be used to
control a @command{switch} statement.  The @code{enum} prefix (type) is not
required for @command{switch}.

@example
switch(ap) @{
  case Jonathon: @dots{}
  case Winesap: @dots{}
@}
@end example

@subheading Printing Enum Types
@cindex enums, printing

When an enumeration object is printed, its name is output (without the
@code{enum} type): @samp{System.out.println(ap)} would produce
@samp{RedDel}.

@node Enum Methods
@section Enum Methods @command{values()} and @command{valueOf()}
@cindex enumeration methods
@cindex methods, enumeration
@cindex enum @command{values()}
@cindex enum @command{valueOf()}

All enumerations inherit two methods:

@deftypemethod Enum {public static @ii{enum-type}[]} values ()
The @command{values()} method returns an array that contains a list of the
enumeration constants.
@end deftypemethod

@deftypemethod Enum {public static @ii{enum-type}} valueOf (String @var{str})
The @command{valueOf()} method returns the enumeration constant whose value
corresponds to the string passed in @var{str}.
@end deftypemethod

@subheading Examples using @command{values()} and @command{valueOf()} Methods

@noindent
@samp{Apple allapples[] = Apple.values();} is an example of using the
@command{values()} method to populate an array with enumeration constants.

@example
for(Apple a : Apple.values()) @{
  System.out.println(a);
@}
@end example

@noindent
is an example of iterating directly on the @command{values()} method.

@example
Apple ap;
ap = Apple.valueOf("Winesap");
System.out.println("ap contains " + ap);
@end example

@noindent
is an example of using the @command{valueOf()} method to obtain the
enumeration constant corresponding to the value of a string.

@node Enumerations as Class Types
@section Java Enumerations are Class Types
@cindex enumerations as class types
@cindex enumeration constructor
@cindex enumeration instance variables
@cindex enumeration methods
@cindex enumeration constants

A Java enumeration is a class type.  That is, @code{enum} defines a class,
which has much the same capabilities as other classes.  An enumeration can be
given constructors, instance variables, and methods.  It can even implement
interfaces.  Each enumeration constant is an object of its enumeration type.
When an enumeration is given a constructor, the constructor is called when
each enumeration constant is created.  Also, each enumeration constant has
its own copy of any instance variables defined by the enumeration.

@example
enum Apple @{
  Jonathon(10), GoldenDel(9), RedDel(12), Winesap(15), Cortland(8);
  private int price;
  Apple(int p) @{ price = p; @}
  int getPrice() @{ return price; @}
@}

class EnumDemo @{
  public static void main (String[] args) @{
    Apple ap;
  @}
@}
@end example

In this example, the enumeration @samp{Apple} is given an instance variable
@code{price}, a constructor, and an instance method @samp{getPrice()}.  When
the variable @samp{ap} is declared in @samp{main()}, the constructor for
@samp{Apple} is called once for each constant that is specified.  The
arguments to the constructor are placed in parentheses after the name of each
constant.  Thereafter, each enumeration constant has its own copy of
@samp{price}, which can be obtained by calling the instance method
@samp{getPrice()}.  In addition, there can be multiple overloaded
constructors just as for any other class.

@subheading Restrictions on Enums
@cindex enumeration restrictions

@itemize
@item
An enumeration cannot inherit another class.
@item
An @code{enum} cannot be a superclass (@code{enum} cannot be extended).
@end itemize

The key is to remember that each enumeration constant is an object of the
class in which it is defined.

@node Inherit Enum
@section Enumerations Inherit @code{Enum}
@cindex enumerations inherit @code{Enum}

All enumerations automatically inherit from one superclass:
@code{java.lang.Enum}.  This class defines several methods  that are
available for use by all enumerations.

@subheading @code{ordinal()} and @code{compareTo()}

@deftypemethod Enum {final int} ordinal ()
The @code{ordinal()} method returns a value that indicates an enumeration
constant's position in the list of constants, called its @dfn{ordinal
value}.  In other words, calling @code{ordinal()} returns the ordinal value
of the invoking constant (zero indexed).
@end deftypemethod

@deftypemethod Enum {final int} compareTo (@ii{enum-type} @var{e})
The ordinal values of two constants can be compared using the
@code{compareTo()} method.  Both the invoking constant and @var{e} must be of
the same enumeration @ii{enum-type}.  This method returns a negative value, a
zero, or a positive value depending on whether the invoking constant's
ordinal value is less than, equal to, or greater than the passed-in
enumeration constant's ordinal value.
@end deftypemethod

@subheading @code{equals()} and @code{==}

@deftypemethod Enum boolean equals (@ii{enum-type} @var{e})
@deftypemethodx Enum boolean == (@ii{enum-type} @var{e})
Compare for equality an invoking enum constant with a referenced enum
constant. 
@end deftypemethod


An invoking enum constant can compare for equality itself with any
other object by using @code{equals()} or, equivalently, @code{==}, which
overrides the @code{equals()} method defined in @code{Object}.
@code{equals()} will return true only if both objects refer to the same
constant within the same enumeration.  (In other words, @code{equals} does
not just compare ordinal values in general.)





@c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@part The Java Standard Library




@c *****************************************************************************

@node Strings
@chapter String Handling
@cindex Strings
@cindex String Handling




@c *****************************************************************************

@node java.lang
@chapter Exploring @file{java.lang}
@cindex @file{java.lang}

Classes and interfaces defined by @file{java.lang}, which is automatically
imported into all programs.  Contains classes and interfaces that are
fundamental to all of Java programming.  Beginning with JDK 9, all of
@file{java.lang} is part of the @file{java.base} module.

@subheading @file{java.lang} includes the following classes
@cindex classed in @file{java.lang}

@itemize
@item Boolean
@item Byte
@item Character
@itemize
@item Character.Subset
@item Character.UnicodeBlock
@end itemize
@item Class
@item ClassLoader
@item ClassValue
@item Compiler
@item Double
@item Enum
@item Float
@item InheritableThreadLocal
@item Integer
@item Long
@item Math
@item Module
@itemize
@item ModuleLayer
@item ModuleLayer.Controller
@end itemize
@item Number
@item Object
@item Package
@item Process
@itemize
@item ProcessBuilder
@item ProcessBuilder.Redirect
@end itemize
@item Runtime
@itemize
@item RuntimePermission
@item Runtime.Version
@end itemize
@item SecurityManager
@item Short
@item StackFramePermission
@item StackTraceElement
@item StackWalker
@item StrictMath
@item String
@itemize
@item StringBuffer
@item StringBuilder
@end itemize
@item System
@itemize
@item System.LoggerFinder
@end itemize
@item Thread
@itemize
@item ThreadGroup
@item ThreadLocal
@end itemize
@item Throwable
@item Void
@end itemize

@subheading @file{java.lang} includes the following interfaces
@cindex interfaces in @file{java.lang}

@itemize
@item Appendable
@item AutoClosable
@item CharSequence
@item Clonable
@item Comparable
@item Iterable
@item ProcessHandle
@itemize
@item ProcessHandle.Info
@end itemize
@item Readable
@item Runnable
@item StackWalker.StackFrame
@item System.Logger
@item Thread.UncaughtExceptionHandler
@end itemize


@c -----------------------------------------------------------------------------

@node Primitive Wrappers
@section Primitive Type Wrappers
@cindex Primitive Wrappers
@cindex Wrappers, Primitives
@cindex type wrappers

Java uses primitive types for @samp{int}, @samp{char}, etc. for performance
reasons.  These primitives are not part of the object hierarchy; they are
passed by-value, not by reference.  Sometimes you may need to create an
object representation for a primitive type.  To store a primitive in a
class, you need to wrap the primitive type in a class.

Java provides classes that correspond to each of the primitive types.
These classes encapsulate or @dfn{wrap} the primitive types within a
class.  They are commonly referred to as @dfn{type wrappers}.

@c .....................................

@node Number
@subsection Number

@c .....................................

@node Double and Float
@subsection Double and Float

@c .....................................

@node isInfinite() and isNaN()
@subsection isInfinite() and isNaN()

@c .....................................

@node Byte Short Integer Long
@subsection Byte, Short, Integer, Long

@c .....................................

@node Numbers to from String
@subsection Converting Numbers to and from String




@c -----------------------------------------------------------------------------

@node Iterable Interface
@section The @file{Iterable} Interface
@cindex @file{Iterable} Interface
@cindex @code{for} loop, for-each version
@cindex for-each version of @code{for} loop
@cindex @file{Iterator} iterator

@file{Iterable} must be implemented by any class whose objects will be used
by the for-each version of the @code{for} loop.  In other words, for
an object to be used within a for-each style @code{for} loop, its class must
implement @file{Iterable}.  @file{Iterable} is a generic interface that has
this declaration:

@display
interface Iterable<T>
@end display

Here, @code{T} is the type of the object being iterated.  It defines one
abstract method, @code{iterator()}, which is declared as:

@display
Iterator<T> iterator()
@end display

It returns an iterator to the elements contained in the invoking object.

@subheading @file{Iterable} Default Methods

@subsubheading @code{forEach()}

Beginning with JDK 8, @file{Iterable} also defines two default methods.  The
first is called @code{forEach()}:

@display
default void forEach(Consumer<? super T> @ii{action})
@end display
@cindex @file{Consumer}
@cindex JDK 8
@cindex @file{java.util.function}

For each element being iterated, @code{forEach()} executes the code specified
by @ii{action}.  (@file{Consumer} is a functional interface added by JDK 8
and defined in @file{java.util.function}.)

@subsubheading @code{spliterator()}
@cindex @code{spliterator()}

The second default method is @code{spliterator()}:

@display
default Spliterator<T> spliterator()
@end display

It returns a @file{Spliterator} to the sequence being iterated.



@c *****************************************************************************

@node java.util Part 1 --- Collections Framework
@chapter @file{java.util} Part 1: The Collections Framework
@cindex @file{java.util} Collections Framework

The package @file{java.util} contains a large assortment of classes and
interfaces that support a braod range of functionality.  For example,
@file{java.util} has classes that

@itemize
@item
generate pseudorandom numnbers,
@item
manage date and time,
@item
observe events,
@item
manipulate sets of bits,
@item
tokenize strings, and
@item
handle formatted data
@end itemize

@heading Collections Framework
@cindex Collections Framework
@cindex JDK 9

The @file{java.util} package also contains one of Java's most powerful
subsystems: the Collections Framework.  This is a sophisticated hierarchy of
interfaces and classes that provide state-of-the-art technology for managing
groups of objects.  Beginning with JDK 9, @file{java.util} is part of the
@file{java.base} module.


@c -----------------------------------------------------------------------------

@node Collections Overview
@section Collections Overview
@cindex Collections overview
@cindex J2SE 1.2
@cindex @file{Dictionary}
@cindex @file{Vector}
@cindex @file{Stack}
@cindex @file{Properties}

The Java Collections Framework standardizes the way in whcih groups of
objects are handled by programs.  Collections were not part of the original
Java release, but were added by J2SE 1.2.  Prior to the Collections
Framework, Java provided ad hoc classes such as @file{Dictionary},
@file{Vector}, @file{Stack}, and @file{Properties} to stored and manipulate
groups of objects.  These classes lacked a central unifying theme.  The way
that you used @file{Vector} was different from the way that you used
@file{Properties}.  This early, ad hoc approach was not designed to be easily
extended or adapted.  Collections were an answer to these (and other)
problems.

@subheading Collections Goals
@cindex Collections Framekwork goals

The Collections Framework was designed to meet several goals.  @emph{First},
the framework had to be high-performance.  The implementations for the
fundamental collections (dynamic arrays, linked lists, trees, and hash
tables) are highly efficient.  You seldom, if ever, need to code one of these
``data engines'' manually.  @emph{Second}, the framework had to allow
different types of collections to work in a similar manner and with a high
degree of interoperability.  @emph{Third}, extending and/or adapting a
collection had to be easy.  Toward this end, the entire Collections Framework
is built upon a set of standard interfaces.  Several standard implementations
(such as @file{LinkedList}, @file{HashSet}, and @file{TreeSet} of these
interfaces are provided that you may use as-is.  You may also implement your
own collection.  Various special-purpose implementations are created for your
convenience, and some partial implementations are provided that make creating
your own collection class easier.  @emph{Finally}, mechanisms were added that
allow the integration of standard arrays into the Collections Framework.

@enumerate
@item
high-performance
@item
interoperatibility
@item
standard interfaces and implementations; easily extensibible
@item
integration of arrays
@end enumerate

@subheading Algorithms
@cindex Algorithms, Collections Framework

@dfn{Algorithms} are another important part of the collection mechanism.
Algorithms operate on collections and are defined as static methods within
the @file{Collections} class.  Thus, they are available for all collections.
Each collection class need not implement its own versions.  The algorithms
provide a standard means of manipulating collections.

@subheading @file{Iterator} Interface
@cindex @file{Iterator} interface
@cindex iterator

Another item closely associated with the Collections Framework is the
@file{Iterator} interface.  An @dfn{iterator} offers a general-purpose
standardized way of accessing the elements within a collection, one at a
time.  Thus, an iterator provides a means of @emph{enumerating the contents
of a collection}.  Because each collection provides an iterator, the elements
of any collection class can be accessed through the methods defined by
@file{Iterator}.  Thus, with only small changes, the code that cycles through
a set can also be used to cycle through a list.

@subheading @file{Splitarator}
@cindex @file{Spliterator}
@cindex @file{PrimitiveIterator}
@cindex @file{PrimitiveIterator.OfDouble}
@cindex JDK 8
@cindex primitive type iterators
@cindex iterators, primitive types

JDK 8 added another type of iterator called a @dfn{spliterator}.  These are
iterators that provide support for parallel iteration.  The interfaces that
support spliterators are @file{Spliterator} and several nested interfaces
that support primitive types.  JDK 8 also added iterator interfaces designed
for use with primitive types such as @file{PrimitiveIterator} and
@file{PrimitiveIterator.OfDouble}.  

@subheading Map Interfaces and Classes
@cindex maps
@cindex collection-view of a map

In addition to collections, the framework defines several map interfaces and
classes.  @dfn{Maps} store key/value pairs.  Although maps are part of the
Collections Framework, they are not ``collections'' in the strict use of the
term.  You can, however, obtain a @dfn{collection-view} of a map.  Such a
view contains the elements from the map stored in a collection.  Thus, you
can process the contents of a map as a collection.


@c -----------------------------------------------------------------------------

@node Collection Interfaces
@section The Collection Interfaces
@cindex Collection Interfaces

The Collections Framework defines several core interfaces.  Beginning with
the collection interfaces is necessary because they determine the fundamental
nature of the collection classes.  The concrete classes simply provide
different implementations of the standard interfaces.  The interfaces that
underpin collections are summarized:

@float Table,CollectionsInterfaces
@table @file
@item Collection
Enables you to work with groups of objects; it is at the top of the
collections hierarchy.
@item Deque
Extends @file{Queue} to handle a double-ended queue.
@item List
Extends @file{Collection} to handle sequences (lists of objects).
@item NavigableSet
Extends @file{SortedSet} to handle retrieval of elements based on
closest-match searchesl.
@item Queue
Extends @file{Collection} to handle special types of lists in which elements
are removed only from the head.
@item Set
Extends @file{Collection} to handle sets, which must contain unique elements.
@item SortedSet
Extends @file{Set} to handle sorted sets
@end table
@caption{Summary of @file{Collection} Interfaces}
@end float

In addition to the collection interfaces, collections also use the following
interfaces:  

@itemize
@item
@file{Comparator} (defines how two objects are compared)
@item
@file{RandomAccess} (indicates that a collection supports efficient random
access to its elements)
@item
@file{Iterator} (the iterators enumerate the objects within a collection)
@item
@file{ListIterator}
@item
@file{Spliterator}
@end itemize

@subheading Optional Interface Methods --- Modifiable Collections
@cindex modifiable collections
@cindex unmodifiable collections
@cindex UnsupportedOperationException

To provide the greatest flexibility  in their use, the collection interfaces
allow some methods to be optional.  The optional methods enable you to modify
the contents of a collection.  Collections that support these methods are
called @dfn{modifiable}.  Collections that do not allow their contents to be
changed are called @dfn{unmodifiable}.  If an attempt is made to use one of
these methods on an unmodifiable collection, an
@file{UnsupportedOperationException} is thrown.  All of the built-in
collections are modifiable.  

@c .....................................

@node Collection Interface
@subsection The @file{Collection} Interface
@cindex @file{Collection} interface

The @file{Collection} interface is the foundation upon which the Collections
Framework is build because it must be implemented by any class that defines a
collection.  @file{Collection} is a generic interface that has this
declaration:

@display
interface Collection<E>
@end display

Here, @code{E} specifies the type of objects that the collection will hold.
@file{Collections} extends the @file{Iterable} interface.  This means that
all collections can be cycled through by use of their for-each style
@code{for} loop.  (Only classes that implement @file{Iterable} can be cycled
through by the @code{for}.  @xref{Iterable Interface}.)

@subheading Collection Core Methods

@file{Collection} declares the core methods that all collecitons will have.
These methods are summarized in @ref{CollectionsCoreMethods}.  Because all
collections implement @file{Collection}, familiarity with its methods is
necessary for a clear understanding of the framework.  Several of these
methods can throw an @file{UnsupportedOperationException}.  This occurs if a
collection cannot be modified.  A @file{ClassCastException} is generated when
one object is incompatible with another, such as when an attempt is made to
add an incompatible object to a collection.  A @file{NullPointerException} is
thrown if an attempt is made to store a @code{null} object and @code{null}
elements are not allowed in the collection.  An
@file{IllegalArgumentException} is thrown if an invalid argument is used.  An
@file{IllegalStateException} is thrown if an attempt is made to add an
element to a fixed-length collection that is full.

@float Table,CollectionsCoreMethods
@multitable @columnfractions 0.4 0.6
@item
boolean add(E @ii{obj}) @tab Adds @ii{obj} to the invoking collection.
Returns @code{true} if @ii{obj} was added to the collection.  Returns
@code{false} if @ii{obj} is already a member of the collection and the
collection does not allow duplicates
@item
boolean addAll(Collection<? extends E> @ii{c}) @tab Adds all the elements of
@ii{c} to the invoking collection.  Returns @code{true} if the collection
changed (i.e., the elements were added).  Otherwise, returns @code{false}.
@end multitable
@caption{The Methods Declared by @file{Collection}}
@FIXME{continue adding methods}
@end float

@subheading Adding and Removing Objects to and from Collections
@cindex @code{add()}
@cindex @code{addAll()}
@cindex @code{remove()}
@cindex @code{removeAll()}
@cindex @code{retainAll()}
@cindex @code{removeIf()}
@cindex @code{clear()}

Objects are added to a collection by calling @code{add()}  Notice that
@code{add()} takes an argument of type @code{E}, whcih means that objects
added to a collection must be compatible with the type of data expected by
the collection.  You can add the entire contents of one collection to another
by called @code{addAll()}.

You can remove an object by using @code{remove()}.  To remove a group of
objects, call @code{removeAll()}.  You can remove all elements except those
of a specified group by calling @code{retainAll()}.  To remove an element
only if it satisfies some condition,you cna use @code{removeIf()}.  To empty
a collection, call @code{clear()}.

@subheading Determine Whether a Collection Contains an Object
@cindex @code{contains()}
@cindex @code{containsAll()}
@cindex @code{isEmpty()}
@cindex @code{size()}

You can determine whether a collection contains a specific object by calling
@code{contains()}.  To determine whether one collection contains all the
members of another, call @code{containsAll()}.  You can determine when a
collection is empty by calling @code{isEmpty()}.  The number of elements
currently held in a collection can be determined by calling @code{size()}.

@subheading @code{toArray()} Methods
@cindex @code{toArray()}

@display
Object[] toArray()
<T> T[] toArray(T @ii{array}[])
@end display

The @code{toArray()} methods return an array that contains the elements
stored in the collection.  The first returns an array of @file{Object}.  The
second returns an array of elements that have the same type as the array
specified as a parameter.  Normally, the second form is more convenient
because it returns the desired array type.  Often, processing the contents of
a collection by using array-like syntax is advantageous.  By providing a
pathway between collections and arrays, you have the best of both.

@subheading Comparing Collections
@cindex @code{equals()}

Two collections can be compared for equality by called @code{equals()}.  The
precise meaning of ``equality'' may differ from collection to collection.  

@subheading Collection Iterators
@cindex @code{iterator()}
@cindex @code{spliterator()}
@cindex @code{stream()}
@cindex @code{parallelStream()}
@cindex @file{Stream}

Another important method is @code{iterator()}, which returns an iterator to a
collection.  The @code{spliterator()} methods returns a spliterator to the
collection.  Iterators are frequently used when working with collections.
Finally, the @code{stream()} and @code{parallelStream()} methods return a
@file{Stream} that uses the collection as a source of elements.

@c .....................................

@node List Interface
@subsection The @file{List} Interface
@cindex @file{List} interface

@c .....................................

@node Set Interface
@subsection The @file{Set} Interface
@cindex @file{Set} Interface

@c .....................................

@node SortedSed Interface
@subsection The @file{SortedSet} Interface
@cindex @file{SortedSet} interface

@c .....................................

@node NavigableSet Interface
@subsection The @file{NavigableSet} Interface
@cindex @file{NavigableSet} interface

@c .....................................

@node Queue Interface
@subsection The @file{Queue} Interface
@cindex @file{Queue} interface

@c .....................................

@node Dequeue Interface
@subsection The @file{Dequeue} Interface
@cindex @file{Dequeue} Interface


@c -----------------------------------------------------------------------------

@node Collection Classes
@section The Collection Classes
@cindex Collection Classes

Some collection classes provide full implementations that can be used as-is.
Others are abstract, providing skeletal implementations that are used as
starting points for creating concrete collections.  As a general rule, the
collection classes are not synchronized, but it is possible to obtain
synchronized version.

@heading Core Collection Classes

@float Table,CollectionCoreClasses
@multitable @columnfractions 0.4 0.6
@item
AbstractCollection @tab Implements most of the @file{Collections} interface
@item
AbstractList @tab Extends @file{AbstractCollection} and implments most of the
@file{List} interface
@item
AbstractQueue @tab Extends @file{AbstractCollection} and implements parts of
the @file{Queue} interface
@item
@FIXME{Complete entering Classes}
@end multitable
@caption{Collection Core Classes}
@end float




@c -----------------------------------------------------------------------------

@node Accessing a Collection via Iterator
@section Accessing a Collection via an Interator
@cindex Iterator, accessing a Collection

Often you will want to cycle through the elements in a
collection. @footnote{Beginning with JDK 8, you can also use a
@file{Spliterator} to cycle through a collection.  It is described later in
this chapter in @ref{Spliterators}.}  One way to do this is to employ
an @dfn{iterator}, which is an object that implements either the
@file{Iterator} of the @file{ListIterator} interface.  @file{Iterator}
enables you to cycle through a collection, obtaining or removing elements.
@file{ListIterator} extends @file{Iterator} to allow bidirectional traversal
of a list, and the modification of elements.  @file{Iterator} and
@file{ListIterator} are generic interfaces which are declared as shown:

@display
interface Iterator<E>
interface ListIterator<E>
@end display

@noindent
Here, @code{E} specifies the type of objects being iterated.  The
@file{Iterator} interface declares the methods shown in
@ref{IteratorMethods}, while the @file{ListIterator} methods are shown in
@ref{ListIteratorMethods}.  In both cases, operations which modify the
underlying collections are optional.

@float Table,IteratorMethods
@multitable @columnfractions 0.4 0.6
@item
default void forEachRemaining(Consumer<? super E> @ii{action}) @tab The
action specified by @ii{action} is executed on each unprocessed element in
the collection.  (Added by JDK 8.)
@item
boolean hasNext() @tab Returns @code{true} if there are more elements.
Otherwise, returns @code{false}.
@item
E next() @tab Returns the next element.  Throws @file{NoSuchElementException}
if there is not a next element.
@item
default void remove() @tab Removes the current element.  Throws
@file{IllegalStateException} if an attempt is made to call @code{remove()}
that is not preceded by a call to @code{next()}.  The default version throws
an @file{UnsupporterdOperationException}.
@end multitable
@caption{The Methods Provided by @file{Iterator}}
@end float

@float Table,ListIteratorMethods
@multitable @columnfractions 0.4 0.6
@item
void add(E @ii{obj}) @tab Inserts @ii{obj} into the list in front of the
element that will be returned by the next call to @code{next()}.
@item
default void forEachRemaining(Consumer<? super E> @ii{action}) @tab The
action specified by @ii{action} is executed on each unprocessed element in
the collection.  (Added by JDK 8.)
@item
boolean hasNext() @tab Returns @code{true} if there is a next element.
Otherwise returns @code{false}.
@item
boolean hasPrevious() @tab Returns @code{true} if there is a previous
element.  Otherwise returns @code{false}.
@item
E next() @tab Returns the next element.  A @file{NoSuchElementException} is
thrown if there is not a next element.
@item
int nextIndex() @tab Returns the index of the next element.  If there is not
a next element, returns the size of the list.
@item
E previous() @tab Returns the previous element.  A
@file{NoSuchElementException} is thrown if there is not a previous element.
@item
int previousIndex() @tab Returns the index of the previous element.  If there
is not a previous element, returns -1.
@item
void remove() @tab Removes the current element from the list.  An
@file{IllegalStateException} is thrown if @code{remove()} is called before
@code{next()} or @code{previous()} is invoked.
@item
void set(E @ii{obj}) @tab Assigns @ii{obj} to the current element.  This is
the element last returned by a call to either @code{next()} or
@code{previous()}.  
@end multitable
@caption{The Methods Declared by @file{ListIterator}}
@end float


@c .....................................

@node Using an Iterator
@subsection Using an Iterator
@cindex iterator, using

You must obtain an iterator to access a collection through iteration.  Each
of the collection classes provides an @code{iterator()} method that returns
an iterator to the start of the collection.  By using this iterator object,
you can access each element in the collection, one element at a time.

@subheading Process To Cycle Through the Contents of a Collection
@cindex iterator process
@cindex @code{iterator()} method
@cindex @code{listIterator()} method
@cindex @code{hasNext()}
@cindex @code{next()}

@enumerate
@item
Obtain an iterator to the start of the collection by calling the collection's
@code{iterator()} method;
@item
Set up a loop that makes a call to @code{hasNext()}.  Have the loop iterate
as long as @code{hasNext()} returns @code{true};
@item
Within the loop, obtain each element by calling @code{next()}.
@end enumerate

For collections that implement @file{List}, you can obtain an iterator by
calling @code{listIterator()}.  A list iterator gives you the ability to
access a collection in either the forward or backward direction and lets you
modify an element.  Otherwise, @file{ListIterator} is used just like
@file{Iterator}.

@subsubheading Iterator Example
@pindex @file{IteratorDemo.java}

The follwoing example implements these steps, demonstrating both the
@file{Iterator} and @file{ListIterator} interfaces.  The general principles
apply to any type of collection.

@(IteratorDemo.java@)=
@<Import java.util@>

class IteratorDemo {
  public static void main (String[] args) {
    @<IteratorDemo---Create an Array List@>
    @<IteratorDemo---Use Iterator To Display Contents of Array List@>
    @<IteratorDemo---Modify Objects Being Iterated@>
    @<IteratorDemo---Use ListIterator to Display Modified Contents@>
    @<IteratorDemo---Display the List Backwards@>
  }
}

@

@c _____________________________________

@node Import java.util
@subsubsection Import java.util

@<Import java.util@>=
import java.util.*;

@

@c _____________________________________

@node IteratorDemo---Create an Array List
@subsubsection IteratorDemo---Create an Array List

@<IteratorDemo---Create an Array List@>=
ArrayList<String> al = new ArrayList<String>();

al.add("C");
al.add("A");
al.add("E");
al.add("B");
al.add("D");
al.add("F");

@

@c _____________________________________

@node IteratorDemo---Use Iterator To Display Contents of Array List
@subsubsection IteratorDemo---Use Iterator To Display Contents of Array List

@<IteratorDemo---Use Iterator To Display Contents of Array List@>=
System.out.print("Original contents of al: ");

Iterator<String> itr = al.iterator();

while (itr.hasNext()) {
12  String element = itr.next();
  System.out.print(element + " ");
}
System.out.println();

@

@c _____________________________________

@node IteratorDemo---Modify Objects Being Iterated
@subsubsection IteratorDemo---Modify Objects Being Iterated

@<IteratorDemo---Modify Objects Being Iterated@>=
ListIterator<String> litr = al.listIterator();

while (litr.hasNext()) {
  String element = litr.next();
  litr.set(element + "+");
}

@

@c _____________________________________

@node IteratorDemo---Use ListIterator to Display Modified Contents
@subsubsection IteratorDemo---Use ListIterator to Display Modified Contents

@<IteratorDemo---Use ListIterator to Display Modified Contents@>=
System.out.print("Modified contents of al: ");

itr = al.iterator();

while (itr.hasNext()) {
  String element = itr.next();
  System.out.print(element + " ");
}
System.out.println();

@

@c _____________________________________

@node IteratorDemo---Display the List Backwards
@subsubsection IteratorDemo---Display the List Backwards

@<IteratorDemo---Display the List Backwards@>=
System.out.print("Modified list backwards: ");

while (litr.hasPrevious()) {
  String element = litr.previous();
  System.out.print(element + " ");
}
System.out.println();

@


@c .....................................


@node ForEach Alternative to Iterators
@subsection The For-Each Alternative to Iterators
@cindex for-each alternative to iterators
@cindex @code{for} loop

If you won't be modifying the contents of a collection or obtaining elements
in reverse order, then the for-each version of the @code{for} loop is often a
more convenient alternative to cycling through a collection than is using an
iterator.  The @code{for} can cycle through any collection of objects that
implement the @file{Iterable} interface.  Because all of the collection
classes implement this inteface, they can all be operated upon by @code{for}.
The code for a @code{for} loop is substantially shorter and simpler than the
iterator-approach, but cna be used only to cycle through a collection in the
forward direction and cannot be used to modify the contents of the
collection.  

@subsubheading Example Using a @code{for} Loop
@pindex @file{ForEachDemo.java}

@(ForEachDemo.java@)=
@<Import java.util@>

class ForEachDemo {
  public static void main (String[] args) {
    @<ForEachDemo---Create an Array List For Integers@>
    @<ForEachDemo---Use for Loop to Display the Values@>
    @<ForEachDemo---Sum the Values by Using a for Loop@>
  }
}

@

@c _____________________________________

@node ForEachDemo---Create an Array List For Integers
@subsubsection ForEachDemo---Create an Array List For Integers

@<ForEachDemo---Create an Array List For Integers@>=
ArrayList<Integer> vals = new ArrayList<Integer>();

vals.add(1);
vals.add(2);
vals.add(3);
vals.add(4);
vals.add(5);

@

@c _____________________________________

@node ForEachDemo---Use for Loop to Display the Values
@subsubsection ForEachDemo---Use for Loop to Display the Values

@<ForEachDemo---Use for Loop to Display the Values@>=
System.out.print("Contents of vals: ");

for (int v : vals) {
  System.out.print(v + " ");
}
System.out.println();

@

@c _____________________________________

@node ForEachDemo---Sum the Values by Using a for Loop
@subsubsection ForEachDemo---Sum the Values by Using a for Loop

@<ForEachDemo---Sum the Values by Using a for Loop@>=
int sum = 0;

for (int v : vals) {
  sum += v;
}

System.out.println("Sum of values: " + sum);

@




@c -----------------------------------------------------------------------------

@node Spliterators
@section Spliterators
@cindex Spliterators
@cindex JDK 8
@cindex parallel iteration
@cindex parallel programming

JDK 8 added a new type of iterator called a @dfn{spliterator} that is defined
by the @file{Spliterator} interface.  A spliterator cycles through a sequence
of elements and in this regard it is similar to the iterators.  However, the
techniques required to use it differ.  Furthermore, it offers substantially
more functionality than does either @file{Iterator} or @file{ListIterator}.
Perhaps the most important aspect of @file{Spliterator} is its ability to
provide support for parallel iteration of portions of the sequence.  Thus,
@file{Spliterator} supports parallel programming.

However, you can use @file{Spliterator} even if you won't be using parallel
execution.  One reason you might want to do is because it offers a
streamlined approach that combines the @code{hasNext()} and @code{next()}
operations in one method.

@file{Spliterator} is a generic interface that is declared thus:

@display
interface Spliterator<T>
@end display

@noindent
@code{T} is the type of elements being iterated.  @file{Spliterator} declares
the methods shown in @ref{SpliteratorMethods}.


@c .....................................

@node Spliterator Methods
@subsection @file{Spliterator} Methods
@cindex @file{Spliterator} Methods

@float Table,SpliteratorMethods
@multitable @columnfractions 0.4 0.6
@item
int characteristics() @tab Returns the characteristics of the invoking
spliterator, encoded into an integer.
@item
long estimateSize() @tab Estimates the number of elements left to iterate and
returns the result.  Returns @code{Long.MAX_VALUE} if the count cannot be
obtained for any reason.
@item
default void forEachRemaining(Consumer<? super T> @ii{action}) @tab Applies
@ii{action} to each unprocessed element in the data source.
@item
default Comparator<? super T> getComparator() @tab Returns the comparator
used by the invoking spliterator or @code{null} if natural ordering is used.
If the sequence is unordered, @file{IllegalStateException} is thrown.
@item
default long getExactSizeIfKnown() @tab If the invoking spliterator is sized,
returns the number of elements left to iterate.  Returns -1 otherwise.
@item
default boolean hasCharacteristics(int @ii{val}) @tab Returns @code{true} if
the invoking spliterator has the characteristics passed in @ii{val}.  Returns
@code{false} otherwise.
@item
boolean tryAdvance(Consumer<? super T> @ii{action}) @tab Executes @ii{action}
on the next element in the iteation.  Returns @code{true} if there is a next
element.  Returns @code{false} if no elements remain.
@item
Spliterator<T> trySplit() @tab If possible, split the invoking spliterator,
returning a reference to a new spliterator for the partition.  Otherwise,
returns @code{null}.  Thus, if successful, the original spliterator iterates
over one portion of the sequence and the returned spliterator iterates over
the other portion.
@end multitable
@caption{The Methods Declared by Spliterator}
@end float


@c .....................................

@node Using Spliterator for Iteration
@subsection Using @file{Spliterator} for Basic Iteration
@cindex basic iteration using @file{Spliterator}

To use a @file{Spliterator} for basic iteration, call @code{tryAdvance()}
until it returns @code{false}.  If you will be applying the same action to
each element in the sequence, @code{forEachRemaining()} offers a streamlined
alternative.  In both cases, the action that will occur wtih each iteration
is defined by what the @file{Consumer} object does with each element.
@file{Consumer} is a functional interface that applies an action to an
object.  It is a generic functional interface declared in
@file{java.util.function}.  @file{Consumer} specifies only one abstract
method, @code{accept()}, which is:

@display
void accept(T @ii{objRef})
@end display

In the case of @code{tryAdvance()}, each iteration passes the next element in
the sequence to @ii{objRef}.  Often, the easiest way to implement
@file{Consumer} is by use of a lambda expression.

@subsubheading Example Using @file{Spliterator} for Iteration
@pindex @file{SpliteratorDemo.java}

@cartouche
The following program provides a simple example of @file{Spliterator}.  The
program demonstrates both @code{tryAdvance()} and @code{forEachRemaining()}.
These methods combine the actions of @file{Iterator}'s @code{next()} and
@code{hasNext()} methods into a single call.
@end cartouche

@(SpliteratorDemo.java@)=
@<Import java.util@>

class SpliteratorDemo {
  public static void main (String[] args) {
    @<SpliteratorDemo---Create an Array List for Doubles@>
    @<SpliteratorDemo---Use tryAdvance() to Display Contents@>
    @<SpliteratorDemo---Create New List@>
    @<SpliteratorDemo---Use forEachRemaining() to Display Contents@>
  {
}

@

@c _____________________________________

@node SpliteratorDemo---Create an Array List for Doubles
@subsubsection SpliteratorDemo---Create an Array List for Doubles

@<SpliteratorDemo---Create an Array List for Doubles@>=
ArrayList<Double> vals = new ArrayList<>();

vals.add(1.0);
vals.add(2.0);
vals.add(3.0);
vals.add(4.0);
vals.add(5.0);

@

@c _____________________________________

@node SpliteratorDemo---Use tryAdvance() to Display Contents
@subsubsection SpliteratorDemo---Use tryAdvance() to Display Contents

@<SpliteratorDemo---Use tryAdvance() to Display Contents@>=
System.out.println("Contents of vals: ");
Spliterator<Double> spltitr = vals.spliterator();

while (spltitr.tryAdvance((n) -> System.out.println(n)));

System.out.println();

@

@c _____________________________________

@node SpliteratorDemo---Create New List
@subsubsection SpliteratorDemo---Create New List

@<SpliteratorDemo---Create New List@>=
spltitr = vals.spliterator();
ArrayList<Double> sqrs = new ArrayList<>();

while (spltitr.tryAdvance((n) -> sqrs.add(Math.sqrt(n))));

@

@c _____________________________________

@node SpliteratorDemo---Use forEachRemaining() to Display Contents
@subsubsection SpliteratorDemo---Use forEachRemaining() to Display Contents

@<SpliteratorDemo---Use forEachRemaining() to Display Contents@>=
System.out.println("Contents of sqrs: ");
spltitr = sqrs.spliterator();

spltitr.forEachRemaining((n) -> System.out.println(n));

System.out.println();

@


@c .....................................

@node Spliterator Characteristics
@subsection @file{Spliterator} Characteristics
@cindex Characteristics, @file{Spliterator}
@cindex @file{Spliterator} Characteristics

Each @file{Spliterator} has a set of attributes, called
@dfn{characteristics}, associated with it.  These are defined by static
@code{int} fields in @file{Spliterator}, such as

@itemize
@item
SORTED
@item
DISTINCT
@item
SIZED
@item
IMMUTABLE
@end itemize

@noindent
to name a few.  You can obtain the characteristics by calling
@code{characteristics()}.  You can determine if a characteristic is present
by calling @code{hasCharacteristics()}.


@c .....................................

@node Spliterator Subinterfaces
@subsection @file{Spliterator} Subinterfaces
@cindex spliterator subinterfaces
@cindex @file{Spliterator.OfDouble}
@cindex @file{Spliterator.OfInt}
@cindex @file{Spliterator.OfLong}
@cindex @file{Spliterator.OfPrimitive}

There are several nested subinterfaces of @file{Spliterator} designed for use
with the primitive types @code{double}, @code{int}, and @code{long}.  These
are called

@itemize
@item
@file{Spliterator.OfDouble}, 
@item
@file{Spliterator.OfInt}, and
@item
@file{Spliterator.OfLong}.
@item
@file{Spliterator.OfPrimitive} (serves as a superinterface)
@end itemize




@c -----------------------------------------------------------------------------

@node Storing User-Defined Classes
@section Storing User-Defined Classes in Collections
@cindex User-Defined Classes, storing in Collections




@c -----------------------------------------------------------------------------

@node RandomAccess Interface
@section RandomAccess Interface
@cindex RandomAccess Interface




@c -----------------------------------------------------------------------------

@node Working with Maps
@section Working with Maps
@cindex Maps, working with




@c -----------------------------------------------------------------------------

@node Comparators
@section Comparators
@cindex Comparators




@c -----------------------------------------------------------------------------

@node Collection Algorithms
@section The Collection Algorithms
@cindex Collection Algorithms




@c -----------------------------------------------------------------------------

@node Arrays Class
@section Arrays Class
@cindex Arrays Class




@c -----------------------------------------------------------------------------

@node Legacy Classes and Interfaces
@section Legacy Classes and Interfaces
@cindex legacy classes and interfaces, Collections








@c *****************************************************************************

@node java.util Part 2 --- Utility Classes
@chapter @file{java.util} Part 2: Utility Classes
@cindex @file{java.util} Utility Classes








@c *****************************************************************************

@node  java.io --- Input/Output
@chapter Input/Output --- Exploring @file{java.io}
@cindex @file{java.io}
@cindex @file{java.nio}
@cindex stream
@cindex NIO

This chapter explores @file{java.io}, which provides support for I/O
operations.  Data is retrieved from an @emph{input} source.  The results of a
program are sent to an @emph{output} destination.  In Java, these sources or
destinations are defined very broadly.  Although physically different, these
devices are all handled by the same abstraction: the @dfn{stream}.  An I/O
stream is a logical entity that either produces or consumes information.  An
I/O stream is linked to a physical device by the Java I/O system.  All I/O
streams behave in the same manner, even if the phyiscal devices they are
linked to differ.

Beginning with version 1.4, a second I/O system was added to Java, called
@acronym{NIO} (which meant New I/O).  @acronym{NIO} is packaged in
@file{java.nio} and its subpackages.  The @acronym{NIO} is described in
@ref{java.nio --- NIO}.  




@c -----------------------------------------------------------------------------

@node I/O Classes and Interfaces
@section I/O Classes and Interfaces
@cindex I/O Classes and Interfaces


@c .....................................

@node I/O Classes
@subsection I/O Classes Defined by @file{java.io}
@cindex I/O Classes, @file{java.io}

@itemize
@item
BufferedInputStream / BufferedOutputStream
@item
BufferedReader / Buffered Writer
@item
ByteArrayInputStream / ByteArrayOutputStream
@item
CharArrayReader / CharArrayWriter
@item
Console
@item
DataInputStream / DataOutputStream
@item
File
@item
FileDescriptor
@item
FileInputStream / FileOutputStream
@item
FilePermission
@item
FileReader / FileWriter
@item
FilterInputStream / FilterOutputStream
@item
FilterReader / FilterWriter
@item
InputStream / OutputStream
@item
InputStreamReader / OutputStreamWriter
@item
LineNumberReader
@item
ObjectInputFilter.Config
@item
ObjectInputStream / ObjectOutputStream
@item
ObjectInputStream.GetField / ObjectOutputStream.PutField
@item
ObjectStreamClass
@item
ObjectStreamField
@item
PipedInputStream / PipedOutputStream
@item
PipedReader / PipedWriter
@item
PrintStream / PrintWriter
@item
PushbackInputStream / PusbbackReader
@item
RandomAccessFile
@item
Reader / Writer
@item
SequenceInputStream
@item
SerializablePermission
@item
StreamTokenizer
@item
StringReader / StringWriter
@end itemize


@c .....................................

@node I/O Interfaces
@subsection I/O Interfaces Defined by @file{java.io}
@cindex I/O Interfaces, @file{java.io}

@itemize
@item
Closeable
@item
DataInput / DataOutput
@item
Externalize
@item
FileFilter
@item
FilenameFilter
@item
Flushable
@item
ObjectInput / ObjectOutput
@item
ObjectInputFilter
@item
ObjectInputFilter.FilterInfo
@item
ObjectInputValidation
@item
ObjectStreamConstants
@item
Serializable
@end itemize




@c -----------------------------------------------------------------------------

@node File
@section File
@cindex File class
@cindex file properties

The @file{File} class does not operate on streams.  It deals directly with
files and the file system.  The @file{File} class does not specify how
information is retrieved from or stored in files; rather, it describes the
properties of a file itself.  A @file{File} object is used to obtain or
manipulate the information associated with a disk file, such as the
permissions, time, date, and directory path, and to navigate subdirectory
hierarchies.@footnote{The @file{Path} interface and @file{Files} class, part
of the @acronym{NIO} system, offer a powerful alternative to @file{File}. 
@xref{java.nio --- NIO}.}

@subheading Files and Directories in Java
@cindex files
@cindex directories
@cindex @code{list()} method for directories

Files are a primary source and destination for data within programs.  Files
are a central resource for storing persistent and shared information.  A
directory in Java is treated simply as a @file{File} with one additional
property --- a list of filenames that can be examined by the @code{list()}
method.

@subheading Constructors Used to Create @file{File} Objects
@cindex @file{File} constructors

@itemize
@item
File(String @ii{directoryPath})
@item
File(String @ii{directoryPath}, String @ii{filename})
@item
File(File @ii{dirObj}, String @ii{filename})
@item
File(URI @ii{uriObj})
@end itemize

@ii{dirObj} is a @file{File} object that specifies a directory, while
@ii{uriObj} is a @file{URI} object that describes a file.

@subheading Examples Creating Files and Directories

The following example creates three files.  The first @file{File} object is
constructed with a directory path as the only argument.  The second includes
two arguments --- the path and the filename.  The third includes the file
path assigned to @code{f1} and a filename; @code{f3} refers to the same file
as @code{f2}.

@example
File f1 = new File("/");
File f2 = new File("/", "autoexec.bat");
File f3 = new File(f1, "autoexec.bat");
@end example


@c .....................................

@node File Methods
@subsection @file{File} Methods
@cindex @file{File} methods

@file{File} defines many methods that obtain the standard properties of a
@file{File} object.

@float Table,@file{File}-Methods
@table @code
@item getName()
returns the name of the file
@item getParent()
returns the name of the parent directory
@item getPath()
@itemx getAbsolutePath()
returns the path
@item exists()
returns @code{true} if the file exists, @code{false} if it does not
@item canWrite()
@itemx canRead()
returns whether the file is writeable/readable
@item isDirectory()
returns whether the file is a directory
@item isFile()
returns whether the file is a regular file (@code{true}) or a
non-file (@code{false}) such as directory, device drivers, named
pipes, etc.
@item isAbsolute()
returns whether the file is an absolute path (@code{true}) or a
relative path (@code{false})
@item lastModified()
returns the modification date and time
@item length()
returns the file's size
@end table
@caption{@file{File} Property Methods}
@end float


@c .....................................

@node File Utility Methods
@subsection @file{File} Utility Methods
@cindex @file{File} utility methods

@float Table,@file{File}-Utility-Methods
@table @code
@item renameTo()
boolean renameTo(File @ii{newName}); returns @code{true} upon success
or @code{false} if the file cannot be renamed
@item delete()
boolean delete(); deletes a file or directory (if the directory is
empty); returns @code{true} if it successfully deletes or @code{false}
if the file or directory cannot be removed;
@item deleteOnExit()
removes the file associated with the invoking object when the Java
Virtual Machines terminates
@item getFreeSpace()
returns the number of free bytes of storage (as a @code{long})
available on the partition associated with the invoking object
@item getTotalSpace()
returns the stoarage capacity (as a @code{long}) of the partition
associated with the invoking object
@item getUsableSpace()
returns the number of usable free bytes of storage (as a @code{long})
available on the partition associated with the invoking object
@item isHidden()
returns @code{true} if the invoking file is hidden, or @code{false}
otherwise 
@item setLastModifiedTime()
sets the time stamp on the invoking file to that specified by the
arguement (@code{long} @ii{millisec}), which is the number of
milliseconds from January 1, 1970, UTC
@item setReadOnly()
sets the invoking to read-only; returns @code{true} on success
@item readable()
@itemx writeable()
@itemx executable()

@item compareTo()
because @file{File} implements the @file{Comparable} interface
@item toPath()
returns a @file{Path} object that represents the file encapsulated by
the invoking @file{File} object; (in other words, @code{toPath()}
converts a @file{File} into a @file{Path});@footnote{@code{toPath()}
forms a bridge between the older @file{File} class and the newer
@file{Path} interface; @xref{java.nio --- NIO}.}
@item mkdir()
@itemx mkdirs()
the first creates a directory, returning @code{true} on success and @code{false} on
failure; use the second to create a directory for which no path exists; it
creates both a directory and all the parents of the directory;
@end table
@caption{File Utility Methods}
@end float


@c .....................................

@node Directories
@subsection Directories
@cindex Directories
@cindex @code{list()}

A @dfn{directory} is a @file{File} that contains a list of other files
and directories.  When you create a @file{File} object that is a
directory, the @code{isDirectory()} method will return true.  In this
case, you can call @code{list()} on that object to extract the list of
other files and directories inside.  It has two forms.  Here is the more
general form:

@float GeneralForm,Directory-List
@deftypemethod File String[] list ()
@code{list()} is used to extract the list of other files and directories
inside the calling File object
@end deftypemethod
@caption{Obtaining a list of files in a directory}
@end float


@c .....................................

@node Examine Directory Contents
@subsection Using @code{list()} to Examine Directory Contents
@cindex directory contents, examine using @code{list()}
@pindex @file{DirList.java}

This program illustrates how to use @code{list()} to examine the
contents of a directory.

@(DirList.java@)=
@<Import java.io.File@>
class DirList {
  public static void main(String[] args) {
    @<DirList Instance Variable Declarations@>
    @<DirList Examine Directory Contents@>
  }
}

@

@c _____________________________________

@node Import java.io.File
@subsubsection Import @file{java.io.File}
@cindex import @file{java.io.File}

@<Import java.io.File@>=
import java.io.File;

@

@c _____________________________________

@node DirList Instance Variable Declarations
@subsubsection DirList Instance Variable Declarations

@<DirList Instance Variable Declarations@>=
@<DirList Obtain Directory From Command-Line Args@>
String dirname = args[0];
File f1 = new File(dirname);

@

@c _____________________________________

@node DirList Examine Directory Contents
@subsubsection DirList Examine Directory Contents

@<DirList Examine Directory Contents@>=
if (f1.isDirectory()) {
  System.out.println("Directory of " + dirname);

  String[] s = f1.list();

  @<DirList Examine Directory Contents For-Loop@>

} else {
  System.out.println(dirname + " is not a directory");
}

@

@c _____________________________________

@node Examine Directory Contents For-Loop
@subsubsection Examine Directory Contents For-Loop

@<DirList Examine Directory Contents For-Loop@>=
for (int i = 0; i < s.length; i++) {
  File f = new File(dirname + "/" + s[i]);

  if (f.isDirectory()) {
    System.out.println(s[i] + " is a directory");
  } else {
    System.out.println(s[i] + " is a file");
  }
}

@

@c _____________________________________

@node DirList Obtain Directory From Command-Line Args
@subsubsection DirList Obtain Directory From Command-Line Args

@<DirList Obtain Directory From Command-Line Args@>=
if (args.length != 1) {
  System.out.println("Usage: java DirList <directory>");
  return;
}

@


@c .....................................

@node FilenameFilter
@subsection Using @file{FilenameFilter}
@cindex @file{FilenameFilter}
@cindex filter directory contents
@cindex @file{FilenameFilter} interface
@cindex @code{accept()}

You can limit the number of files returned by the @code{list()} method to
include only those files that match a certain filename pattern, or
@dfn{filter}.  To do this, use a second form of list:

@float GeneralForm,Directory-List-With-Filter
@deftypemethod File String[] list (FilenameFilter @var{FFObj})
Returns an array of String filenames found in the directory named by the
calling File object
@end deftypemethod
@caption{Obtaining a filtered list of files in a directory}
@end float

Here, @ii{FFObj} is an object of a class that implements the
@file{FilenameFilter} interface.  This interface defines a single method,
@code{accept()}, whcih is called once for each file in a list.  It's general
form is given here:

@float GeneralForm,FilenameFilter.Accept
@deftypemethod FilenameFilter boolean accept (File @var{directory}, String @var{filename})
The @code{accept()} method returns @code{true} for files in the directory
specified by the @var{directory} that should be included in the list (that
is, those that match the @var{filename} argument) and returns @code{false}
for those files that should be excluded.
@end deftypemethod
@caption{@code{accept()} Form to be used with @code{list()}}
@end float

@node Example Using FilenameFilter Interface
@subsection Example Program Using FilenameFilter Interface

The @file{OnlyExt} class implements @file{FilenameFilter} by defining an
@code{accept()} method, which will be used by a variation of the preceding
program listing the contents of a directory to filter the directory listing.

@subsubheading OnlyExt Class
@pindex @file{OnlyExt.java}

@(OnlyExt.java@)=
@<Import java.io@>
public class OnlyExt implements FilenameFilter {
  @<OnlyExt Instance Variable Declarations@>
  @<OnlyExt Constructor@>
  @<OnlyExt Accept Method Implementation@>
}

@

@subsubheading DirListOnly Class

This class now @code{list()}s the directory contents by including the
@file{FilenameFilter} object from @file{OnlyExt}.

@(DirListOnly@)=
@<Import java.io@>
class DirListOnly {
  public static void main(String[] args) {
    @<DirList Obtain Directory From Command-Line Args@>
    @<DirListOnly FilenameFilter Object@>
    @<DirListOnly FilenameFilter Object List@>
    @<DirListOnly Print List@>
  }
}

@

@c _____________________________________

@node DirListOnly FilenameFilter Object
@subsubsection DirListOnly FilenameFilter Object

@<DirListOnly FilenameFilter Object@>=
FilenameFilter only = new OnlyExt("html");

@

@c _____________________________________

@node DirListOnly FilenameFilter Object List
@subsubsection DirListOnly FilenameFilter Object List

Recallthe corresopnding line in the @file{DirList} program:
@xref{DirList Examine Directory Contents}.

@<DirListOnly FilenameFilter Object List@>=
String[] s = f1.list(only);

@

@c _____________________________________

@node DirListOnly Print List
@subsubsection DirListOnly Print List

@<DirListOnly Print List@>=
for (int i = 0; i < s.length; i++) {
  System.out.println(s[i]);
}

@

@c _____________________________________

@node OnlyExt Instance Variable Declarations
@subsubsection OnlyExt Instance Variable Declarations

@<OnlyExt Instance Variable Declarations@>=
String ext;

@

@c _____________________________________

@node OnlyExt Constructor
@subsubsection OnlyExt Constructor

@<OnlyExt Constructor@>=
public OnlyExt(String ext) {
  this.ext = "." + ext;
}

@

@c _____________________________________

@node OnlyExt Accept Method Implementation
@subsubsection OnlyEct Accept Method Implementation

@<OnlyExt Accept Method Implementation@>=
public boolean accept(File dir, String name) {
  return name.endsWith(ext);
}

@


@c .....................................

@node listFiles() Alternative
@subsection @code{listFiles()} Alternative
@cindex @code{listFiles()} Alternative

There is a variation to the @code{list()} method, called @code{listFiles()},
that might be useful.

@float GeneralForm,listFiles
@deftypemethod File File[] listFiles ()
@deftypemethodx File File[] listFiles (FilenameFilter @var{FFOjb})
@deftypemethodx File File[] listFiles (FileFilter @var{FOjb})
These methods return the file list as an array of @file{File} objects instead
of Strings.  The first method returns all files, and the second returns those
files that satisfy the specified @file{FilenameFilter}.  The third version of
@code{listFiles()} returns those files with path names that satisfy the
specified @file{FileFilter}.  @file{FileFilter} defines only a single method,
@code{accept()}, whcih is called once for each file in a list.  Its general
form is shown below (@pxref{FileFilter-accept()}).
@end deftypemethod
@caption{@file{File.listFiles()} Form}
@end float

@subheading FileFilter.accept()
@cindex @file{FileFilter}.@code{accept()} method

@float GeneralForm,FileFilter-accept()
@deftypemethod FileFilter boolean accept (File @var{path})
Called once for each file in a list; it returns @code{true} for files that
should be included in the list (that is, those that match the @var{path}
argument) and @code{false} for those that should be excluded.
@end deftypemethod
@caption{FileFilter.accept() Method}
@end float

@c .....................................

@node Creating Directories
@subsection Creating Directories
@cindex Creating Directories
@cindex directories, creating

@itemize
@item
boolean mkdir()
@item
boolen mkdirs()
@end itemize


@c -----------------------------------------------------------------------------

@node AutoCloseable Closeable Flushable Interfaces
@section The @file{AutoCloseable}, @file{Closeable}, and @file{Flushable} Interfaces
@cindex @file{AutoCloseable}
@cindex @file{Closeable}
@cindex @file{Flushable}


@c -----------------------------------------------------------------------------

@node I/O Exceptions
@section I/O Exceptions
@cindex I/O Exceptions
@cindex Exceptions, I/O
@cindex @file{IOException}
@cindex @file{FileNotFoundException}
@cindex @code{catch} exception

@subheading @file{IOException} and @file{FileNotFoundException}

Two exceptions play an important role in I/O handling.  The first is
@file{IOException}.  If an I/O error occurs, an @file{IOException} is
thrown.  In many cases, if a file cannot be opened, a
@file{FileNotFoundException} is thrown.  @file{FileNotFoundException} is a
subclass of @file{IOException}, so both can be caught with a single
@code{catch} that catches @file{IOException}.  You might find it useful to
@code{catch} each exception separately.

@subheading @file{SecurityException}
@file{SecurityException}

Another exception class that could occur during I/O is
@file{SecurityException}.  In situations in which a security manager is
present, several of the file classes will throw a @file{SecurityException} if
a security violation occurs when attempting to open a file.  By default,
application run via @file{java} do not use a security manager.  Other
applications could generate a @file{SecurityExcpetion}, which will need to be
handled.  


@c -----------------------------------------------------------------------------

@node Closing a Stream
@section Two Ways to Close a Stream
@cindex closing a stream
@cindex @code{close()}
@cindex stream closing, traditional approach
@cindex @code{finally} used to close a stream

In general, a stream must be closed when it is no longer needed.  Failure to
do so can lead to memory leaks and resource starvation.

@subheading Traditional Method with @code{close()} in @code{finally}

Beginning with JDK 7, there are two basic ways in which you can close a
stream.  The first is to explicitly call @code{close()} on the stream.  This
is the traditional approach that has been used since the original release of
Java.  With this approach, @code{close()} is typically called within a
@code{finally} block.  

@float GeneralForm,CloseStreamWithClose
@display
try @{
  open and access file @dots{}
@} catch (@ii{IOException}) @{
   handle @ii{IOException} @dots{}
@} finally @{
   close the file @dots{}
@}
@end display
@caption{Simplified skeleton for traditional approach to close a stream}
@shortcaption{Traditional Stream Close}
@end float

@subheading @code{try-with-resources} Statement
@cindex @code{try-with-resources}
@cindex stream closing using @code{try-with-resources}
@cindex JDK 7, @code{try-with-resource}

The second approach to closing a stream is to automate the process by using
the @code{try-with-resources} statement added by JDK 7.  The
@code{try-with-resources} is an enhanced form of @code{try} with the
following form:

@float GeneralForm,TryWithResourcesClose
@display
try (@ii{resource-specification}) @{
  use the resource @dots{}
@}
@end display
@caption{Closing a file using @code{try-with-resources} Statement}
@shortcaption{@code{try-with-resources} Stream Close}
@end float

Typically, @emph{resource-specification} is a statement or statements that
declare and initialize a resource, such as a file or other stream-related
resource.  It consists of a variable declaration in which the variable is
initialized with a reference to the object being managed.  When the
@code{try} block ends, the resource is automatically released.  In the case
of a file, the file is automatically closed (there is no need to call
@code{close()}.

@subheading @code{try-with-resources} Under JDK 9
@cindex JDK 9, @code{try-with-resources}

Beginning with JDK 9, it is also possible for the resource specification of
the @code{try} to consist of a variable that has been declared and
initialized earlier in the program.  However, that variable must be
effectively @code{final}, which means that it has not been assigned a new
value after being given its initial value.

Here are three key points about @code{try-with-resources} statement:

@itemize
@item
Resources must be objects of classes the implement @file{AutoCloseable}
interface 
@item
A resource declared in @code{try} is @emph{implicitly} @code{final}, while a
resource declared outside the @code{try} must be @emph{effectively}
@code{final}.  
@item
More than one resource can be handled by separating each declaration with a
semicolon.
@end itemize

@subheading Principal Advantages to using @code{try-with-resources}

A principal advantage of @code{try-with-resources} is that the resource is
closed automatically when the @code{try} block ends.  Thus, it is not
possible to forget to close a stream.  Another advantage is that the
@code{try-with-resources} approach typically results in shorter, clear,
easier-to-maintain source code.


@c -----------------------------------------------------------------------------

@node Stream Classes
@section The Stream Classes
@cindex Stream Classes
@cindex I/O abstract classes
@cindex @file{InputStream} abstract class
@cindex @file{OutputStream} abstract class
@cindex @file{Reader} abstract class
@cindex @file{Writer} abstract class

Java's stream-based I/O is built upon four abstract classes:

@itemize

@item Byte Streams
@itemize
@item @file{InputStream}
@item @file{OutputStream}
@end itemize

@item Character Streams
@itemize
@item @file{Reader}
@item @file{Writer}
@end itemize

@end itemize

@noindent The top-level classes define the basic functionality common to all
stream classes.  In general, you should use the character stream classes when
working with characters or strings and use the byte stream classes when
working with bytes or other binary objects.

@c -----------------------------------------------------------------------------

@node Byte Streams
@section The Byte Streams
@cindex Byte Streams
@cindex byte-oriented I/O
@cindex I/O, byte-oriented

The byte stream classes provide an environment for handling byte-oriented
I/O.  A byte stream can be used with any type of object, including binary
data.  The byte streams are topped by @file{InputStream} and
@file{OutputStream}.  

@c .....................................

@node InputStream
@subsection @file{InputStream}
@cindex @file{InputStream}

@file{InputStream} is an abstract class that defines Java's model of
streaming byte input.  It implements the @file{AutoCloseable} and
@file{Closeable} interfaces.  Most of the methods in this class will throw an
@file{IOException} when an I/O error occurs.@footnote{The exceptions are
@code{mark()} and @code{markSupported()}.}

@c _____________________________________

@node InputStream Methods
@subsubsection @file{InputStream} Methods
@cindex @file{InputStream} methods

@float Table,InputStreamMethods
@table @b
@item int available()
Returns the number of bytes of input currently available for reading
@item void close()
Closes the input source.  Further read attempts will generate an
@file{IOException}.
@item void mark(int @ii{numBytes})
Places a mark at the current point in the input stream that will remain valid
until @ii{numBytes} bytes are read.
@item boolean markSupported()
Returns @code{true} if @code{mark()} / @code{reset()} are supported by the
invoking stream.
@item int read()
Returns an integer representation of the next available byte of input.
@code{-1} is returned when an attempt is made to read at the end of the
stream.  
@item int read(byte @ii{buffere[]})
Attempts to read up to @ii{buffer.length} bytes into @ii{buffer} and returns
the actual number of bytes that were successfully read.  @code{-1} is
returned when an attempt is made to read at the end of the stream.
@item int read(byte @ii{buffer[]}, int @ii{offset}, int @ii{numBytes})
Attempts to read up to @ii{numBytes} bytes into @ii{buffer} starting at
@ii{buffer[offset]}, returning the numnber of bytes successfully read.
@code{-1} is returned when an attempt is made to read at the end of the
stream.  
@item byte[] readAllBytes()
Beginning at the current position, reads to the end of the stream, returning
a byte array that holds the input.  (Added by JDK 9.)
@item int readNBytes(byte @ii{buffer[]}, int @ii{offset}, int @ii{numBytes})
Attempts to read up to @ii{numBytes} bytes into @ii{buffer} starting at
@ii{buffer[offset]}, returning the number of types successfully read.  (Added
by JDK 9.)
@item void reset()
Resets the input pointer to the previously set mark.
@item long skip(long @ii{numBytes})
Ignores (that is, skips) @ii{numBytes} bytes of input, returning the number
of bytes actually ignored.
@item long transferTo(OutputStream @i{strm})
Copies the bytes in teh invoking stream into @ii{strm}, returning the number
of bytes copies.  (Added by JDK 9.)
@end table
@caption{The Methods Defined by @file{InputStream}}
@end float


@c .....................................

@node OutputStream
@subsection @file{OutputStream}
@cindex @file{OutputStream}

@file{OutputStream} is an abstract class that defines streaming byte output.
It implements @file{AutoCloseable}, @file{Closeable}, and @file{Flushable}
interfaces.  Most of the methods defined by this class return @code{void} and
throw an @file{IOException} in the case of I/O errors.

@c _____________________________________

@node OutputStream Methods
@subsubsection @file{OutputStream} Methods
@cindex @file{OutputStream} Methods

@float Table,OutputStreamMethods
@table @b
@item void close()
Closes the output stream.  Further write attempts will generate an
@file{IOException}.  
@item void flush()
Finalizes the output state so that any buffers are cleared (it flushes the
output buffers).
@item void write(int @ii{b})
Writes a single byte to an output stream.  Note that the parameter is an
@code{int}, which allows you to call @code{write()} with an expression
without having to cast it back to @code{byte}.
@item void write(byte @ii{buffer[]})
Writes a complete array of bytes to an output stream.
@item void write(byte @ii{buffer[]}, int @ii{offset}, int @ii{numBytes})
Writes a subrange of @ii{numBytes} bytes from the array @ii{buffer},
beginning at @ii{buffer[offset]}.
@end table
@caption{The Methods Defined by @file{OutputStream}}
@end float

@c .....................................

@node FileInputStream
@subsection @file{FileInputStream}
@cindex @file{FileInputStream}
@cindex constructors for @file{FileInputStream}
@cindex @file{FileNotFoundException}

The @file{FileInputStream} class creates an @file{InputStream} that you can
use to read bytes from a file.  Two commonly used constructors are:

@display
FileInputStream(String @ii{filePath})
FileInputStream(File @ii{fileObj})
@end display

Either can throw a @file{FileNotFoundException}.

@c .....................................

@node FileOutputStream
@subsection @file{FileOutputStream}
@cindex @file{FileOutputStream}

@c .....................................

@node ByteArrayInputStream
@subsection @file{ByteArrayInputStream}
@cindex @file{ByteArrayInputStream}

@c .....................................

@node ByteArrayOutputStream
@subsection @file{ByteArrayOutputStream}
@cindex @file{ByteArrayOutputStream}

@c .....................................

@node Filtered Byte Streams
@subsection Filtered Byte Streams
@cindex Byte Streams, filtered
@cindex filtered byte streams
@cindex @file{FilterInputStream}
@cindex @file{FilterOutputStream}

@dfn{Filtered streams} are simply wrappers around underlying input or output
streams that transparently provide some extended level of functionality.
These streams are typcially accessed by methods that are expecting a generic
stream, which is a superclass of the filtered streams.  Typical extensions
are buffering, character translation, and raw data translation. The filtered
byte streams are:

@itemize
@item
@file{FilterInputStream}
@item
@file{FilterOutputStream}
@end itemize

@noindent Their constructors are:

@display
FilterOutputStream (OutputStream @ii{os})
FilterInputStream (InputStream @ii{is})
@end display

@c .....................................

@node Buffered Byte Streams
@subsection Buffered Byte Streams
@cindex Buffered Byte Streams
@cindex Byte Streams, buffered
@cindex buffered stream
@cindex @file{BufferedInputStream}
@cindex @file{BufferedOutputStream}
@cindex @file{PushbackInputStream}

For the byte-oriented streams, a @dfn{buffered stream} extends a filtered
stream class by attaching a memory buffer to the I/O stream.  This buffer
allows Java to do I/O operations on more than a byte at a time, thereby
improving performance.  Because the buffer is available, skipping, marking,
and resetting of the stream become possible.  The buffered byte stream
classes are:

@itemize
@item
@file{BufferedInputStream}
@item
@file{BufferedOutputStream}
@item
@file{PushbackInputStream}
@end itemize

@c _____________________________________

@node BufferedInputStream
@subsubsection @file{BufferedInputStream}
@cindex @file{BufferedInputStream}
@cindex @file{BufferedInputStream} constructors

Java's @file{BufferedInputStream} class allows you to ``wrap'' any
@file{InputStream} into a buffered stream to improve performance.
@file{BufferedInputStream} has two constructors:

@display
BufferedInputStream (InputStream @ii{inputStream})
BufferedInputStream (InputStream @ii{inputStream}, int @ii{bufSize})
@end display

The first form creates a buffered stream using a default buffer size.  In the
second, the size of the buffer is passed in @ii{bufSize}.  Use of sizes that
are multiples of a memory page, a disk block, and son, can have a significant
positive impact on performance.  A good guess for a size is around 8,192
bytes, and attaching even a rather small buffer to an I/O stream is always a
good idea.  That way, the low-level system can read blocks of data from the
disk or network and store the results in your buffer.  Thus, even if you are
reading the data a byte at a time out of the @file{InputStream}, you will be
manipulating fast memory most of the time.

Buffering an input stream provides the foundation required to support moving
backward in the stream of the available buffer.  Beyond the @code{read()} and
@code{skip()} methods implemented in any @file{InputStream},
@file{BufferedInputStream} also supports the @code{mark()} and @code{reset()}
methods.  This support is reflected by the
@code{BufferedInputStream.markSupported()} returning @code{true}.

@c _____________________________________

@node Buffered Input Example
@subsubsection Buffered Input Example
@pindex @file{BufferedInputStreamDemo.java}

@cartouche
The following example contrives a situation where we can use @code{mark()} to
remember where we are in an input stream and later use @code{reset()} to get
back there.  This example is parsing a stream for the HTML entity reference
for the ``copyright'' symbol.  Such a reference begins with an ampersand
(@kbd{&}) and ends with a semicolon (@kbd{;}) without any intervening
whitespace.  The sample input has two ampersands to show the case where the
@code{reset()} happens and where it does not.
@end cartouche

@ifinfo
@noindent=============================================================================
@end ifinfo

@(BufferedInputStreamDemo.java@)=
@<Import java.io@>
class BufferedInputStreamDemo {
  public static void main(String[] args) {

    @<BufferedInputStreamDemo Instance Variables@>

    @<BufferedInputStreamDemo TryWithResources BufferedInputStream@>
    @<Catch IOException@>

  }
}

@

@c _____________________________________

@node BufferedInputStreamDemo Instance Variables
@subsubsection BufferedInputStreamDemo Instance Variables
@<BufferedInputStreamDemo Instance Variables@>=
@<BufferedInputStreamDemo String@>
@<BufferedInputStreamDemo Buffer@>
@<BufferedInputStreamDemo ByteArrayInputStream@>
@<BufferedInputStreamDemo Utility Variables@>
@

@c _____________________________________

@node BufferedInputStreamDemo TryWithResources BufferedInputStream
@subsubsection BufferedInputStreamDemo TryWithResources BufferedInputStream

@<BufferedInputStreamDemo TryWithResources BufferedInputStream@>=
try (BufferedInputStream f = new BufferedInputStream(in)) {

  @<BufferedInputStreamDemo While Loop@>

}

@

@c _____________________________________

@node BufferedInputStreamDemo While Loop
@subsubsection BufferedInputStreamDemo While Loop

@<BufferedInputStreamDemo While Loop@>=
while ( (c = f.read()) != -1 ) {

   @<BufferedInputStreamDemo Switch on Character@>
  
}

@

@c _____________________________________

@node BufferedInputStreamDemo Switch on Character
@subsubsection BufferedInputStreamDemo Switch on Character

@<BufferedInputStreamDemo Switch on Character@>=
switch (c) {
  case '&':
    if (!marked) {
      f.mark(32);
      marked = true;
    } else marked = false;
    break;

  case ';':
    if (marked) {
      marked = false;
      System.out.print("(c)");
    } else System.out.print( (char) c);
    break;

  case ' ':
    if (marked) {
      marked = false;
      f.reset();
      System.out.print("&");
    } else System.out.print( (char) c);
    break;

  default:
    if (!marked) System.out.print( (char) c);
    break;
}

@


@c _____________________________________

@node BufferedInputStreamDemo String Into Buffer
@subsubsection BufferedInputStreamDemo String Into Buffer

@<BufferedInputStreamDemo String@>=
String s = "This is a &copy; copyright symbol " + "but this is &copy not.\n"
@

@c _____________________________________

@node BufferedInputStreamDemo Buffer
@subsubsection BufferedInputStreamDemo Buffer

@<BufferedInputStreamDemo Buffer@>=
byte buf[] = s.getBytes();

@

@c _____________________________________

@node BufferedInputStreamDemo ByteArrayInputStream
@subsubsection BufferedInputStreamDemo ByteArrayInputStream

@<BufferedInputStreamDemo ByteArrayInputStream@>=
ByteArrayInputStream in = new ByteArrayInputStream(buf);

@

@c _____________________________________

@node BufferedInputStreamDemo Utility Variables
@subsubsection BufferedInputStreamDemo Utility Variables

@<BufferedInputStreamDemo Utility Variables@>=
int c;
boolean marked = false;

@

@c _____________________________________

@node BufferedOutputStream
@subsubsection @file{BufferedOutputStream}
@cindex @file{BufferedOutputStream}

@c _____________________________________

@node PushbackInputStream
@subsubsection @file{PushbackInputStream}
@cindex @file{PushbackInputStream}

@c .....................................

@node SequenceInputStream
@subsection @file{SequenceInputStream}
@cindex @file{SequenceInputStream}

@c .....................................

@node PrintStream
@subsection @file{PrintStream}
@cindex @file{PrintStream}

@c .....................................

@node DataOutputStream DataInputStream
@subsection @file{DataOutputStream} and @file{DataInputStream}
@cindex @file{DataOutputStream}
@cindex @file{DataInputStream}

@c .....................................

@node RandomAccessFile
@subsection @file{RandomAccessFile}
@cindex @file{RandomAccessFile}


@c -----------------------------------------------------------------------------

@node Character Streams
@section The Character Streams
@cindex Character Streams
@cindex Unicode characters
@cindex @file{Reader} abstract class
@cindex @file{Writer} abstract class

While th byte stream classes provide sufficient functionality to handle any
type of I/O operation, they cannot work directly with Unicode characters.
Since one of the purposes of Java is to support the ``write once, run
anywhere'' philosophy, it was necessary to include direction I/O support for
characters.  In this section, several of the character I/O classes are
discussed.

At the top of the character stream hierarchies are the

@itemize
@item
@file{Reader}
@item
@file{Writer}
@end itemize

@noindent abstract classes.

@c .....................................

@node Reader
@subsection @file{Reader}
@cindex @file{Reader}

@file{Reader} is an abstact class that defines Java's model of streaming
character input.  It implements the @file{AutoCloseable}, @file{Closeable},
and @file{Readable} interfaces.  All of the methods in this class (except
@code{markSupported()}) will throw an @file{IOException} on error
conditions.

@subsubheading Reader Methods
@cindex @file{Reader} Methods

@float Table,ReaderMethods
@table @b
@item abstract void close()
Closes the input source.  Further read attempts will general an
@file{IOException}.  
@item void mark(int @ii{numChars})
Places a mark at the current point in the input stream that will remain valid
until @ii{numChars} characters are read.
@item boolean markSupported()
Returns @code{true} if @code{mark()}/@code{reset()} are supported on this
stream.
@item int read(char @ii{buffer[]})
Attempts to read up to @ii{buffer.length} characters into @ii{buffer} and
returns the actual number of characters that were successfully read.
@code{-1} is returned when an attempt is made to read at the end of the
stream.
@item int read(CharBuffer @ii{buffer})
Attempts to read characters into @ii{buffer} and returns the actual number of
characters that were successfully read.  @code{-1} is returned when an
attempt is made to read at the end of the stream.
@item abstract int read(char @ii{buffer[]}, int @ii{offset}, int @ii{numChars})
Attempts to read up to @ii{numChars} characters into @ii{buffer} starting at
@ii{buffer[offset]}, returning the number of characters successfully read.
@code{-1} is returned whn an attempt is made to read at the end of the
stream. 
@item boolean read()
Returns @code{true} if the next input request will not wait.  Otherwise, it
returns @code{false}.
@item void reset()
Resets the input pointer to the previously set mark.
@item long skip(long @ii{numChars})
Skips over @ii{numChars} characters of input, returning the number of
characters actually skipped.
@end table
@caption{The Methods Defined by @file{Reader}}
@end float

@c .....................................

@node Writer
@subsection @file{Writer}
@cindex @file{Wrtier}

@file{Writer} is an abstract class that defines streaming character output.
It implements the @file{AutoCloseable}, @file{Closeable}, @file{Flushable},
and @file{Appendable} interfaces.  All of the methods in this class throw an
@file{IOException} in the case of errors.

@subsubheading @file{Writer} Methods
@cindex @file{Writer} Methods

@float Table,WriterMethods
@table @b
@item Writer append(char @ii{ch})
Appends @ii{ch} tot he end of the invoking output stream.  Returns a
reference to the invoking stream.
@item Writer append(CharSequence @ii{chars})
Appends @ii{chars} to the end of the invoking output stream.  Returns a
reference to the invoking stream.
@item Writer append(CharSequence @ii{chars}, int @ii{begin}, int @ii{end})
Appends the subrange of @ii{chars} specified by @ii{begin} and @ii{end} - 1
to the end of the invoking output stream.  Returns a refernce to the invoking
stream.  
@item abstract void close()
Closes the output stream.  Further write attempts will generate an
@file{IOException}. 
@item abstract void flush()
Finalizes the output state so that any buffers are cleared (it flushes the
output buffers).
@item void write(int @ii{ch})
Writes a single character to the invoking output stream.  The parameter is an
@code{int}, whcih allows you to call @code{write()} with an expression
without have to case it back to @code{char}.  However, only the low-order 16
bits are written.
@item void write(char @ii{buffer[]})
Writes a complete array of characters to the invoking output stream.
@item abstract void(char @ii{buffer[]}, int @ii{offset}, int @ii{numChars})
Writes a subrange of @ii{numChars} characters from the array @ii{buffer},
beginning at @ii{buffer[offset]} to the invoking output stream.
@item void write(String @ii{str})
Writes @ii{str} to the invoking output stream.
@item void write(String @ii{str}, int @ii{offset}, int @ii{numChars})
Writes a subrange of @ii{numChars} characters from the string @ii{str},
beginning at the specified @ii{offset}
@end table
@caption{The Methods Defined by Writer}
@end float

@c .....................................

@node FileReader
@subsection @file{FileReader}
@cindex @file{FileReader}
@cindex @file{FileReader} constructors

The @file{FileReader} class creates a @file{Reader} that you can use to read
the contents of a file.  Two commonly used constructors are:

@display
FileReader (String @ii{filePath})
FileReader (File @ii{fileObj})
@end display

Either can throw a @file{FileNotFoundException}.

@subsubheading Example Reading Lines From a File
@pindex @file{FileReaderDemo.java}

@cartouche
This example shows how to read lines from a file and display them on the
standard output device.  It reads its own source file, which must be in the
current directory.
@end cartouche

@ifinfo
@noindent=========================================================================
@end ifinfo

@(FileReaderDemo.java@)=
@<Import java.io@>
class FileReaderDemo {
  public static void main (String[] args) {
    @<FileReaderDemo TryWithResources FileReader@>
    @<Catch IOException@>
  }
}

@

@c _____________________________________

@node FileReaderDemo TryWithResources FileReader
@subsubsection FileReaderDemo TryWtihResources FileReader

@<FileReaderDemo TryWithResources FileReader@>=
try (FileReader fr = new FileReader("FileReaderDemo.java")) {
  int c;

  while ((c = fr.read()) != -1)
    System.out.print((char) c);
}

@

@c _____________________________________

@node Catch IOException
@subsubsection Catch IOException

@<Catch IOException@>=
catch (IOException e) {
  System.out.println("I/O Error: " + e);
}

@

@c .....................................

@node FileWriter
@subsection @file{FileWriter}
@cindex @file{FileWriter}
@cindex @file{FileWriter} constructors

@file{FileWriter} creates a @file{Writer} that you can use to write to a
file.  Four commonly used constructors are:

@display
FileWriter (String @ii{filePath})
FileWriter (String @ii{filePath}, boolean @ii{append})
FileWriter (File @ii{fileObj})
FileWriter (File @ii{fileObj}, boolean @ii{append})
@end display

@noindent They can all throw an @file{IOException}.  If @ii{append} is
@code{true}, then output is appended to the end of the file.  Creation of a
@file{FileWriter} is not dependent on the file already existing.
@file{FileWriter} will create the file before opening it for output when you
create the object.  In the case where you attept to open a read-only file,
an @file{IOException} will be thrown.


@c .....................................

@node CharArrayReader
@subsection @file{CharArrayReader}
@cindex @file{CharArrayReader}

@c .....................................

@node CharArrayWriter
@subsection @file{CharArrayWriter}
@cindex @file{CharArrayWriter}

@c .....................................

@node BufferedReader
@subsection @file{BufferedReader}
@cindex @file{BufferedReader}
@cindex @file{BufferedReader} constructors
@cindex stream, move backwards in
@cindex @code{BufferedReader.lines()} method
@cindex @code{lines()} method
@cindex @file{Stream} reference
@cindex @file{Streams} API

@file{BufferedReader} improves performance by buffering input.  It has two
constructors:

@display
BufferedReader (Reader @ii{inputStream})
BufferedReader (Reader @ii{inputStream}, int @ii{bufSize})
@end display

The first form creates a buffered character stream using a default buffer
size.  In the second, the size of the buffer is passed in @ii{bufSize}.
Closing a @file{BufferedReader} also causes the underlying stream specified
by @ii{inputStream} to be closed.

Buffering an input character stream provides the foundation required to
support moving backward in the stream within the available buffer.  To
support this, @file{BufferedReader} implements the @code{mark()} and
@code{reset()} methods, and @code{BufferedReader.markSupported()} returns
@code{true}.

JDK 8 added a new method to @file{BufferedReader} called @code{lines()}.  It
returns a @file{Stream} reference to the sequence of lines read by the
reader.  (@file{Stream} is part of the stream API discussed in @ref{Streams
API}.  

@c .....................................

@node Buffered Reader Demo
@subsection Buffered Reader Demo
@pindex @file{BufferedReaderDemo.java}

@cartouche
This example reworks the @file{BufferedInputStream} example (@pxref{Buffered
Input Example}) so that it uses a @file{BufferedReader} character stream
rather than a buffered byte stream.  It uses the @code{mark()} and
@code{reset()} methods to parse a stream for the HTML-entity reference for
the copyright symbol.  Such a reference begins with an ampersand (@kbd{&})
and ends with a semicolon (@kbd{;}) without any intervening whitespace.  The
sample has two ampersands to show the case where the @code{reset()} happens
and where it does not.
@end cartouche

@ifinfo
@noindent =============================================================================
@end ifinfo

@(BufferedReaderDemo.java@)=
@<Import java.io@>
class BufferedReaderDemo {
  public static void main (String[] args) throws IOException {

    @<BufferedReaderDemo Instance Variables@>

    @<BufferedReaderDemo TryWithResources BufferedReader@>
    @<Catch IOException@>

  }
}

@

@c _____________________________________

@node BufferedReaderDemo Instance Variables
@subsubsection BufferedReaderDemo Instance Variables

@cartouche
The String is copied directly from the prior implementation.
@end cartouche

@ifinfo
@noindent=========================================================================
@end ifinfo

@<BufferedReaderDemo Instance Variables@>=
@<BufferedInputStreamDemo String@>
@<BufferedReaderDemo Buffer@>

@

@c _____________________________________

@node BufferedReaderDemo Buffer
@subsubsection BufferedReaderDemo Buffer

@cartouche
Notice that this implementation uses a @code{char} buffer, with a
@code{getChars()} method to transfer the string characters, while the
@file{BufferedInputStream} implementation uses a @code{byte} buffer, and a
@code{getBytes()} method to transfer the string bytes.
@xref{BufferedInputStreamDemo Buffer}.
@end cartouche

@ifinfo
@noindent =========================================================================
@end ifinfo

@<BufferedReaderDemo Buffer@>=
char buf[] = new char[s.length()];
s.getChars(0, s.length(), buf, 0);

@

@c _____________________________________

@node BufferedReaderDemo TryWithResources BufferedReader
@subsubsection BufferedReaderDemo TryWithResources BufferedReader

@cartouche
Notice that the Switch code is identical to the byte stream example.
@end cartouche

@ifinfo
@noindent==========================================================================
@end ifinfo

@<BufferedReaderDemo TryWithResources BufferedReader@>=
try ( BufferedReader f = new BufferedReader(in) ) {
  while ( (c = f.read()) != -1 ) {
    @<BufferedInputStreamDemo Switch on Character@>
  }
}

@

@c .....................................

@node BufferedWriter
@subsection @file{BufferedWriter}
@cindex @file{BufferedWriter}
@cindex @file{BufferedWriter} constructors

A @file{BufferedWriter} is a @file{Writer} that buffers output.  Using a
@file{BufferedWriter} can improve performance by reducing the number of times
data is actually phyiscally written to the output device.  A
@file{BufferedWriter} has these constructors:

@display
BufferedWriter (Writer @ii{outputStream})
BufferedWriter (Writer @ii{outputStream}, int @ii{bufSize})
@end display



@c .....................................

@node PushbackReader
@subsection @file{PushbackReader}
@cindex @file{PushbackReader}

@c .....................................

@node PrintWriter
@subsection @file{PrintWriter}
@cindex @file{PrintWriter}


@c -----------------------------------------------------------------------------

@node Console Class
@section The Console Class
@cindex Console Class


@c -----------------------------------------------------------------------------

@node Serialization
@section Serialization
@cindex Serialization
@cindex directed graph

@dfn{Serialization} is the process of writing the state of an object to a
byte stream.  This is useful when you want to save the state of your program
to a persistent storage area, such as a file.  At a later time, you may
restore these objects by using the process of deserialization.

Assume that an object to be serialized has references to other objects,
which, in turn, have references to still more objects.  This set of objects
and the relationships among them form a directed graph.  There may also be
circular references within this object graph.  Objects may also contain
references to themselves.  The object serialization and deserialization
facilities have been designed to work correctly in these scenarios.  If you
attempt to serialize an object at the top of an object graph, all of the
other referenced objects are recurseively located and serialized.  Similarly,
during the process of deserialization, all of these objects and their
references are correctly restored.

@c .....................................

@node Serializable
@subsection @file{Serializable}
@cindex @file{Serializable} interface
@cindex @code{transient} variable, not serialized
@cindex @code{static} variable, not serialized

Only an object that implements the @file{Serializable} interface can be saved
and restored by the serialization facilities.  The @file{Serializable}
interface defines no members.  It is simply used to indicate that a class may
be serialized.  If a class is serializable, all of its subclasses are also
serializable.

Variables that are declared as @code{transient} are not saved by the
serialization facilities.  Also @code{static} variables are not saved.

@c .....................................

@node Externalizable
@subsection @file{Externalizable}
@cindex @file{Externalizable}
@cindex @code{readExternal()}
@cindex @code{writeExternal()}

The Java facilities for serialization and deserialization have been designed
so that much of the work to save and restore the state of an object occurs
automatically.  However, there are cases in which the programmer may need to
have control over these processes.  The @file{Externalizable} interface is
designed for these sitautions.

The @file{Externalizable} interface defines these two methods:

@display
void readExternal (ObjectInput @ii{inStream}) throws IOException, ClassNotFoundException
void writeExternal (ObjectOutput @ii{outStream} throws IOException
@end display


@c .....................................

@node ObjectOutput
@subsection @file{ObjectOutput}
@cindex @file{ObjectOutput}

@c .....................................

@node ObjectOutputStream
@subsection @file{ObjectOutputStream}
@cindex @file{ObjectOutputStream}

@c .....................................

@node ObjectInput
@subsection @file{ObjectInput}
@cindex @file{ObjectInput}

@c .....................................

@node ObjectInputStream
@subsection @file{ObjectInputStream}
@cindex @file{ObjectInputStream}

@c .....................................

@node Serializable Example
@subsection A Serializable Example
@cindex serializable example


@c -----------------------------------------------------------------------------

@node Stream Benefits
@section Stream Benefits
@cindex Stream Benefits








@c *****************************************************************************

@node java.nio --- NIO
@chapter Exploring NIO
@cindex NIO
@cindex @file{java.nio}








@c *****************************************************************************

@node Networking
@chapter Networking
@cindex Networking








@c *****************************************************************************

@node Event Handling
@chapter Event Handling
@cindex Event Handling








@c *****************************************************************************

@node AWT
@chapter AWT: Working with Windows, Graphics, and Text
@cindex AWT
@cindex Windows
@cindex Graphics
@cindex Text








@c *****************************************************************************

@node AWT Controls
@chapter Using AWT Controls, Layout Managers, and Menus
@cindex AWT Controls
@cindex AWT Layout Managers, Menus








@c *****************************************************************************

@node Images
@chapter Images
@cindex Images








@c *****************************************************************************

@node Concurrency
@chapter The Concurrency Utilities
@cindex Concurrency Utilities








@c *****************************************************************************

@node Streams API
@chapter The Stream API
@cindex Stream API
@cindex API, Stream








@c *****************************************************************************

@node Regular Expressions
@chapter Regular Expressions
@cindex Regular Expressions








@c *****************************************************************************

@node Reflection
@chapter Reflection
@cindex Reflection
@cindex @file{java.lang.reflect} package
@cindex @file{Class}
@cindex JDK 9
@cindex @file{java.base} module

@dfn{Reflection} is the ability of software to analyze or modify itself at
runtime rather than at compile time.  This is provided by the
@file{java.lang.reflect} package and elements in @file{Class}.  Beginning
with JDK 9, @file{java.lang.reflect} is part of the @file{java.base} module.
Reflection allows you to analyze a software component and describe its
capabilities dynamcically at run-time rather than at compile time.  For
example, by using reflection, you can determine what methods, constructors,
and fields a class supports.

@heading Drawbacks of Reflection

Because reflection is dynamic, the java virtual machine is unable to make
certain optimizations and could therefor run slower.  Also, since reflection
allows code to perform operations that would be illegal in non-reflective
code, such as accessing private fields and methods, the use of reflection can
result in unexpected behavior.  Reflection breaks abstractions.




@c -----------------------------------------------------------------------------

@node java.lang.reflect Package
@section @file{java.lang.reflect} Package
@cindex @file{java.lang.reflect} Package
@cindex @file{Member} interface

This package provides classes and interfaces for obtaining reflective
information about classes and objects.  Reflection allows programmatic access
to information about the fields, methods and constructors of loaded classes,
and the use of reflected fields, methods, and constructors to operate on
their underlying counterparts, within encapsulation and security
restrictions.

The package @file{java.lang.reflect} includes several interfaces.  Of special
interest is @file{Member}, which defines methods that allow you to get
information abouta field, constructor, or method of a class.  There are also
ten classes in this package.

Classes in this package, along with java.lang.Class accommodate applications
such as debuggers, interpreters, object inspectors, class browsers, and
services such as Object Serialization and JavaBeans that need access to
either the public members of a target object (based on its runtime class) or
the members declared by a given class.

Note that none of the classes in @file{java.lang.reflect} offer any public
constructors.  All reflection interactions must go through
@file{java.lang.Class}.  Note also that @file{java.lang.Class} does not offer
any public constructors.  Instances of this class are created by the Java
Virtual Machine.


@c .....................................

@node Classes Defined in java.lang.reflect
@subsection Classes Defined in @file{java.lang.reflect}

@float Table,java.lang-reflect-Classes
@table @b
@item AccessibleObject
Allows you to bypass the default access control checks
@item Array
Allows you to dynamically create and manipulate arrays
@item Constructor
Provides information about a constructor
@item Executable
An abstract superclass extended by @file{Member} and @file{Constructor}
@item Field
Provides information about a field
@item Method
Provides information about a method
@item Modifier
Provides information about class and member access modifiers
@item Parameter
Provides information about parameters
@item Proxy
Supports dynamic proxy classes
@item ReflectPermission
Allows reflection of private or protected members of a class
@end table
@caption{Classes Defined in @file{java.lang.reflect}}
@end float


@c .....................................

@node Interfaces Defined in java.lang.reflect
@subsection Interfaces Defined in @file{java.lang.reflect}

@float Table,java.lang.reflect_Interfaces
@table @b
@item  AnnotatedArrayType
represents the potentially annotated use of an array type, whose component
type may itself represent the annotated use of a type.
@item AnnotatedElement
represents an annotated element of the program currently running in this VM.
@item AnnotatedParameterizedType
represents the potentially annotated use of a parameterized type, whose type
arguments may themselves represent annotated uses of types.
@item AnnotatedType
represents the potentially annotated use of a type in the program currently
running in this VM.
@item AnnotatedTypeVariable
represents the potentially annotated use of a type variable, whose
declaration may have bounds which themselves represent annotated uses of
types.
@item AnnotatedWildcardType
represents the potentially annotated use of a wildcard type argument, whose
upper or lower bounds may themselves represent annotated uses of types.
@item GenericArrayType
represents an array type whose component type is either a parameterized type
or a type variable.
@item GenericDeclaration
A common interface for all entities that declare type variables.
@item InvocationHandler
the interface implemented by the invocation handler of a proxy instance.
@item Member
an interface that reflects identifying information about a single member (a
field or a method) or a constructor.
@item ParameterizedType
ParameterizedType represents a parameterized type such as Collection<String>.
@item Type
Type is the common superinterface for all types in the Java programming
language.
@item TypeVariable<D extends GenericDeclaration>
the common superinterface for type variables of kinds.
@item WildcardType
WildcardType represents a wildcard type expression, such as ?, ? extends
Number, or ? super Integer.
@end table
@caption{Interfaces Defined in @file{java.lang.reflect}}
@end float


@c .....................................

@node Reflection Demonstration
@subsection Reflection Demonstration
@cindex Reflection demonstration

The following application illustrates a simple use of the Java reflection
capabilities.  It prints the constructors, fields, and methods of the class
@file{java.awt.Dimension}.  The program begins by using the @code{forName()}
mthod of @file{Class} to get a class object for @file{java.awt.Dimension}.
Once this is obtained, @code{getConstructors()}, @code{getFields()}, and
@code{getMethods()} are used to analyze this class object.  They return
arrays of @file{Constructor}, @file{Field}, and @file{Method} objects that
provide the information about the object.  The @file{Constructor},
@file{Field}, and @file{Method} classes define several methods that can be
used to obtain information about an object.  Each supports the
@code{toString()} method.  Therefore, using these objects as arguments tot he
@code{println()} method is straightforward.

@subsubheading ReflectionDemo1.java
@pindex @file{ReflectionDemo1.java}

@(ReflectionDemo1.java@)=
@<Import java.lang.reflect@>

public class ReflectionDemo1 {
  public static void main(String[] args) {
    try {
      @<ReflectionDemo1---Class forName() Call@>
      @<ReflectionDemo1---getConstructors() Call@>
      @<ReflectionDemo1---getFields() Call@>
      @<ReflectionDemo1---getMethods() Call@>
    }
    @<Catch Exception@>
  }
}

@

@c _____________________________________

@node Import java.lang.reflect
@subsubsection Import java.lang.reflect

@<Import java.lang.reflect@>=
import java.lang.reflect.*;

@

@c _____________________________________

@node ReflectionDemo1---Class forName() Call
@subsubsection ReflectionDemo1---Class forName() Call

@<ReflectionDemo1---Class forName() Call@>=
Class<?> c = Class.forName("java.awt.Dimension");

@

@c _____________________________________

@node ReflectionDemo1---getConstructors() Call
@subsubsection ReflectionDemo1---getConstructors() Call

@<ReflectionDemo1---getConstructors() Call@>=
System.out.println("Constructors:");
Constructor<?> constructors[] = c.getConstructors();

for (int i = 0; i < constructors.length; i++) {
  System.out.println(" " + constructors[i]);
}

@

@c _____________________________________

@node ReflectionDemo1---getFields() Call
@subsubsection ReflectionDemo1---getFields() Call

@<ReflectionDemo1---getFields() Call@>=
System.out.println("Fields:");
Filed fields[] = c.getFields();

for (int i = 0; i < fields.length; i++) {
  System.out.println(" " + fields[i]);
}

@

@c _____________________________________

@node ReflectionDemo1---getMethods() Call
@subsubsection ReflectionDemo1---getMethods() Call

@<ReflectionDemo1---getMethods() Call@>=
System.out.println("Methods:");
Method methods[] = c.getMethods();

for (int i = 0; i < methods.length; i++) {
  System.out.print.n(" " + methods[i]);
}

@

@c _____________________________________

@node Catch Exception
@subsubsection Catch Exception

@<Catch Exception@>=
catch (Exception e) {
  System.out.println("Exception: " + e);
}

@




@c -----------------------------------------------------------------------------

@node Classes and Reflection
@section Classes and Reflection
@cindex Classes and Reflection
@cindex @file{java.lang.Class}

For every type of object, the Java virtual machine instantiates an immutable
instance of @file{java.lang.Class} which provides methods to examine the
runtime properties of the object including its members and type information.

@file{Class} also provides the ability to create new classes and objects.
Most importantly, it is the entry point for all of the Reflective APIs.


@c .....................................

@node java.lang.Class
@subsection @file{java.lang.Class}
@cindex @file{java.lang.Class}
@cindex @file{Class}

Instances of the class @file{Class} represent classes and interfaces in a
running Java application.  An @code{enum} is a kind of class and an
@code{annotation} is a kind of interface.  Every array also belongs to a
class that is reflected as a @file{Class} object that is shared by all arrays
with the same element type and number of dimensions.  The primitive Java
types (@code{boolean}, @code{byte}, @code{char}, @code{short}, @code{int},
@code{long}, @code{float}, and @code{double}), and the keyword @code{void}
are also represented as @file{Class} objects.

@file{Class} has no public constructor. Instead @file{Class} objects are
constructed automatically by the Java Virtual Machine as classes are loaded
and by calls to the @code{defineClass} method in the class loader.

The following example uses a Class object to print the class name of an
object:

@example
void printClassName(Object obj) @{
         System.out.println("The class of " + obj +
                            " is " + obj.getClass().getName());
     @}
@end example

It is also possible to get the @file{Class} object for a named type (or for
@code{void}) using a class literal.

@example
System.out.println("The name of class Foo is: "+Foo.class.getName());
@end example

@c _____________________________________

@node Class Constructor
@subsubsection @file{Class} getConstructor

@deftypeop Constructor Class Constructor<T> getConstructor (parameterType)
Returns a @file{Constructor} object that reflects the specified public
constructor of the class represented by this @file{Class} object.
@end deftypeop

@subsubheading @file{Class} getConstructors

@deftypeop Constructor Class Constructor<?>[] getConstructors ()
Returns an array containing @file{Constructor} objects reflecting all the
public constructors of the class represented by this @file{Class} object.
@end deftypeop


@c .....................................

@node Retrieving Class Objects
@subsection Retrieving Class Objects
@cindex @file{java.lang.Class}
@cindex @file{Class}

The entry point for all reflection operations is @file{java.lang.Class}.
None of the classes in @file{java.lang.reflect} have public constructors.
@footnote{with the exception of @file{java.lang.reflect.ReflectPermission}.}
To get to these classes, it is necessary to invoke appropriate methods on
@file{Class}.  There are several ways to get a @file{Class} depending on
whether the code has access to an object, the name of the class, a type, or
an existing @file{Class}.

@c _____________________________________

@node Object.getClass
@subsubsection @code{Object.getClass()}
@cindex @code{Object.getClass()}

If an instance of an object is available, then the simplest way to get its
@file{Class} is to invoke @code{Object.getClass()}.

@subsubheading String.getClass()

@example
Class c = "foo".getClass();
@end example

@noindent returns the @file{Class} for @file{String};

@subsubheading System.console.getClass()

@example
Class c = System.console().getClass();
@end example

@noindent
returns the @file{Class} corresponding to @file{java.io.Console}.
@footnote{There is a unique console associated with the virtual machine which
is returned by the @code{static} method @code{System.console()}.}

@subsubheading Enum.getClass()

@example
enum E @{ A, B @}
Class c  = A.getClass();
@end example

@noindent
@file{A} is an instance of the @code{enum} @file{E}; thus, @code{getClass()}
returns the @file{Class} corresponding to the enumeration type @file{E}.

@subsubheading Array.getClass()

Since arrays are @file{Object}s, it is possible to invoke @code{getClass()}
on an instance of an array.  The returned @file{Class} corresponds to an
array with component type @code{byte}.

@example
import java.util.HashSet;
import java.util.Set;

Set<String> s = new HashSet<String>();
Class c = s.getClass();
@end example

@file{java.util.Set} is an interface to an object of type
@file{java.util.HashSet}.  The value returned by @code{getClass()} is the
class corresponding to @file{java.util.HashSet}.

@c _____________________________________

@node .class Syntax
@subsubsection The @code{.class} Syntax
@cindex @code{.class} syntax

If the type is available, but there is no instance, then it is possible to
obtain a @file{Class} by appending @code{.class} to the name of the type.
This is also the easiest way to obtain the @file{Class} for a primitive type.

@subsubheading Primitive.class

@example
boolean b;
Class c = b.getClass();	 // compile-time error
Class c = boolean.class; // correct
@end example

@noindent
The statement @samp{boolean.getClass()} would produce a compile-time error
because a @code{boolean} is a primitive type and cannot be dereferenced.  The
@code{.class} syntax returns the @file{Class} corresponding to the type
@code{boolean}.

@subsubheading Type.class

@example
Class c = java.io.PrintStream.class;
@end example

@noindent
The variable @code{c} will be the @file{Class} corresponding to the type
@file{java.io.PrintStream}.

@subsubheading Multi-dimensional Array

@example
Class c = int[][].class;
@end example

@noindent
The @code{.class} syntax may be used to retrieve a @file{Class} corresonding
to a multi-dimensional array of a given type.

@c _____________________________________

@node Class.forName() and Class.getName() Methods
@subsubsection @code{Class.forName()} and @code{Class.getName()} Methods
@cindex @code{Class.forName()}
@cindex @code{Class.getName()}
@cindex fully-qualified name and reflection

If the fully-qualified name of a class is available, it is possible to get
the corresponding @file{Class} using the @code{static} method
@code{Class.forName()}.  This cannot be used for primitive types.

The syntax for names of array classes is described by @code{Class.getName()}.
This syntax is applicable to references and primitive types.

@subsubheading @code{forName()}

@example
Class c = Class.forName("com.duke.MyLocalServiceProvider");
@end example

@noindent
This statement will create a class from the given fully-qualified name.

@subsubheading @code{getName()}

@FIXME{should these be @code{getName()} instead of @code{forName()}}?

@example
Class cDoubleArray = Class.forName("[D");
Class cStringArray = Class.forName("[[Ljava.lang.String;");
@end example

@noindent
The variable @code{cDoubleArray} will contain the @code{Class} corresponding
to an array of primitive type @code{double} (i.e., the same as
@code{double[].class}.  The @code{cStringArray} variable will contain the
@code{Class} corresponding to a two-dimensional array of @code{String} (i.e.,
identical to String[][].class).

@c _____________________________________

@node TYPE Field for Primitive Wrappers
@subsubsection TYPE Field for Primitive Type Wrappers
@cindex TYPE field for primitive type wrappers

The @code{.class} syntax is a more convenient and the preferred way to obtain
the @file{Class} for a primitive type; however, there is another way to
acquire the @file{Class}.  Each of the primitive types and @code{void} has a
wrapper class in @file{java.lang} that is used for boxing of primitive types
to reference types.  Each wrapper class contains a field name @code{TYPE}
which is equal to the @code{Class} for the primitive type being wrapped.

@subsubheading Wrapper TYPE for Primitive

@example
Class c = Double.TYPE;
@end example

@noindent
There is a class @file{java.lang.Double} which is used to wrap the primitive
type @code{double} whenever an @file{Object} is required.  The value of
@code{Double.TYPE} is identical to that of @code{double.class}.

@subsubheading Wrapper TYPE for void

@example
Class c = Void.TYPE;
@end example

@code{Void.TYPE} is identical to @code{void.class}.  

@c _____________________________________

@node Methods that Return Classes
@subsubsection Methods that Return Classes

There are several @file{Reflection} APIs which return classes, but these may
only be accessed if a @file{Class} has already been obtained, either directly
or indirectly.

@subsubheading @code{Class.getSuperClass()}
@cindex @code{getSuperClass()}

Returns the super class for the given class.

@example
Class c = javax.swing.JButton.class.getSuperclass();
@end example

@subsubheading @code{Class.getClasses()}
@cindex @code{Class.getClasses()}

Returns all the public classes, interfaces, and enums that are members of the
class including inherited members.

@example
Class<?>[] c = Character.class.getClasses();
@end example

@subsubheading @code{Class.getDeclaredClasses()}
@cindex @code{getDeclaredClasses()}

Returns all of the classes interfaces, and enums that are explicitly declared
in this class.

@example
Class<?>[] c = Character.class.getDeclaredClasses();
@end example

@subsubheading @code{Class.getDeclaringClass()}
@cindex @code{getDeclaringClass()}

@display
java.lang.reflect.Field.getDeclaringClass()
java.lang.reflect.Method.getDeclaringClass()
java.lang.reflect.Constructor.getDeclaringClass()
@end display

@noindent
Returns the @file{Class} in which these members were
declared. @file{Anonymous Class Declarations} will not have a declaring class
but will have an enclosing class.

@example
import java.lang.reflect.Field;

Field f = System.class.getField("out");
Class c = f.getDeclaringClass();
@end example

@noindent The field out is declared in @file{System}.

@example
public class MyClass @{
    static Object o = new Object() @{
        public void m() @{@}
    @};
    static Class<c> = o.getClass().getEnclosingClass();
@}
@end example

The declaring class of the anonymous class defined by @code{o} is @code{null}

@subsubheading @code{Class.getEnclosingClass()}
@cindex @code{getEnclosingClass()}

Returns the immediately enclosing class of the class.

@example
Class c = Thread.State.class().getEnclosingClass();
@end example

@noindent
The enclosing class of the enum @file{Thread.State} is @file{Thread}.

@example
public class MyClass @{
    static Object o = new Object() @{
        public void m() @{@} 
    @};
    static Class<c> = o.getClass().getEnclosingClass();
@}
@end example

The anonymous class defined by @code{o} is enclosed by @code{MyClass}.


@c .....................................

@node Examining Class Modifiers
@subsection Examing Class Modifiers and Types
@cindex class modifiers, examining
@cindex class types, examing

A class may be declared with one or more modifiers which affect its runtime
behavior:

@itemize
@item
Access modifiers: public, protected, and private
@item
Modifier requiring override: abstract
@item
Modifier restricting to one instance: static
@item
Modifier prohibiting value modification: final
@item
Modifier forcing strict floating point behavior: strictfp
@item
Annotations
@end itemize

Not all modifiers are allowed on all classes, for example an interface cannot
be @code{final} and an @code{enum} cannot be @code{abstract}.
@code{java.lang.reflect.Modifier} contains declarations for all possible
modifiers.  It also contains methods which may be used to decode the set of
modifiers returned by @code{Class.getModifiers()}.


@c .....................................

@node Discovering Class Members
@subsection Discovering Class Members
@cindex class members, discovering

There are two categories of methods provided in @file{Class} for accessing
fields, methods, and constructors:

@enumerate
@item
methods which enumerate these members; and
@item
methods which search for particular members.
@end enumerate

@noindent
Also there are distinct methods for

@itemize
@item
accessing members declared directly on the class; versus 
@item
methods which search the superinterfaces and superclasses
for inherited members.
@end itemize

The following tables provide a summary of all the member-locating methods and
their characteristics.

@float Table,ClassMethodsLocating
@center @b{Class Methods for Locating Fields}
@multitable @columnfractions .27 .23 .25 .23
@headitem @file{Class} API @tab List of members? @tab Inherited members? @tab Private members?
@item getDeclarareField() @tab no  @tab no  @tab yes
@item getField()          @tab no  @tab yes @tab no
@item getDeclaredFields() @tab yes @tab no  @tab yes
@item getFields()         @tab yes @tab yes @tab no
@end multitable

@sp 2

@center @b{Class Methods for Locating Methods}
@multitable @columnfractions .27 .23 .25 .23
@headitem @file{Class} API @tab List of members? @tab Inherited members? @tab Private members?
@item getDeclarareMethod() @tab no  @tab no  @tab yes
@item getMethod()          @tab no  @tab yes @tab no
@item getDeclaredMethods() @tab yes @tab no  @tab yes
@item getMethods()         @tab yes @tab yes @tab no
@end multitable

@sp 2

@center @b{Class Methods for Locating Constructors}
@multitable @columnfractions .27 .23 .25 .23
@headitem @file{Class} API @tab List of members? @tab Inherited members? @tab Private members?
@item getDeclarareConstructor() @tab no  @tab N/A@footnote{Constructors are not inherited} @tab yes
@item getConstructor()          @tab no  @tab N/A @tab no
@item getDeclaredConstructors() @tab yes @tab N/A @tab yes
@item getConstructors()         @tab yes @tab N/A @tab no
@end multitable
@caption{Class Methods for Locating Fields, Methods, and Constructors}
@shortcaption{Class Methods Locating}
@end float




@c -----------------------------------------------------------------------------

@node Members and Reflection
@section Members and Reflection
@cindex Members and Reflection
@cindex @file{java.lang.reflect.Member} interface

Reflection defines an interface @file{java.lang.reflect.Member} which is
implemented by

@itemize
@item @file{java.lang.reflect.Field}, 
@item @file{java.lang.reflect.Method}, and
@item @file{java.lang.reflect.Constructor}.
@end itemize

For each member, the lesson will describe the associated APIs to retrieve
declaration and type information, any operations unique to the member (for
example, setting the value of a field or invoking a method), and commonly
encountered errors. Each concept will be illustrated with code samples and
related output which approximate some expected reflection uses.

@subheading Note about Members and the Specification

According to The Java Language Specification, Java SE 7 Edition, the
@dfn{members of a class} are the inherited components of the class body
including fields, methods, nested classes, interfaces, and enumerated
types. Since constructors are not inherited, they are not members. This
differs from the implementing classes of @file{java.lang.reflect.Member}.


@c .....................................

@node reflect Fields
@subsection @file{reflect.Fields}
@cindex Fields, reflection
@cindex @file{java.lang.reflect.Field} class

Fields have a type and a value. The @file{java.lang.reflect.Field} class
provides methods for accessing type information and setting and getting
values of a field on a given object.


@c .....................................

@node reflect Methods
@subsection @file{reflect.Method}
@cindex Methods, reflection
@cindex @file{java.lang.reflect.Method} class

Methods have return values, parameters, and may throw exceptions. The
@file{java.lang.reflect.Method} class provides methods for obtaining the type
information for the parameters and return value. It may also be used to
invoke methods on a given object.


@c .....................................

@node reflect Constructors
@subsection @file{reflect.Constructors}
@cindex Constructor, reflection
@cindex @file{java.lang.reflect.Constructor}

The Reflection APIs for constructors are defined in
@file{java.lang.reflect.Constructor} and are similar to those for methods,
with two major exceptions: first, constructors have no return values; second,
the invocation of a constructor creates a new instance of an object for a
given class.

Similar to methods, reflection provides APIs to

@itemize
@item
discover and retrieve the constructors of a class and
@item
obtain declaration information such as the modifiers, parameters,
annotations, and thrown exceptions.
@item
New instances of classes may also be created using a specified constructor.
@end itemize

The key classes used when working with constructors are @file{Class} and
@file{java.lang.reflect.Constructor}. Common operations involving
constructors are covered in the following sections.

@c _____________________________________

@node Finding Constructors
@subsubsection Finding Constructors
@cindex constructors, finding
@cindex @file{java.lang.reflect.Constructor}

This section illustrates how to retrieve constructors with specific
parameters.

A constructor declaration includes the name, modifiers, parameters, and list
of throwable exceptions. The @file{java.lang.reflect.Constructor} class provides a
way to obtain this information.

@c _____________________________________

@node Constructor Modifiers
@subsubsection Retrieving and Parsing Constructor Modifiers
@cindex constructor modifiers, retrieving and parsing

This section shows how to obtain the modifiers of a constructor declaration
and other information about the constructor.

Because of the role of constructors in the language, fewer modifiers are
meaningful than for methods:

@itemize
@item Access modifiers:
@itemize
@item @code{public},
@item @code{protected}, and
@item @code{private}
@end itemize
@item Annotations
@end itemize

@c _____________________________________

@node Creating New Class Instances
@subsubsection Creating New Class Instances
@cindex class instance, creating new
@cindex object, instantiate using reflection API
@cindex @code{java.lang.reflect.Constructor.newInstance()}
@cindex @code{Class.newInstance()}

This section shows how to instantiate an instance of an object by invoking
its constructor.

There are two reflective methods for creating instances of classes:

@enumerate
@item @code{java.lang.reflect.Constructor.newInstance()} and
@item @code{Class.newInstance()}.
@end enumerate

The former is preferred and is thus used in these examples because:

@itemize
@item
@code{Class.newInstance()} can only invoke the zero-argument constructor,
while @code{Constructor.newInstance()} may invoke any constructor, regardless
of the number of parameters.
@item
@code{Class.newInstance()} throws any exception thrown by the constructor,
regardless of whether it is checked or unchecked.
@code{Constructor.newInstance()} always wraps the thrown exception with an
@file{InvocationTargetException}.
@item
@code{Class.newInstance()} requires that the constructor be visible;
@code{Constructor.newInstance()} may invoke private constructors under
certain circumstances.
@end itemize




@c -----------------------------------------------------------------------------

@node Arays and Enumerated Types and Reflection
@section Arrays and Enumerate Types and Reflection
@cindex Arrays, reflection
@cindex Enumerate types, reflection

From the Java virtual machine's perspective, arrays and enumerated types (or
@code{enums}) are just classes.  Many of the methods in @file{Class} may be
used on them.  Reflection provides a few specific APIs for arrays and
enums.  This lesson uses a series of code samples to describe how to
distinguish each of these objects from other classes and operate on
them.  Various errors are also be examined.


@c .....................................

@node Arrays and Reflection
@subsection Arrays and Reflection
@cindex Arrays, reflection
@cindex @file{java.lang.reflect.Array}

Arrays have a component type and a length (which is not part of the
type). Arrays may be maniuplated either in their entirety or component by
component. Reflection provides the @file{java.lang.reflect.Array} class for
the latter purpose.

@c _____________________________________

@node Identifying Array Types
@subsubsection Identifying Array Types

Array types may be identified by invoking @code{Class.isArray()}. To obtain a
@file{Class} use one of the methods described in @ref{Retrieving Class
Objects} section.

@c _____________________________________

@node Creating New Arrays
@subsubsection Creating New Arrays
@cindex arrays, creating new

Just as in non-reflective code, reflection supports the ability to
dynamically create arrays of arbitrary type and dimensions via
@code{java.lang.reflect.Array.newInstance()}. Consider ArrayCreator, a basic
interpreter capable of dynamically creating arrays. The syntax that will be
parsed is as follows:

@example
fully_qualified_class_name variable_name[] =
	@{ val1, val2, val3, ... @}
@end example

@c _____________________________________

@node Getting and Setting Arrays
@subsubsection Getting and Setting Arrays and Their Components
@cindex arrays, getting and setting
@cindex @code{java.lang.reflect.Field.set()}
@cindex @code{Field.get(Object)}
@cindex @file{java.lang.reflect.Array}

Just as in non-reflective code, an array field may be set or retrieved in its
entirety or component by component. To set the entire array at once, use
@code{java.lang.reflect.Field.set(Object obj, Object value)}. To retrieve the
entire array, use @code{Field.get(Object)}. Individual components can be set
or retrieved using methods in @file{java.lang.reflect.Array}.

@file{Array} provides methods of the form @code{setFoo()} and @code{getFoo()}
for setting and getting components of any primitive type.  For example, the
component of an int array may be set with @samp{Array.setInt(Object array,
int index, int value)} and may be retrieved with @samp{Array.getInt(Object
array, int index)}.

@subsubheading Setting a Field of Type Array

@subsubheading Accessing Elements of a Multidimensional Array


@c .....................................

@node Enumerate Types and Reflection
@subsection Enumerated Types and Reflection
@cindex Enumerated types, refelction
@cindex @code{Class.isEnum()}
@cindex @code{Class.getEnumConstants()}
@cindex @code{java.lang.reflect.Field.isEnumConstant()}

Enums are treated very much like ordinary classes in reflection code.
@code{Class.isEnum()} tells whether a @file{Class} represents an enum.
@code{Class.getEnumConstants()} retrieves the enum constants defined in an
enum.  @code{java.lang.reflect.Field.isEnumConstant()} indicates whether a
field is an enumerated type.

@c _____________________________________

@node Enumerated Types Reflection
@subsubsection Enumerated Types in Reflection
@cindex enumerate types, reflection
@cindex @code{Class.isEnum()}
@cindex @code{Class.getEnumConstants()}
@cindex @code{java.lang.reflect.Field.isEnumConstant()}

An @dfn{enum} is a language construct that is used to define type-safe
enumerations which can be used when a fixed set of named values is desired.
All @code{enums} implicitly extend @file{java.lang.Enum}.  @code{Enums} may
contain one or more @code{enum} constants, which define unique instances of
the @code{enum} type.  An @code{enum} declaration defines an @code{enum} type
which is very similar to a class in that it may have members such as fields,
methods, and constructors (with some restrictions).

Since @code{enums} are classes, reflection has no need to define an explicit
java.lang.reflect.Enum class.  The only Reflection APIs that are specific to
@code{enums} are @code{Class.isEnum()}, @code{Class.getEnumConstants()}, and
@code{java.lang.reflect.Field.isEnumConstant()}.  Most reflective operations
involving @code{enums} are the same as any other class or member.  For
example, @code{enum} constants are implemented as @code{public static final}
fields on the @code{enum}.  The following sections show how to use
@file{Class} and @file{java.lang.reflect.Field} with @code{enums}.

@subsubheading Examining Enums

Illustrates how to retrieve an enum's constants and any other fields,
constructors, and methods

Reflection provides three enum-specific APIs:

@table @code
@item Class.isEnum()
Indicates whether this class represents an enum type
@item Class.getEnumConstants()
Retrieves the list of enum constants defined by the enum in the order they're declared
@item java.lang.reflect.Field.isEnumConstant()
Indicates whether this field represents an element of an enumerated type
@end table

Sometimes it is necessary to dynamically retrieve the list of enum constants;
in non-reflective code this is accomplished by invoking the implicitly
declared static method @code{values()} on the enum.  If an instance of an
@code{enum} type is not available the only way to get a list of the possible
values is to invoke @code{Class.getEnumConstants()} since it is impossible
to instantiate an @code{enum} type.

@subsubheading Getting and Setting Fields with Enum Types

Shows how to set and get fields with an enum constant value

Fields which store @code{enums} are set and retrieved as any other reference
type, using @code{Field.set()} and @code{Field.get()}. For more information
on accessing fields, see the Fields section.  @xref{reflect Fields}
















@c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@part GUI Programming with Swing








@c *****************************************************************************

@node Introducing Swing
@chapter Introducing Swing
@cindex Swing
@cindex GUI Programming with Swing








@c *****************************************************************************

@node Exploring Swing
@chapter Exploring Swing
@cindex Swing Exploring








@c *****************************************************************************

@node Swing Menus
@chapter Introducing Swing Menus
@cindex Swing Menus








@c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@part GUI Programming with JavaFX

@c *****************************************************************************

@node Introducing JavaFX
@chapter Introducing JavaFX GUI Programming
@cindex JavaFX
@cindex GUI Programming with JavaFX








@c *****************************************************************************

@node Exploring JavaFX Controls
@chapter Exploring JavaFX Controls
@cindex JavaFX Controls








@c *****************************************************************************

@node Introducing JavaFX Menus
@chapter Introducing JavaFX Menus
@cindex JavaFX Menus
















@c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@part Applying Java








@c *****************************************************************************

@node Java Beans
@chapter Java Beans
@cindex Java Beans








@c *****************************************************************************

@node Servlets
@chapter Introducing Servlets
@cindex Servlets
















@c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@part APPENDICES








@c *****************************************************************************

@node Documentation Comments
@appendix Using Java's Documentation Comments
@cindex Documentation comments
@cindex @file{javadoc}
@cindex JDK 9 modules and @file{javadoc}

Java supports three types of comments.

@itemize
@item
@kbd{//}
@item
@kbd{/* */}
@item
@kbd{/** */}
@end itemize

The third is called a @dfn{documwentation comment}.  Documentation comments
allow you to embed information about your program into the program itself.  You
can then use the @file{javadoc} utility progrm to extract the information and
put it into an HTML file.  Documentation comments make it convenient to
document your programs.  Beginning with JDK 9,m @file{javadoc} includes support
for modules.




@c -----------------------------------------------------------------------------

@node javadoc Documentation Tags
@section @file{javadoc} Documentation Tags
@cindex @file{javadoc} tags
@cindex documentation tags

The @file{javadoc} utility recognizes several tags, including:

@float Table,JavaDocTags
@multitable @columnfractions .25 .75
@item
@@author @tab Identifies the author.
@item
@{@@code@} @tab Displays information as-is, without processing HTML styles, in
code font.
@item
@@deprecated @tab Specifies that a program element is deprecated.
@item
@{@@docRoot@} @tab Specifies the path to the root directory of the current
documentation.
@item
@@exception @tab Identifies an exception thrown by a method or constructor.
@item
@@hidden @tab Prevents an element from appearing in the documentation.  (Added by
JDK 9.)
@item
@{@@index@} @tab Specifies a term for indexing.  (Added by JDK 9.)
@item
@{@@inheritDoc@} @tab Inherits a comment from the immediate superclass.
@item
@{@@link@} @tab Inserts an in-line link to another topic.
@item
@{@@linkplain@} @tab Inserts an in-line link to another topic, but the link is
displayed in a plain-text font.
@item
@{@@literal@} @tab Displays information as-is without processing HTML styles.
@item
@@param @tab Documents a parameter.
@item
@@provides @tab Documents a service provided by a module.  (Added by JDK 9.)
@item
@@return @tab Doicuments a method's return value.
@item
@@see @tab Specifies a link to another topic.
@item
@@serial @tab Documents a default serializable field.
@item
@@serialData @tab Documents the data written by the @code{writeObject()} or
@code{writeExternal()} methods.
@item
@@serialField @tab Dcouments an @code{ObjectStreamField} component.
@item
@@since @tab States the release when a specific change was introduced.
@item
@@throws @tab Same as @code{@@exception}.
@item
@@uses @tab Documents a service needed by a module.  (Added by JDK 9.)
@item
@{@@value@} @tab Displays the value of a constant, which must be a @code{static}
field.
@item
@@version @tab Specifies the version of a program element.
@end multitable
@caption{The @file{javadoc} Tags}
@end float

@cindex stand-alone tags
@cindex block tags
@cindex in-line tags
@cindex tags, stand-alone, block, in-line

Document tags that begin with an ``at'' sign @kbd{@@} are called
@dfn{stand-alone} tags (also called @dfn{block} tags), and they must be used on
their own line.  Tags that begin with a brace, such as @code{@{@@code@}}, are
called @dfn{in-line} tags, and they can be used within a larger description.
You may also use other, standard HTML tags in a documentation comment.
However, some tags, such as headings, should not be used because they disrupt
the look of the HTML file produced by @file{javadoc}.

You can use documentation comments to document classes, interfaces, fields,
constructors, methods, and modules.  In all cases, the documentation comment
must immediately prcede the item being documented.  Some tags, such as
@code{@@see}, @code{@@since}, and @code{@@deprecated}, can be used to document
any element.  Other tags apply only to the relevant elements.


@c .....................................

@node @@author
@subsection @code{@@author}
@cindex @code{@@author}

The @code{@@author} tag documents the author of a program element.  It has the
following syntax:

@display
@@author @samp{description}
@end display

The @i{description} will usually be the name of the author.  You will need to
specify the @code{-author} option when executing @file{javadoc} in order for
the @code{@@author} field to be included in the HTML documentation.


@c .....................................

@node @@code
@subsection @code{@{@@code@}}
@cindex @code{@{@@code@}}

The @code{@{@@code@}} tag enables you to embed text, such as a snippet of code,
into comment.  That text is then displayed as-is in code font, without any
furhter processsing, such as HTML rendering.  It has the following syntax:

@display
@code{@{@@code @samp{code-snippet}@}}
@end display

@c .....................................

@node @@deprecated
@subsection @code{@@deprecated}
@cindex @code{@@deprecated}

The @code{@@deprecated} tag specifies that a program element is deprecated.  It
is recommended that you include @code{@@see} or @code{@{@@link@}} tags to
inform the programmer about available alternatives.  The syntax is:

@display
@@deprecated @samp{description}
@end display


@c .....................................

@node @@docRoot
@subsection @code{@{@@docRoot@}}
@cindex @code{@{@@docRoot@}}

@code{@{@@docRoot@}} specifies the path to to the root directory of the current
documentation.

@c .....................................

@node @@exception
@subsection @code{@@exception}
@cindex @code{@@exception}

The @code{@@exception} tag describes an exception to a method.  It has the
following syntax:

@display
@@exception @samp{exception-name explanation}
@end display

Here, the fully qualified name of the exception is specified by an
@samp{exception-name} and @samp{explanation} is a string that describes how the
exception can occur.  It can be used only in documentation for a method or
constructor.

@c .....................................

@node @@hidden
@subsection @code{@@hidden}
@cindex @code{@@hidden}

The @code{@@hidden} tag prevents an element from appearing in the
documentation.

@node @@index
@subsection @code{@{@@index@}}
@cindex @code{@{@@index@}}

The @code{@{@@index@}} tag specifies an item that will be indexed and returned,
and thus found when using the search feature added by JDK 9.  It has the
following syntax:

@display
@{ @@index @samp{term usage-str} @}
@end display

Here, @samp{term} is the item (which can be a quoted string) to be indexed;
@samp{usage-str} is optional.  Thus, in the following @code{@@exception} tag,
@code{@{@@index@}} causes the ``error'' to be added to the index:

@example
@@exception IOException On input @{@@index error@}
@end example

Note that the word ``error'' is still displayed as part of the description.
Now it is also indexed.  If you include the optional @samp{usage-str}, then
that description will be shown in the index and in the search box to indicate
how the term is used.


@c .....................................

@node @@inheritDoc
@subsection @code{@{@@inheritDoc@}}
@cindex @code{@{@@inheritDoc@}}

This tag inherits a comment from the immediate superclass.


@c .....................................

@node @@link
@subsection @code{@{@@link@}}
@cindex @code{@{@@link@}}

The @code{@{@@link@}} tag prvoides an in-line link to additional information.
It has the following syntax:

@display
@{@@link @samp{pkg.class#member text}@}
@end display

Here, @samp{pkg.class#member} specifies the name of a class or method to which
a link is added, and @samp{text} is the string that is displayed.


@c .....................................

@node @@linkplain
@subsection @code{@{@@linkplain@}}
@cindex @code{@{@@linkplain@}}

Inserts an in-line link to another topic.  The link is displayed in plain-text
font.  Otherwise it is similar to @code{@{@@link@}}.


@c .....................................

@node @@literal
@subsection @code{@{@@literal@}}
@cindex @code{@{@@literal@}}

The @code{@{@@literal@}} tag enables you to embed text into a comment.  That
text is then displayed as-is, without any further processing, such as HTML
rendering.  It has the following syntax:

@display
@{@@literal @samp{description}@}
@end display


Here, @samp{description} is the text that is embedded.


@c .....................................

@node @@param
@code{@@param}
@cindex @code{@@param}

The @code{@@param} tag documents a parameter.  It has the following syntax:

@display
@@param @samp{parameter-name explanation}
@end display

Here, @samp{paramter-name} specifies the name of a parameter.  That meaning of
that parameter is described by @samp{explanation}.  The @code{@@param} tag can
be used only in documentation for a method or constructor, or a generic class
or interface.


@c .....................................

@node @@provides
@subsection @code{@@provides}
@cindex @code{@@provides}

The @code{@@provides} tag documents a service provided by a module.  It has the
following syntax:

@display
@@provides @samp{type explanation}
@end display

Here, @samp{type} specifies a service provider type and @samp{explanation}
describes the service provider.


@c .....................................

@node @@return
@subsection @code{@@return}
@cindex @code{@@return}

The @code{@@return} tag describes the return value of a method.  It has the
following syntax:

@display
@@return @samp{explanation}
@end display


Here, @samp{explanation} describes the type and meaning of the value returned
by a method.  The @code{@@return} tag can be used only in documentation for a
method.


@c .....................................

@node @@see
@subsection @code{@@see}
@cindex @code{@@see}

The @code{@@see} tag provides a reference to additional information.  Two
commonly used forms are shown here:

@display
@@see @samp{anchor}
@@see @samp{pkg.class#member text}
@end display

In the first form, @samp{anchor} is a link to an absolute or relative URL.  In
the second form, @samp{pkg.class#member} specifies the name of the item, and
@samp{text} is the text displayed for that item.  The text parameter is
optional and if not used, then the item specified by @samp{pkg.class#member} is
displayed.  The member name, too, is optional.  Thus, you can specify a
reference to a package, class, or interface in addition to a refernce to a
specific method or field.  The name can be fully qualified or partially
qualified.  However, the dot that precedes the member name (if it exists) must
be replaced by a hash character.


@c .....................................

@node @@serial
@subsection @code{@@serial}
@cindex @code{@@serial}

The @code{@@serial} tag defines the comment for a default serializable field.
It has the following syntax:

@display
@@serial @samp{description}
@end display


@samp{description} is the comment for that field.


@c .....................................

@node @@serialData
@subsection @code{@@serialData}
@cindex @code{@@serialData}

The @code{@@serialData} tag documents the data written by the
@code{writeObject()} and @code{writeExternal()} methods.  It has the following
syntax:

@display
@@serialData @samp{description}
@end display


@samp{description} is the comment for that data.


@c .....................................

@node @@serialField
@subsection @code{@@serialField}
@cindex @code{@@serialField}

For a class that implements @file{Serializable}, the @code{@@serialField} tag
provides comments for an @file{ObjectStreamField} component.  It has the
following syntax:

@display
@@serialField @samp{name type description}
@end display


@samp{name} is the name of the field, @samp{type} is its type, and
@samp{description} is the comment for that field.


@c .....................................

@node @@since
@subsection @code{@@since}
@cindex @code{@@since}

The @code{@@since} tag states that an element was introduced in a specific
release.  It has the following syntax:

@display
@@since @samp{release}
@end display


@samp{release} is a string that designates the release or version in which this
feature became available.


@c .....................................

@node @@throws
@subsection @code{@@throws}
@cindex @code{@@throws}

The @code{@@throws} tag has the same meaning as the @code{@@exception} tag.


@c .....................................

@node @@uses
@subsection @code{@@uses}
@cindex @code{@@uses}

The @code{@@uses} tag documents a service provider neede by a module.  It has
the following syntax:

@display
@@uses @samp{type explanation}
@end display


@samp{type} specifies a service provider type and @samp{explanation} describes
the service.


@c .....................................

@node @@value
@subsection @code{@{@@value@}}
@cindex @code{@{@@value@}}

@code{@{@@value@}} has two forms.  The first displays the value of the constant
that it precedes, which must be a @code{static} field.  It has this form:

@display
@{@@value@}
@end display

The second form displays the value of a specified @code{static} field.  It has
the form:

@display
@{@@value @samp{pkg.class#field}@}
@end display

@samp{pkg.class#field} specifies the name of the @code{static} field.


@c .....................................

@node @@version
@subsection @code{@@version}
@cindex @code{@@version}

The @code{@@version} tag specifies the version information, typically a version
number, such as 2.2.  You will need to specify the @code{-version} option when
executing @file{javadoc} in order for the @code{@@version} field to be included
in the HTML documentation.




@c -----------------------------------------------------------------------------

@node Documentation Comment General Form
@section The General Form of a Documentation Comment
@cindex Documentation Comment general form

After the beginning @kbd{/**}, the first line or lines become the main
description of your class, interface, field, constructor, method, or module.
After that, you can include one or more the various @@ tags.  Each @@ tag must
start at the beginning of a new line or follow one or more asterisks (@kbd{**})
that are at the start of a line.  Multiple tags of the same type should be
grouped together.  In-line tags (thse that being with a brace (@kbd{@{}) can be
used within any description.




@c -----------------------------------------------------------------------------

@node What @file{javadoc} Outputs
@section What @file{javadoc} Outputs
@cindex @file{javadoc} output

The @file{javadoc} program takes as input your Java program's source file and
outputs several HTML files that contain the program's documentation.
Information about each class will be in its own HTML file.  @file{javadoc} will
also output an index and a hierarchy tree.  Other HTML files can be generated.
Beginning with JDK 9, a search box feature is also included.




@c -----------------------------------------------------------------------------

@node Documentation Comments Example
@section An Example that Uses Documentatation Comments
@cindex documentation comments example

Following is a sample program that uses documentation comments.  Notice the way
each comment immediately precedes the item that it describes.  After begin
processed by @file{javadoc}, the documentation about the @file{SquareNum} class
will be found in @file{SquareNum.html}.


@subheading @file{SquareNum.java}

@(SquareNum.java@)=
@<Import java.io@>

@<SquareNum---SquareNum Class@>
@

@c .....................................

@node SquareNum---SquareNum Class
@subsection SquareNum---SquareNum Class

@<SquareNum---SquareNum Class@>=
@<SquareNum---SquareNum Class--Documentation@>
@<SquareNum---SquareNum Class--Body@>

@

@c _____________________________________

@node SquareNum---SquareNum Class--Documentation
@subsubsection SquareNum---SquareNum Class--Documentation

@<SquareNum---SquareNum Class--Documentation@>=
/**
   This class demonstrates documentation comments.
   @author Herbert Schildt
   @version 1.2
 */
@

@subsubheading SquareNum---SquareNum Class--Body

@<SquareNum---SquareNum Class--Body@>=
public class SquareNum {
  @<SquareNum---square() Method@>
  @<SquareNum---getNumber() Method@>
  @<SquareNum---main() Method@>
}
@


@c .....................................

@node SquareNum---square() Method
@subsection SquareNum---square() Method

@<SquareNum---square() Method@>=
  @<SquareNum---square() Method--Documentation@>
  @<SquareNum---square() Method--Body@>
@

@c _____________________________________

@node SquareNum---square() Method Doc and Body
@subsubheading SquareNum---square() Method Doc and Body

@subsubheading SquareNum---square() Method--Documentation@

@<SquareNum---square() Method--Documentation@>=
/**
   This method returns the square of num.
   This is a multiline description.  You can use
   as many lines as you like.
   @param num The value to be squared.
   @return num squared.
 */
@

@subsubheading SquareNum---square() Method--Body

@<SquareNum---square() Method--Body@>=
  public double square(double num) {
    return num * num;
  }

@

@c .....................................

@node SquareNum---getNumber() Method
@subsection SquareNum---getNumber() Method

@<SquareNum---getNumber() Method@>=
  @<SquareNum---getNumber() Method--Documentation@>
  @<SquareNum---getNumber() Method--Body@>
@

@c _____________________________________

@node SquareNum---getNumber() Method Doc and Body
@subsubsection SquareNum---getNumber() Method Doc and Body

@subsubheading SquareNum---getNumber() Method--Documentation

@<SquareNum---getNumber() Method--Documentation@>=
/**
   This method inputs a number from the user.
   @return The value input as a double.
   @exception IOException On input error.
   @see IOException
 */
@

@subsubheading SquareNum---getNumber() Method--Body

@<SquareNum---getNumber() Method--Body@>=
public double getNumber() throws IOException {
  // create a BufferedReader using System.in
  InputStreamReader isr = new InputStreamReader (System.in);
  BufferedReader inData = new BufferedReader(isr);
  String str;

  str = inData.readline();
  return (new Double(str)).doubleValue();
}

@


@c .....................................

@node SquareNum---main() Method
@subsection SquareNum---main() Method

@<SquareNum---main() Method@>=
  @<SquareNum---main() Method--Documentation@>
  @<SquareNum---main() Method--Body@>
@

@subsubheading SquareNum---main() Method--Documentation

@<SquareNum---main() Method--Documentation@>=
/**
   This method demonstrates square().
   @param args Unused.
   @exception IOException On input error.
   @see IOException
 */
@

@subsubheading SquareNum---main() Method--Body

@<SquareNum---main() Method--Body@>=
public static void main(String[] args) {
  SquareNum ob = new SquareNum();
  double val;

  System.out.println("Enter value to be squared: ");
  val = ob.getNumber();
  val = ob.square(val);

  System.out.println("Square value is " + val);
}
@








@c *****************************************************************************

@node Java Web Start
@appendix An Overview of Java Web Start
@cindex Java Web Start







@c *****************************************************************************

@node JShell
@appendix Introducing JShell
@cindex JShell








@c *****************************************************************************

@node Applet Basics
@appendix Applet Basics
@cindex Applet
















@c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@part MAKEFILE








@c *****************************************************************************

@node The Makefile
@appendix The Makefile
@cindex Makefile, The (appendix)

@(Makefile@)=
@<Makefile CONSTANTS@>
@<Makefile DEFAULTS@>
@<Makefile TANGLE WEAVE@>
@<Makefile PDF@>
@<Makefile HTML@>
@<Makefile CLEAN Targets@>
@<Makefile MAKEFILE Target@>
@

@node Makefile Constants
@appendixsec Makefile Constants
@cindex Constants

@FIXME{Relativize ROOT}

@<Makefile CONSTANTS@>=
ROOT := /usr/local/dev/programming/Java/JavaSE9
FILENAME := JavaSE9
AUX := {aux,cps,fns,log,toc}
@

@node Makefile Defaults
@appendixsec Makefile Default Targets
@cindex Makefile defaults

@<Makefile DEFAULTS@>=
.PHONY: all
all: tangle weave

@

@node Make the Makefile
@appendixsec Make the Makefile
@cindex Make the Makefile

@<Makefile MAKEFILE Target@>=

.PHONY : makefile
makefile : jrtangle worldclean

@

@node Makefile Tangle Weave
@appendixsec Makefile Tangle Weave Targets
@cindex Makefile Tangle
@cindex Makefiel Weave

@<Makefile TANGLE WEAVE@>=
.PHONY: tangle weave jrtangle jrweave texi

tangle: jrtangle
weave: jrweave

jrtangle: $(FILENAME).twjr
	jrtangle $(FILENAME).twjr

jrweave: texi

texi: $(FILENAME).texi

$(FILENAME).texi: $(FILENAME).twjr
	jrweave $(FILENAME).twjr > $(FILENAME).texi
@

@node Makefile PDF
@appendixsec Makefile PDF
@cindex Makefile PDF

@<Makefile PDF@>=
@<Makefile MAKEPDF@>
@<Makefile OPENPDF@>

@

@node Makefile MAKEPDF
@appendixsubsec Makefile MAKEPDF
@cindex Makefile MAKEPDF

@<Makefile MAKEPDF@>=
.PHONY : makepdf
makepdf : ${FILENAME}.pdf

${FILENAME}.pdf : ${FILENAME}.texi
	pdftexi2dvi ${FILENAME}.texi

@

@node Makefile OPENPDF
@appendixsubsubsec Makefile OPENPDF
@cindex Makefile OPENPDF

@<Makefile OPENPDF@>=
.PHONY : pdf
pdf : makepdf
	open ${FILENAME}.pdf

@

@node Makefile HTML
@appendixsec Makefile HTML
@cindex Makefile HTML

@<Makefile HTML@>=
.PHONY: html
html : ${FILENAME}.texi
	makeinfo --html ${FILENAME}.texi

@

@node Makefile Clean Targets
@appendixsec Makefile Clean Targets
@cindex Makefile Clean targets

@<Makefile CLEAN Targets@>=
@<Makefile CLEAN@>
@<Makefile DISTCLEAN@>
@<Makefile WORLDCLEAN@>

@

@node Makefile Clean 
@appendixsubsec Makefile Clean
@cindex Makefile Clean

@<Makefile CLEAN@>=
.PHONY: clean
clean:
	rm -f *~
	rm -f $(FILENAME).??

@

@node Makefile DistClean
@appendixsubsec Makefile DistClean
@cindex Makefile DistClean

@<Makefile DISTCLEAN@>=
.PHONY : distclean
distclean : clean
	rm -fv ${FILENAME}.${AUX}

@

@node Makefile WorldClean
@appendixsubsec Makefile WorldClean
@cindex Makefile WorldClean

@<Makefile WORLDCLEAN@>=
.PHONY: worldclean
worldclean :
	for file in ${ROOT}/*; do \
	  [ \
	    $${file} != "${ROOT}/${FILENAME}.twjr" -a \
	    $$file != "${ROOT}/Makefile" -a \
	    $$file != ".git" \
	  ] \
	  && rm -rfv "$${file}" || :; \
	done

@

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@node List of Tables
@unnumbered List of Tables
@listoffloats Table

@node List of General Forms
@unnumbered List of General Forms
@listoffloats GeneralForm

@node Bibliography
@unnumbered Bibliography

@node Concept Index
@unnumbered Index

@printindex cp

@node Function Index
@unnumbered Function Index

@printindex fn

@node Program Index
@unnumbered Program Index

@printindex pg

@bye

TODO:
