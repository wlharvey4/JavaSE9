\input texinfo   @c -*-texinfo-*-

@c %**start of header (This is for running Texinfo on a region.)
@setfilename JavaSE9.info
@settitle About Java SE 9
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH AUGUST, 2018
@set EDITION 0.1

@set TITLE Outline Covering Java SE 9
@set SHORTTITLE Java SE 9 Outline

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@ignore
@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} YYYY, YYYY @*
Full name here @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The FOO program is copyright
@copyright{} YYYY, YYYY by Full name here. It is published under
the conditions of the GNU General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying
@end ignore

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author LOLH

@ignore COPYRIGHT PAGES
@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Full name here @*
Address Line 1 @*
Address Line 2 @*
etc. @*
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@end ignore
@end titlepage

@set DRAFT @i{DRAFT}

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @value{TITLE}.

@c @insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@ignore
PREFATORY MATTER THRU ACKNOWLEDGEMENTS

@node Preface
@c @unnumbered Preface

Text here.

@node Audience
@c @unnumberedsec Intended Audience

Text here.

@node Overview
@c @unnumberedsec What Is Covered

Text and chapter by chapter description here.

@node Conventions
@c @unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@c @unnumberedsec Acknowledgements

@end ignore

@node Java SE 9 Introduction
@chapter Java SE 9 Introduction
@cindex Java SE 9 introduction
@cindex introduction to Java SE 9

@c *****************************************************************************
@node Packages
@chapter Packages
@cindex Packages (chapter)
@cindex containers, packages as
@cindex compartmentalized
@cindex class namespace, compartmentalize
@cindex packages, purposes, prevent collisions
@cindex collisions, prevention
@cindex packages, how stored
@cindex packages, import
@cindex import packages
@cindex hierarchical structure, packages

@ii{Packages} are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file names.
Packages are stored in a heirarchical manner and are explicitly imported into
new class definitions.

@node Packages Intro
@section Introduction to Packages
@cindex Introduction to Packages (section)
@cindex partitioning mechanism
@cindex naming mechanism
@cindex visibility mechanism
@cindex accessibility
@cindex exposure of code

Java provides a mechanism for partitioning the class name space into
manageble chunks: the PACKAGE.  The package is both a naming and a visibility
control mechanism.  In other words, you can use the package mechanism to
define classes inside a package that are not accessible by code outside the
package; and you can define class members that are exposed only to other
members of the same package.

@node Define Packages
@section Defining Packages
@cindex Packages, Defining (section)

To create a package, include the @command{package} command as the first
statement in a Java source file.  Thereafter, any classes declared within
that file will belong to the specified package.  The @command{package}
statement defines a name space in which classes are stored.  Without the
@command{package} statement, classes are put into the default package (which
has no name).

@subheading General Form of @command{package} statement
@cindex package statement, general form

@float GeneralForm,PackageStatement
@display
package @ii{pkg}
@end display
@caption{Package Statement --- General Form}
@end float

@ii{pkg} is the name of the package.  For example:
@cindex package statement, example

@example
package mypackage;
@end example

@subheading File System Directories

Java uses the file system directories to store packages.  Therefore, the
@code{.class} files for any classes you declare to be part of
@code{mypackage} must be stored in a directory called @code{mypackage}.  The
directory name must match the package name exactly.

More than one file can include the same @command{package} statement.  The
@command{package} statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other files
from being part of that same package.  Most real-world packages are spread
across many files.

@subheading Hierarchy of Packages
@cindex packages hierarchy

You can create a hierarch of packages.  To do so, separate each package name
form the one above it by use of a period.  The general form of a multileveled
package statement is:
@cindex package statement, multilevel form

@float GeneralForm,PackageStatementMulti
@display
package @ii{pkg1[.pkg2[.pkg3]]}
@end display
@caption{Package Statement --- Multilevel Form}
@end float

A package hierarchy must be reflected in the file system of your Java
development system.  For example a package declared as:

@example
package a.b.c;
@end example

needs to be stored in directory @code{a/b/c}.

Be sure to choose package names carefully; you cannot rename a package
without renaming the directory in which the classes are stored.

@node Classpath
@section Finding Packages and CLASSPATH
@cindex @env{CLASSPATH} @option{-classpath}
@cindex finding packages
@cindex run-time system
@cindex modules
@cindex module path

Packages are mirrored by directories.  How does the Java run-time system know
where to look for packages?

@table @b
@item @samp{cwd}
By default, the Java run-time system uses the currect working directory as
its starting point.  Thus, if your package is in a subdirectory of the
current directory, it will be found.
@item @env{CLASSPATH}
You can specify a directory path or paths by setting the @env{CLASSPATH}
environment variable.
@item @option{-classpath}
You can use the @option{-classpath} option with @command{java} and
@command{javac} to specify the path to your classes.
@item module path
Beginning with JDK 9, a package can be part of a module, and thus found on
the module path.
@end table

@subheading Example Finding a Package
@cindex finding packages, example

Consider the following package specification:

@example
package mypack;
@end example

In order for programs to find @code{mypack}, the program can be executed from
a directory @strong{immediadely above} @code{mypack}, or the @env{CLASSPATH}
must be set to include the path to @code{mypack} or the @option{-classpath}
option must specify the path to @code{mypack} when the program is run via
@command{java}.

When the second of the above options are used, the class path @strong{must
not include} @code{mypack} itself.  It must simply specify the @ii{path} to
@code{mypack}.  For example, if the path to @code{mypack} is

@example
/MyPrograms/Java/mypack
@end example

then the class path to @code{mypack} is

@example
/MyPrograms/Java
@end example

@node Member Access
@section Packages and Member Access
@cindex access control, packages
@cindex packages, access control
@cindex member access
@cindex access, member

Packages add another dimension to access control.  Classes and packages are
both means of encapsulating and containing the name space and scope of
variables and methods.  @emph{Packages} act as containiners for classes and
other subordinate packages.  @emph{Classes} act as containers for data and
code.  The class is Java's smallest unit of abstraction.  As it relates to
the interplay between classes and packages, Java addresses four categories of
visibility for class members:

@itemize
@item
Subclasses in the same package
@item
Non-subclasses in the same package
@item
Subclasses in different packages
@item
Classes that are neither in the same package nor subclasses
@end itemize

The three access modifiers

@itemize
@item
private
@item
public
@item
protected
@end itemize

provide a variaty of ways to produce many levels of access required by these
categories.
@cindex access control table

@float Table,PackageAccess
@multitable @columnfractions .4 .15 .15 .15 .15
@headitem Category @tab Private @tab None @tab Protected @tab public
@item
Same Class @tab Yes @tab Yes @tab Yes @tab Yes
@item
Same package subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Same package non-subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Different package subclass @tab No @tab No @tab Yes @tab Yes
@item
Different package noni-subclass @tab No @tab No @tab No @tab Yes
@end multitable
@caption {Package Access Table --- Shows all combinations of the access
control modifiers}
@shortcaption{Package Access Table}
@end float

@node Importing
@section Importing Packages
@cindex packages, importing
@cindex importing packages

Java includes the @command{import} statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be referred to
directly, using only its name.  The @command{import} statement is a
convenience to the programmer and is not technically needed to write a
complete Java program.

In a Java source file, @command{import} statements occur immediately
following the @command{package} statement (if one exists) and before any
class definitions.  This is the general form of the @command{import}
statement:
@cindex import statement, general form and example

@float GeneralForm,Import
@display
import @ii{pkg1}[.@ii{pkg2}].(@ii{classname} | *);
@end display
@caption{Import Statement --- General Form}
@end float

Here, @ii{pkg1} is the name of a top-level package, and @ii{pkg2} is the name
of a subordinate package inside the outerpackage separated by a dot
(@t{.}).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit @file{classname} or a star (@t{*}), which
indicates that the Java compile should import the entire package.

@example
import java.util.Date;
imort java.io.*;
@end example

@cindex standard Java classes, imported implicitly
@cindex @file{java.lang}
All of the standard Java SE classes included with Java begin with the name
@file{java}.  The basic language functions are stored in a package called
@file{java.lang}.  Normally, you have to import every package or class that
you want to use, but since Java is useless without much of the functionality
in @file{java.lang}, it is implicitly imported by the compiler for all
programs.  This is equivalent to the following line being at the top of all
your programs:

@example
import java.lang.*;
@end example

@cindex import is optional
@cindex fully qualified name
The @command{import} statement is @emph{optional}.  Any place you use a class
name, you can use its @emph{fully qualified name}, which includes its full
package hierarchy.

@cindex imported packages must be public
When a package is imported, only those items within the package declared as
@command{public} will be available to non-subclasses in the importing code.

@c *****************************************************************************
@node Interfaces
@chapter Interfaces
@cindex Interfaces (chapter)
@cindex interfaces, introduction
@cindex keyword interface
@cindex abstract class
@cindex interface, implement
@cindex polymorphism, one interface multiple methods

Using the keyword @command{interface}, you can fully abstract a class'
interface from its implementation.  That is, using @command{interface}, you
can specify what a class must do, but not how to do it.  Interfaces are
syntactically similar to classes, but they lack instance variables, and, as a
general rule, their methods are declared without any body.  Once it is
defined, any number of classes can implement an @command{interface}.  Also,
one class can implement any number of interfaces.  To implement an interfce,
a class must provide the complete set of methods required by the interface.
Each class is free to determine the details of its own implementation.  By
providing the @command{interface} keyword, Java allws you to fully utilize
the ``one interface, multiple methods'' aspect of polymorphism.

@cindex dynamic method resolution
@cindex run-time
@cindex compile time
@cindex method signatures compatible
@cindex static environment
Interfaces are designed to support @dfn{dynamic method resolution} at run
time.  Normally, in order for a method to be called from one class to
another, both classes need to be present at compile time so the Java compiler
can check to ensure that the method signatures are compatible.  This
requirement by itself makes for a static and nonextensible classing
environment.  Inevitably in a system like this, functionality gets pushed up
higher and higher in the class hierarchy so that the mechanisms will be
available to more and more subclasses.  Interfaces are designed to avoid this
problem.  @emph{They disconnect the definition of a method or set of methods
from the inheritance hierarchy.}  Since interfaces are in a different
hierarchy from classes, it is possible for classes that are unrelated in
terms of class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.

@node Defining Interfaces
@section Defining Interfaces
@cindex interfaces, defining

An interface is defined much like a class.  Here is a simplified general form
of an interface definition:
@cindex interface definition, simplified general form

@float GeneralForm,InterfaceSimple
@display
@ii{access} interface @ii{name} @{
  @ii{return-type method-name1}(@ii{parameter-list});
  @ii{return-type method-name2}(@ii{parameter-list});

  @ii{type final-varname1} = @ii{value}
  @ii{type final-varname2} = @ii{value}
  @dots{}
  @ii{return-type method-nameN}(@ii{parameter-list});
  @ii{type final-varnameN} = @ii{value}
@}
@end display
@caption{Interface Definition --- Simplified General Form}
@end float

@cindex interface default access, no modified
@cindex interface public access
@cindex abstract methods, interface
@cindex interface methods, abstract methods
When no access modifier is included, then default access results, and the
interface is only available to other members of the package in which it is
declared.  When it is declared as @command{public}, the interface can be used
by code outside its package.  In this case, the interface mst be the only
public interface declared in the file, and the file must have the same name
as the interface.  The methods that are declared have no bodies.  They end
with a semicolon after the parameter list.  They are, essentially, abstract
methods.  Each class that includes such an interface must implement all of
the methods.

@subheading Variable Declarations inside Interfaces
@cindex interface variable declarations

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly @command{final} and @command{static},
meaning they cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly @command{public}.

@node Implementing Interfaces
@section Implementing Interfaces
@cindex interfaces, implementing
@cindex @command{implements} clause

Once an interface has been defined, one or more classes can implement that
interface.  To implement an interface, include the @command{implements}
clause in a class definition, and then create the methods required by the
interface.  The general form of a class that includes the
@command{implements} clause looks like this:

@float GeneralForm,ClassImplementsInterface
@display
class @ii{clasname} [extends @ii{superclass}] [implements @ii{interface} [,@ii{interface}@dots{}] @{
  @ii{class-body}
@}
@end display
@caption{Class Implementing Interface --- General Form}
@end float

@cindex interface method defintion, declared @command{public}
The methods that implement an interface must be declared @command{public}.
The type signature of the implementing method must match exactly the type
signature specified in the @command{interface} definition.

It is both permissible and common for classes that implement interfaces to
define additional members of their own.

@node Interface References
@section Accessing Implementations Through Interface References
@cindex interface references, accessing implementations
@cindex object references, interfaces
@cindex interfaces, key feature, reference look-ups
@cindex dynamic dispatch, interface method look-ups
@cindex dispatch through an interface

You can declare variables as object references that use an interface rather
than a class type.  Any instance of any class that implements the declared
interface can be referred to by such a variable.  When you call a method
through one of these references, the correct version will be called based on
the actual instance of the interface being referred to.  This is one of the
key features of interfaces.  The method to be executed is looked up
dynamically at run-time, allowing classes to be created later than the code
which calls methods on them.  The calling code can dispatch through an
interface without having to know anything about the ``callee.''  This process
is similar to using a superclass reference to access a subclass object.

@node Partial Implementations
@section Partial Implementations
@cindex interface, partial implementation

If a class includes an interface but does not implement the methds required
by that interface, then that class must be declared as @command{abstract}.
Any class that inherits the abstract class must implement the interface or be
declared @command{abstract} itself.

@node Nested Interfaces
@section Nested Interfaces
@cindex interfaces, nested
@cindex nested interfaces
@cindex member interfaces

An interface can be declared a member of a class or another interface.  Such
an interface is called a @dfn{member interface} or a @dfn{nested interface}.
A nested interface can be declared as @command{public}, @command{private}, or
@command{protected}.  This differs from a top-level interface, which must
either be declared as @command{public} or use the default access level.  When
a nexted interface is used outside of its enclosing scope, it must be
qualified by the name of the class or interface of which it is a member.
Thus, outside of the class or interface in which a nested interface is
declared, its name must be fully qualified.

@node Applying Interfaces
@section Applying Interfaces
@cindex intefaces, applying

See detailed example @dots{}

@node Variables in Interfaces
@section Variables in Interfaces
@cindex interfaces, final variables in
@cindex interfaces, shared constants

You can use interfaces to import shared constants into multiple classes by
simply declaring an interface that contains variables that are initialized to
the desired values.  When you include that interface in a class (when you
``implement'' the interface), all of those variable names will be in scope as
constants.  If an interface contains no methods, then any class that includes
such an interface doesn't actually implement anything.  It is as if that
class were importing this constant fields into the class name space as
@command{final} variables.

@node Extending Interfaces
@section Interfaces Can Be Extended
@cindex interfaces, extending
@cindex interfaces, inheriting
@cindex @command{extents}, with interfaces
@cindex extending interfaces
@cindex inheriting interfaces

One interface can inherit another by use of the keyword @command{extends}.
The syntax is the same as for inheriting classes.  When a class implements an
interface that inherits another interface, it must provide implementations
for all methods required by the interface inheritance chain.

@node Default Interface Methods
@section Default Interface Methods
@cindex index interface, default methods
@cindex default methods, interface
@cindex abstract methods, interface
@cindex interface, traditional form
@cindex JDK 8, default method in interface

Prior to JDK 8, an interface could not define any implementation whatsoever.
This meant that for all previous versions of Java, the methods specified by
an interface were abstract, constaining no body.  This is the traditional
form of an interface.  The release of JDK 8 changed this by adding a new
capability to @command{interface} called the @dfn{default method}.  A default
method lets you define a default implementation for an interface method.  It
is possible for an interface method to provide a body, rather than being
abstract.

@cindex default method, interface, motivation
@cindex preexisting code, default method, interface
A primary motivation for the default method was to provide a means by which
interfaces could be expanded without breaking existing code.  There must be
implementations for all methods defined by an interface.  If a new method
were added to a popular, widely used interface, then the addition of that
method would break existing code because no implementation would be found for
that new method.  The default method solves this problem by supplying an
implementation that willbe used if no other implementation is explicitly
provided.  Thus, the addition of a default method will not cause preexisting
code to break.

Another motivation for the default method was the desire to specify methods
in an interface that are, essentially, optional, depending on how the
interface is used.

@subheading Interfaces Do No Maintain State and Cannot Be Created
@cindex interfaces, key aspect, no state
@cindex difference between class and interface

It is important to point out that the addition of default methods does not
change a key aspect of @command{interface}: its inability to maintain state
information.  An interface still cannot have instance variables, for example.
Thus, @strong{the defining difference between an interface and a class is
that a class can maintain state information, but an interface cannot.}
Furthermore, it is still not possible to create an instance of an interface
by itself.  It must be implemented by a class.

@node Interface Static Methods
@section Use Static Methods in an Interface
@cindex interface, static method
@cindex static method, interface
@cindex method, static, interface
@cindex JDK 8, static interface method

Another capability added to interface by JDK 8 is the ability to define one
or more @command{static} methods.  Like @command{static} methods in a class,
a @command{static} method defined by an interface can be called independently
of any object.  Thus, no implementation of the interface is necessary, and no
instance of the interface is required, in order to call a @command{static}
method.  Instead, a @command{static} method is called by specifying the
interface name, followed by a period, followed by the method name.  Here is
the general form:

@float GeneralForm,InterfaceStaticMethod
@display
@ii{InterfaceName.staticMethodName}
@end display
@caption{Interface Static Method, Calling}
@end float

Notice that this is similar to the way that a @command{static} method in a
class is called.  However, @command{static} interface methods are not
inherited by either an implementing class or a subinterface.

@node Private Interface Methods
@section Private Interface Methods
@cindex interface methods, private
@cindex JDK 9, private interface method

Beginning with JDK 9, an interface can include a private method.  A private
interface method can be called only by a default method or another private
method defined by the same interface.  Because a private interface method is
specified @command{private}, it cannot be used by code outside the interface
in which it is defined.  This restriction includes subinterfaces because a
private inteface method is not inherited by a subinterface.

The key benefit of a private interface method is that it lets two or more
default methods use a common piece of code, thus avoiding code duplication.


@c ****************************************************************************
@node Generics
@chapter Generics
@cindex Generics (chapter)
@cindex generics, introduction

Through the use of generics, it is possible to create classes, interfaces,
and methods that will work in a type-safe manner with various kinds of data.
Many algorithms are logically the same no matter what type of data they are
being applied to.  For example, the mechanism that supports a stack is the
same whether that stack is storing items of type @command{Integer},
@command{String}, @command{Object}, or @command{Thread}.  With generics, you
can define an algorithm once, independently of any specific type of data, and
then apply that algorithm to a wide variety of data types without any
additional effort.

Perhaps the one feature of Java that has been most significantly affected by
generics is the @cite{Collections Framework}.  A @dfn{collection} is a group
of objects.  The Collections Framework defines several classes, such as lists
and maps, that manage collections.  The collection classes have always been
able to work with any type of object.  The benefit that generics addes is
that the collection classes can now be used with complete type safety.

This chapter describes the syntax, theory, and use of generics.  It also
shows how generics provide type safety for some previously difficult cases.

@node What are Generics
@section What Are Generics
@cindex generics, what they are
@cindex parameterized types
@cindex generic class, method
@cindex @command{Object} type
@cindex type safety, generics
@cindex casts, generics, automatic, implicit
@cindex generics, casts

The term @dfn{generics} means @i{parameterized types}.  Parameterized types
are important because they enable you to create classes, interfaces, and
methods in whicht the type of data upon which they operate is specified as a
parameter.  Using generics, it is possible to create a single class, for
example, that automatically words with different types of data.  A class,
interface, or method that operates on a parameterized type is called
@dfn{generic}, as in @i{generic class} or @i{generic method}.

Java has always given the ability to create generalized classes, interfaces,
and methods by operating through references of type @command{Object}.
Generics added the type safety that was lacking.  They also streamlined the
process, because it is no longer necessary to explicitly employ casts to
translate between @command{Object} and the type of data that is being operate
upon.  Wtih generics, all casts are automatic and implicit.

@node Simple Generics Example
@section A Simple Generics Example
@cindex generics example
@cindex example, generics
@cindex generic class

The following program defines two classes.  The first is the generic class
@command{Gen}, and the second is @command{GenDemo}, which uses @command{Gen}.

@(SimpleGenerics.java@)=
@<Class Gen@>
@<Class GenDemo@>
@

@node Class Gen<T>
@subsection Class Gen<T>
@cindex generic class
@cindex parameter, generic class
@cindex type parameter, generic class
@cindex parameterized type

This is a simple generic class.  The class @code{Gen} is declared with a
parameter of @samp{<T>}:

@example
class Gen<T> @{
@end example

@samp{T} is the name of a @dfn{type parameter}.  This name is used as a
placeholder for the actual type that will be passed to @code{Gen} when an
object is created.  Thus, @samp{T} is used within @code{Gen} whenever the
type parameter is needed.

Notice that @samp{T} is contained within @samp{< >}.  This syntax can be
generalized.  Whenever a type parameter is being declared, it is specified
within angle brackets.

Because @code{Gen} uses a type parameter, @code{Gen} is a @emph{generic
class}, which is also called a @emph{parameterized type}.

@subsubheading Outline of Class Gen<T>

Class @code{Gen} contains four parts:

@itemize
@item
an instance variable declaration
@item
a constructor
@item
a method returning the instance variable
@item
a method describing the type of the instance variable
@end itemize

@<Class Gen@>=
class Gen<T> {
  @<Instance Variable ob of Type T@>
  @<Constructor taking parameter of Type T@>
  @<Method returning object of type T@>
  @<Method showing type of T@>
}
@

@subsubheading Implementation of Class Gen<T>

@samp{T} is used to declare an object called @code{ob}.  @samp{T} is a
placeholder for the actual type that will be specified when a @code{Gen}
object is created.  Thus, @code{ob} will be an object of the type passed to
@samp{T}.  

@<Instance Variable ob of Type T@>=
T ob;	// declare an object of type T

@

@subsubheading The Constructor

Here is the constructor for @code{Gen}.  Notice that its parameter, @code{o},
is of type @samp{T}.  This means that the actual type of @code{o} is
determined by the type passed to @samp{T} when a @code{Gen} object is
created.  Because both the parameter @code{o} and the member variable
@code{ob} are of type @samp{T}, they will both be the same actual type when
a @code{Gen} object is created.

@<Constructor taking parameter of Type T@>=
// Pass the constructor a reference to
// an object of type T
Gen (T o) {
  ob = o;
}

@

@subsubheading Instance Methods @code{getob()} and @code{showType()}

The type parameter @samp{T} can also be used to specify the return type of a
method, as here in @code{getob()}.  Because @code{ob} is also of type
@samp{T}, its type is compatible wih the return type specified by
@code{getob()}.  

@<Method returning object of type T@>=
// Return ob
T getob() {
  return ob;
}

@

@cindex @command{Class}
@cindex @command{Object}
@cindex @code{getClass()}, defined in @command{Object}
@cindex @command{Class} object, from @code{getClass()}
@cindex @code{getName()}, defined in @command{Class}
@cindex class name, from @code{getName()}

The method @code{showType()} displays the type of @samp{T} by calling
@code{getName()} on the @command{Class} object return by the call to
@code{getClass()} on @code{ob}.   The @code{getClass()} method is defined
by @code{Object} and is thus a member of @emph{all} class types.  It returns
a @command{Class} object that corresponds to the type of the class of the
object on which it is called.  @command{Class} defines the @code{getName()}
method, which returns a string representation of the class name.

@<Method showing type of T@>=
// Show type of T
void showType() {
  System.out.println("Type of T is " + ob.getClass().getName();
}

@

@node Class GenDemo
@subsection Class GenDemo
@cindex generic code, demonstrating an implementation
@cindex erasure
@cindex type erasure

The @code{GenDemo} class demonstrates the generic @code{Gen} class.

But first, take note: The Java compiler does not actually create different
versions of @code{Gen}, or of any other generic class.  The compiler removes
all generic type information, substituting the necessary casts, to make your
code @strong{behave as if} a specific version of @code{Gen} were created.
There is really only one version of @code{Gen} that actually exists.

The process of removing generic type information is called @dfn{type
erasure}.  

@code{GenDemo} first creates a version of @code{Gen} for integers and calls
the methods defined in @code{Gen} on it.  It then does the same for a String
object.

@<Class GenDemo@>=
// Demonstrate the generic class
class GenDemo {
  public static void main(String args[]) {
    @<Create a Gen object for Integers@>
    @<Create a Gen object for Strings@>
  }
}

@

@node GenDemo as Integer
@subsubsection Implementation of Class GenDemo with Type Integer
@cindex generic reference, creating
@cindex type argument, passed to type parameter

@<Create a Gen object for Integers@>=
@<Integer Type Parameter@>
@<Reference to Integer Instance@>
@<Show Type@>
@<Get Value@>
@

@subsubheading Integer Type Declaration
@cindex generic reference to Integer

A reference to an Integer is declared in @code{iOb}.  Here, the type
@samp{Integer} is specified within the angle brackets after @code{Gen}.
@samp{Integer} is a @dfn{type argument} that is passed to @code{Gen}'s type
parameter, @samp{T}.  This effectively creates a version of @code{Gen} in
which all references to @samp{T} are translated into references to
@samp{Integer}.  Thus, @code{ob} is of type @samp{Integer}, and the return
type of @code{getob()} is of type @samp{Integer}.

@<Integer Type Parameter@>=
Gen<Integer> iOb;

@

@subsubheading Reference Assignment
@cindex generic reference assignment to Integer
@cindex generic type checking
@cindex generics, compile-time error, mismatched types
@cindex generics, type safety benefit
@cindex autoboxing in generic reference

The next line assigns to @code{iOb} a reference to an instance of an
@samp{Integer} version of the @code{Gen} class.  When the @code{Gen}
constructor is called, the type argument @samp{Integer} is also specified.
This is because the type of the object (in this case @code{iOb} to which the
reference is being assigned is of type @code{Gen<Integer>}.  Thus, the
reference returned by @command{new} must also be of type
@code{Gen<Integer>}.  If it isn't, a compile-time error will result.  This
type checking is one of the main benefits of generics because it ensures type
safety.  

Notice the use of autoboxing to encapsulate the value 88 within an Integer
object.

@<Reference to Integer Instance@>=
iOb = new Gen<Integer>(88);

@

The automatic autoboxing could have been written explicitly, like so:
@example
iOb = new Gen<Integer>(Integer.valueOf(88));
@end example
@noindent but there would be no value to doing it that way.

@subsubheading Showing the Reference's Type

The program then uses @code{Gen}'s instance method to show the type of
@code{ob}, which is an @samp{Integer} in this case.

@<Show Type@>=
iOb.showType();

@

@subsubheading Showing the Reference's Value

The program now obtains the value of @code{ob} by assiging @code{ob} to an
@samp{int} variable.  The return type of @code{getob()} is @samp{Integer},
which unboxes into @samp{int} when assigned to an @samp{int} variable
(@code{v}).  There is no need to cast the return type of @code{getob()} to
@samp{Integer}.  

@<Get Value@>=
int v = iOb.getob();
System.out.println("value: " + v);
System.out.println();

@

@node GenDemo as String
@subsubsection Implementation of Class GenDemo with Type String

@<Create a Gen object for Strings@>=
// Create a Gen object for Strings.
Gen<String> strOb = new Gen<String>("Generics Test");

// Show the type of data used by strOb
strOb.showType();

// Get the value of strOb.  Again, notice
// that no cast is needed.
String str = strOb.getob();
System.out.println("value: " + str);

@

@node Notes about Generics
@section Notes About Generics

@node Reference Types
@subsection Generics Work Only with Reference Types
@cindex generics, only reference types
@cindex generic type argument, reference type
@cindex type wrappers, generics
@cindex auto-boxing, generics
@cindex auto-unboxing, generics

When declaring an instance of a generic type, the type argument passed to the
type parameter must be a reference type.  It cannot be a primitive type, such
as @samp{int} or @samp{char}.

You can use the type wrappers to encapsulate a primitive type.  Java's
autoboxing and auto-unboxing mechanism makes the use of the type wrapper
transparent.  

@node Type Arguments
@subsection Generic Types Differ Based on their Type Arguments
@cindex generic types differ, type arguments

A reference of one specific version of a generic type is not type-compatible
with another version of the same generic type.  In other words, the following
line of code is an error and will not compile:

@example
iOb = strOb; // Gen<Integer> != Gen<String>
@end example

These are references to different types because their type arguments differ.

@node Type Safety
@subsection How Generics Improve Type Safety
@cindex generics improve type safety
@cindex generics ensure type safety
@cindex generics eliminate casts
@cindex casts, eliminated in generics

Generics automatically ensure the type safety of all operations involving a
generic class, such as @code{Gen}.  They eliminate the need for the coder to
enter cases and to type-check code by hand.

@node Two Type Parameters
@section A Generic Class with Two Type Parameters
@cindex generic class, two type parameters

You can declare more than one type parameter in a generic type.  To specify
two or more type parameters, use a comma-separated list.  When an object is
created, the same number of type arguments must be passed as there are type
parameters.  The type arguments can be the same or different.

@node Two Types Example Code
@subsection Example of Code with Two Type Parameters

@(TwoTypeParameters.java@)=
@<Class TwoGen@>
@<Class SimpGen@>
@

@node Class TwoGen
@subsubsection Class TwoGen

@<Class TwoGen@>=
@<Class Declaration@>
  @<Two Instance Variables Declarations@>
  @<Constructor of Two Parameters@>
  @<Instance Methods Show and Get@>
@

@subsubheading Class Declaration
@cindex generics, two type parameters, declaration
@cindex generics, two type arguments

Notice how @code{TwoGen} is declared.  It specifies two type parameters:
@samp{T} and @samp{V}, separated by a comma.  Because it has two type
parameters, two type arguments must be passed to @code{TwoGen} when an object
is created.

@<Class Declaration@>=
class TwoGen<T, V> {
@

@subsubheading Instance Variables Declarations

@<Two Instance Variables Declarations@>=
T ob1;
V ob2;

@

@subsubheading Constructor
@<Constructor of Two Parameters@>=
TwoGen(T o1, V 02) {
  ob1 = o1;
  ob2 = o2;
}

@

@subsubheading Instance Methods Show and Get
@<Instance Methods Show and Get@>=
void showTypes() {
  System.out.println("Type of T is " + ob1.getClass().getName());
  System.out.println("Type of V is " + ob2.getClass().getName());
}

T getob1() {
  return ob1;
}

V getob2() {
  return ob2;
}

@

@node Class SimpGen
@subsubsection Class SimpGen

Two type arguments must be supplied to the constructor.  In this case, the
two type parameters are @samp{Integer} and @samp{String}.

@<Class SimpGen@>=
class SimpGen {
  public static void main(String args[]) {
    TwoGen<Integer, String> tgObj = new TwoGen<Integer, String>(88, "Generics");

    // Show the types
    tgObj.showTypes();

    // Obtain and show values
    int v = tgObj.getob1();
    System.out.println("value: " + v);

    String str = thObj.getob2();
    System.out.println("value: " + str);
  }
}
@

@node Generic Class General Form
@section The General Form of a Generic Class
@cindex generic class, general form

The generics syntax shown above can be generalized.  Here is the syntax for
declaring a generic class:

@float GeneralForm,GenericClass
@display
class @ii{class-name}<@ii{type-param-list}> @{ @dots{}
@end display

Here is the full syntax for declaring a reference to a generic class and
instance creation:

@display
@ii{class-name}<@ii{type-arg-list}> @ii{var-name} =
  new @ii{class-name}<@ii{type-arg-list}>(@ii{cons-arg-list});
@end display
@caption{General Form for Declaring and Creating a Reference to a Generic
Class}
@shortcaption{General Form Generic Class}
@end float


@c ****************************************************************************
@node The Makefile
@appendix The Makefile
@cindex Makefile, The (appendix)

@(Makefile@)=
@<Makefile CONSTANTS@>
@<Makefile DEFAULTS@>
@<Makefile TANGLE WEAVE@>
@<Makefile CLEAN@>
@

@node Makefile Constants
@appendixsec Makefile Constants
@cindex Constants

@<Makefile CONSTANTS@>=
FILENAME := JavaSE9

@

@node Makefile Defaults
@appendixsec Makefile Default Targets
@cindex Makefile defaults

@<Makefile DEFAULTS@>=
.PHONY: all
all: tangle weave

@

@node Makefile Tangle Weave
@appendixsec Makefile Tangle Weave Targets
@cindex Makefile Tangle
@cindex Makefiel Weave

@<Makefile TANGLE WEAVE@>=
.PHONY: tangle weave jrtangle jrweave
tangle: jrtangle
weave: jrweave

jrtangle: $(FILENAME).twjr
	jrtangle $(FILENAME).twjr

jrweave: $(FILENAME).texi

$(FILENAME).texi: $(FILENAME).twjr
	jrweave $(FILENAME).twjr > $(FILENAME).texi
@

@node Makefile Clean
@appendixsec Makefile Clean Targets
@cindex Makefile Clean targets

@<Makefile CLEAN@>=
.PHONY: clean
clean:
	rm -f *~
	rm -f $(FILENAME).???

@

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs


@node List of Tables
@unnumbered List of Tables
@listoffloats Table

@node List of General Forms
@unnumbered List of General Forms
@listoffloats GeneralForm

@node Bibliography
@unnumbered Bibliography

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
