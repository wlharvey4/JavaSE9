\input texinfo   @c -*-texinfo-*-

@c %**start of header (This is for running Texinfo on a region.)
@setfilename JavaSE9.info
@settitle About Java SE 9
@deftypefnnewline on
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH SEPTEMBER, 2018
@set TITLE Outline Covering Java SE 9
@set SHORTTITLE Java SE 9 Outline
@set EDITION 0.1
@set VERSION 0.2.1

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@c @synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@ignore
@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} YYYY, YYYY @*
Full name here @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The FOO program is copyright
@copyright{} YYYY, YYYY by Full name here. It is published under
the conditions of the GNU General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying
@end ignore

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author LOLH

@ignore COPYRIGHT PAGES
@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Full name here @*
Address Line 1 @*
Address Line 2 @*
etc. @*
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@end ignore
@end titlepage

@set DRAFT @i{DRAFT}

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| Version @value{VERSION} @| @thispage
@end iftex




@c *****************************************************************************

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @value{TITLE}.

@c @insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@ignore
PREFATORY MATTER THRU ACKNOWLEDGEMENTS

@node Preface
@c @unnumbered Preface

Text here.

@node Audience
@c @unnumberedsec Intended Audience

Text here.

@node Overview
@c @unnumberedsec What Is Covered

Text and chapter by chapter description here.

@node Conventions
@c @unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@c @unnumberedsec Acknowledgements

@end ignore




@c *****************************************************************************

@part The Java Language

@node Java SE 9 Introduction
@chapter Java SE 9 Introduction
@cindex Java SE 9 introduction
@cindex introduction to Java SE 9




@c *****************************************************************************

@node Classes
@chapter Classes
@cindex Classes

The class is the logical construct upon which the Java language is built
because it defines the shape and nature of an object, and therefore forms
the basis for object-oriented programming in Java.

@c -----------------------------------------------------------------------------

@node Class Fundamentals
@section Class Fundamentals
@cindex Class fundamentals
@cindex class, new data type
@cindex template, class
@cindex object, class
@cindex instance, class

A @dfn{class} defines a new data type.  Once defined, this new type can be
used to create objects of that type.  A class is therefore a @i{template}
for an object, and an @dfn{object} is an @i{instance} of a class.
@i{Object} and @i{instance} are often used interchangeably.

@node General Form
@subsection General Form of a Class
@cindex class, general form

When you define a class, you declare its exact form and nature.  You do this
by specifying the data that it contains and the code that operates on that
data.  A class is declared by use of the @code{class} keyword.

@float GeneralForm,ClassDeclaration
@display
class @ii{classname} @{
  @ii{type instance-variable1};
  @ii{type instance-variable2};
  @dots{}
  @ii{type instance-variableN};

  @ii{type method-name1} (@ii{parameter-list} @{
    @ii{body of method}
  @}

  @ii{type method-name2} (@ii{parameter-list} @{
    @ii{body of method}
  @}
  @dots{}
  @ii{type method-nameN} (@ii{parameter-list} @{
    @ii{body of method}
  @}
@}
@end display
@caption{Class Declaration --- General Form}
@end float

@cindex instance variables
@cindex methods
@cindex members
The data, or variables, defined within a class are called @dfn{instance variables}.
The code is contained within @dfn{methods}.  Collectively, the methods and
variables defined within a class are called @dfn{members} of the class.
In most cases, the instance variables are acted upon and accessed by the
methods defined for that class.  As a general rule, it is the methods that
determine how a class' data can be used.

Each instance of the class (that is, each object of the class) contains its
own copy of the instance variables.  The data for one object is separate and
unique from the data for another.  Changes to the instance variables of one
object have no effect on the instance variables of another.

@cindex @samp{main()} method, class
Java classes do not need to have a @samp{main()} method; you only need to
specify one if that class is the starting point for the program.

@cindex dot operator
In general, you use the @dfn{dot operator} to access both the instance
variables and the methods within an object.  Although commonly referred to
as the dot @emph{operator}, the formal specification for Java categorizes
the @t{.} as a @emph{separator}.

@c -----------------------------------------------------------------------------

@node Declaring Objects
@section Declaring Objects
@cindex objects, declaring
@cindex @command{new} operator
@cindex run time, dynamic allocation
@cindex dynamic allocation, run time
@cindex constructor

Because a class creates a new data type, you can use this type to declare
objects of that type.  Obtaining objects of a class is a two-step process.

@enumerate
@item
Declare a variable of the class type; this variable does not define an
object.  Instead, it is simply a variable that can @emph{refer} to an object.
@item
Acquire an actual, physical copy of the object and assign it to the
variable; you can do this using the @command{new} operator.  The
@command{new} operator dynamically allocates (at run time) memory for an
object, and returns a reference to to.  This reference is (essentially) the
address in memory of the object allocated by @command{new}.  This reference
is then stored in the variable.  In Java, all class objects must be
dynamically allocated.
@end enumerate

@heading Example Declaration, Allocation, and Assignment

@example
Box mybox; // 1. declare a variable
mybox = new Box(); // 2. allocate a Box object
@end example

These two declarations can be combined into a single declaration, and
usually are:

@example
Box mybox = new Box();
@end example

The @code{mybox} variable simply holds the memory address of the actual
@code{Box} object.  The class name followed by parenthese specifies the
@dfn{constructor} for the class.

@c -----------------------------------------------------------------------------

@node Methods
@section Methods
@cindex Methods

@heading General Form of a Method Declaration

@float GeneralForm,MethodDeclaration
@display
@ii{type name} (@ii{parameter-list}) @{
  @ii{body of method}
@}
@end display
@caption{Method Declaration --- General Form}
@end float

@cindex type, method
@cindex name, method
@cindex parameter list, method

@ii{type} specifies the type of data returned by the method.  This can be
any valid type, including class types that you create.  If the method does
not return a value, its return type must be @code{void}.

@dfn{name} is the name of the method.  This can be any legal identifier.

@dfn{parameter-list} is a sequence of type and identifier pairs separated by
commas.  @dfn{Parameters} are essentially variables that receive the value
of the arguments passed to the method when it is called.  If the method has
no parameters, then the parameter list will be empty.

Methods that have a return type other than @code{void} return a value to the
calling routine using a @dfn{return statement}:

@display
return @ii{value}
@end display

where @ii{value} is the value returned.

@c -----------------------------------------------------------------------------

@node Constructors
@section Constructors
@cindex Constructors

Java allows objects to initialize themselves when they are created.  This
automatic initialization is performed through the use of a constructor.

A @dfn{constructor} initializes an object immediately upon creation.  It has
the same name as the class in which it resides and is syntactically similar
to a method.  Once defined, the constructor is automatically called when the
object is created, before the @command{new} operator completes.
Constructors have no return type.  It is the constructor's job to initialize
the internal state of an object so that the code creating an instance will
have fully initialized, usable object immediately.

@node this Keyword
@section The @code{this} Keyword
@cindex @code{this} Keyword

Sometimes a method will need to refer to the object that invoked it.  To
allow this, Java defines the @code{this} keyword.  @code{this} can be used
inside any method to refer to the @emph{current} object.  That is,
@code{this} is always a refernce to the object on which the method was
invoked.  You can use @code{this} anywhere a reference to an object of the
current class' type is permitted.

@node Instance Variable Hiding
@subsection Instance Variable Hiding
@cindex hiding, instance variables

It is illegal to declare two local variables with the same name inside the
same or enclosing scope.  However, you can have local variables, including
formal parameters to methods, which overlap with the names of the class'
instance variables.  For these cases, the local variables @emph{hide} the
instance variables of the same name.

Because @code{this} lets you refer directly to the object, you can use it to
resolve any namespace collisions that might occur between instance variables
and local variables.  So, @kbd{this.width = width} is an example of a local
variable (@kbd{width}) hiding an instance variable (also @kbd{width}), with
@code{this} allowing an assignment between them.

@c -----------------------------------------------------------------------------

@node Stack Class
@section A Stack Class
@cindex Stack Class

To see a practical application of object-oriented programming, here is one
of the archetypal examples of encapsulation: the stack.  A @dfn{stack}
stores data using @emph{first-in, last-out} ordering.  That is, a stack is
like a stack of plates on a table --- the first plate put down on the table
is the last plate to be used.  Stacks are controlled through two operations
traditionally called @dfn{push} and @dfn{pop}.  To put an item on top of the
stack, you will use @command{push}.  To take an item off the stack, you will
use @command{pop}.  It is easy to encapsulate the entire stack mechanism.

Here is a class called @code{Stack} that implements a stack for up to ten
integers, plus test class called @code{TestStack}:

@heading Stack.java

@(Stack.java@)=
class Stack {
  @<Stack Instance Variables@>
  @<Stack Constructor@>
  @<Stack Instance Methods@>
}

@

@heading TestStack.java

@(TestStack.java@)=
class TestStack {
  @<TestStack Main Method@>
}

@

@node Stack Instance Variables
@subsection Stack Instance Variables

@<Stack Instance Variables@>=
int[] stck = new int[10];
int tos;

@

@node Stack Constructor Node
@subsection Stack Constructor Subsection

@<Stack Constructor@>=
// initialize top-of-stack tos
Stack() {
  tos = -1;
}

@

@node Stack Instance Methods Node
@subsection Stack Instance Methods Subsection

@<Stack Instance Methods@>=
@<Stack Push@>
@<Stack Pop@>
@

@node Stack Push and Pop Node
@subsubsection Stack Push and Pop Subsubsection

@<Stack Push@>=
// Push an item onto the stack
void push(int item) {
  if (tos == 9)
    System.out.println("Stack is full.");
  else
    stck[++tos] = item;
}

@

@<Stack Pop@>=
// Pop an item from the stack
int pop() {
  if (tos < 0) {
    System.out.println("Stack underflow.");
    return 0;
  } else
    return stck[tos--];
  }
}

@

@node Stack TestStack Node
@subsection Stack TestStack Subsection

@<TestStack Main Method@>=
public static void main(String[] args) {
  Stack mystack1 = new Stack();
  Stack mystack2 = new Stack();

  // push some numbers onto the stack
  for (int i = 0; i < 10; i++)
    mystack1.push(i);
  for (int i = 10; i < 20; i++)
    mystack2.push(i);

  // pop those numbers off the stack
  System.out.println("Stack in mystack1:");
  for (int i = 0; i < 10; i++)
    System.out.println(mystack1.pop());

  System.out.println("Stack in mystack2:");
  for (int i + 0; i < 10; i++)
    System.out.println(mystack2.pop());
}

@





@c *****************************************************************************

@node Methods and Classes
@chapter Methods and Classes
@cindex Methods and Classes

This chapter examines several topics relating to methods and classes,
including

@itemize
@item
overloading
@item
parameter passing
@item
recursion
@item
access control
@item
keywords @code{static} and @code{final}
@item
@code{String} class
@item
Arrays
@item
nested and inner classes
@item
command-line arguments and varargs
@end itemize

@c -----------------------------------------------------------------------------


@node Overloading Methods
@section Overloading Methods
@cindex overloading methods
@cindex methods, overloading
@cindex overload, overloaded
@cindex polymorphism, overloading of methods
@cindex overloading, automatic type conversion
@cindex @emph{one interface, multiple methods}

It is possible to define two or more methods within the same class that share
the same name as long as their parameter declarations are different.  When
this is the case, the methods are said to be @dfn{overloaded}, and the
process is referred to as @dfn{method overloading}.  Method overloading is
one of the ways that Java supports polymorphism.

When an overloaded method is invoked, Java uses the type and number of
arguments as its guid to determine which version of the overloaded method to
actually call.  Thus, overloaded methods must differ in the type or number of
their parameters.  While overloaded methods may have different return types,
thei return type alone is inusfficient to distinguish two versions of a
method.  When Java encounters a call to an overloaded method, it simply
executes the version of the method whose parameters match the arguments used
in the call.

The match between arguments and parameters need not always be exact.  In some
cases,Java's automatic type conversions can play a role in overload
resolution.  For example, if there is a method with one @code{double}
parameter, and that method is invoked with a single @code{int} argument,
then, when no exact match is found, Java will automatically convert the
integer into a @code{double}, and this conversion will be used to resolve the
call.  Java will employ automatic type conversion only if no exact match is
found.

Method overloading supports polymorphism because it is one way that Java
implements the @emph{one interface, multiple methods} paradigm.  That is,
Java does not need to rename each similar method just because it has a
slightly different parameter requirements.  The value of overloading is that
it allows related methods to be accessed by use of a common name,
representing the @emph{general action} that is being performed, and leaves to
the compiler the choice of the right @emph{specific} version for a particular
circumstance.  The programmer need only remember the general operation being
performed.  Through the application of polymorphism, several names have been
reduced to one.  Overloading can help manage greater complexity.


@c .....................................

@node Overloading Constructors
@subsection Overloading Constructors
@cindex overloading constructors
@cindex constructors, overloading

You can also overload constructor methods.  


@c -----------------------------------------------------------------------------

@node Objects as Parameters
@section Objects as Parameters
@cindex objects as parameters
@cindex parameters, as objects

It is both correct and common to pass objects to methods as well as primitive
types.  One of the most common uses of object parameters involves
constructors.  Frequently you will want to construct a new object so that it
is initially the same as some existing object.  To do this, you must define a
constructor that takes an object of its class as a parameter.  Providng many
forms of constructors is usually required to allow objects to be constructed
in a convenient and efficient manner.


@c -----------------------------------------------------------------------------

@node Argument Passing
@section Argument Passing
@cindex argument passing

In general, there are two ways that a computer language can pass an argument
to a subroutine:

@enumerate
@item
call-by-value
@item
call-by-reference
@end enumerate

Java uses call-by-value to pass all arguments, although the precise effect
differs between whether a primitive type or a reference type is passed.

When you pass a primitive type to a method, it is passed by value.  Thus, a
copy of the argument is made, and what occurs to the parameter that receives
the argument has no effect outside the method.

When you pass an object to a method, the situation changes; objects are
passed by what is effectively call-by-reference.  When you pass a variable of
a class type, you pass a reference to the method and the parameter receiving
it will refer to the same object.  This effectively means that objects act as
if they are passed to methods by use of call-by-reference.  Changes to the
object inside the method @emph{do} affect the object used as an argument.
However, when an object reference is passed to a method, the reference itself
is passed by use of call-by-value; therefore, that reference will continue to
refer to the object, even though the object itself may be modified.


@c -----------------------------------------------------------------------------

@node Returning Objects
@section Returning Objects
@cindex objects, returning from methods
@cindex objects, dynamical allocation
@cindex objects, references to

A method can return any type of data, including class types that you create.

Since all objects are dynamically allocated using @command{new}, you don't
need to worry about an object going out-of-scope because the method in which
it was created terminates.  The object will continue to exist as long as
there is a reference to it somewhere in your program.  When there are no
references to it, the object will be reclaimed the next time garbage
collection takes place.


@c -----------------------------------------------------------------------------

@node Recursion
@section Recursion
@cindex recursion, recursive
@cindex iteration, iterative
@cindex stack overun, recursion
@cindex stack exhaustion, recursion

@dfn{Recursion} is the process of defining something in terms of itself.  In
programming, it is also what allows a method to call itself.  A method that
calls itself is said to be @dfn{recursive}.

When a method calls itself, new local variables and parameters are allocated
storage on the stack, and the method code is executed with these new
variables from the start.  As each recursive call returns, the old local
variables and parameters are removed from the stack, and execution resumes at
the point of the call inside the method.

Recursive versions of many routines may execute a bit slower than the
iterative equivalent because of the added overhead of the additional method
calls.  A large number of recursive calls to a method could cause a stack
overrun.  Because storage for parameters and local varibles is on the stack
and each new call creates a new copy of these variables, it is possible that
the stack could be exhausted.  If this occurs, the Java run-time system will
cause an exception.

The main advantage to recursive methods is that they can be used to create
clearer and simpler versions of several algorithms than can their iterative
relatives.  For example, the QuickSort sorting algorithm is quite difficult
to implement in an iterative way.  Also, some types of AI-related algorithms
are most easily implemented using recursive solutions.


@c -----------------------------------------------------------------------------

@node Access Control
@section Access Control
@cindex access control, single class
@cindex encapsulation, access control
@cindex access modifiers

Encapsulation provides another important attribute besides linking data with
code: @dfn{access control}.  Through encapsulation, you can control what
parts of a program can access the members of a class.  By controlling access,
you can prevent misuse.  Thus, when correctly implemented, a class creates a
@emph{black box} which may be used, but the inner workings of which are not
open to tampering.  The classes introduced earlier do not completely meet
this goal.  For example, the @code{Stack} class provides the methods
@code{push()} and @code{pop()} as a controlled interface to the stack, this
interface is not enforced --- it is possible for another part of the program
to bypass these methods and access the stack directly.  This could lead to
trouble.

How a member can be accessed is determined by the @dfn{access modifier}
attached to its declaration.  Java supplies a rich set of access modifiers.
Some aspects of access control are related mostly to inheritance or packages
(and now modules).  Those ideas will be discussed later.  Here, let's examine
access control as it relates to a single class.

@subheading Access Modifiers
@cindex public access modifier
@cindex private access modifier
@cindex protected access modifier
@cindex default access level

Java's access modifiers are:

@itemize
@item
public
@item
private
@item
protected (applies only to inheritance)
@item
default access level
@end itemize

@subsubheading @code{public} vs @code{private} Access

When a member of a class is modified by @code{public}, then that member can
be accessed by any other code.  When a member of a class is specified as
@code{private}, then that member can only be accessed by other members of its
class.  Thus, the method @code{main()} is always preceded by the
@code{public} modifier.  It must be called by code that is outside the
program --- the Java run-time system.

@subheading Default Access --- No Access Modifier

When no access modifier is used, then by default the member of a class is
public within its own package, but cannot be accessed outside of its
package.  In the classes developed so far, all members of a class have used
the @code{default} access mode.  However, this is typically not what you will
want to be the case.  Usually, you will want to restrict access to the data
members of a class --- allowing access only through methods.  There will also
be times when you will want to define methods that are private to a class.

@subheading Access Modifier Syntax

An access modifier precedes the rest of a member's type specification.  That
is, it must begin a member's declaration statement.  As an example:

@example
public int i;
private double j;

private int myMethod(int a, char b) @{
  @dots{}
@}
@end example

@subheading Access Control and Inheritance

Consult the chapter on @ref{Inheritance} for more on the topic of access
control in relation to inheritance.

@c ........................................

@node Improved Stack Class
@subsection An Improved @code{Stack} Class
@cindex @code{Stack} class, improved

@subheading StackImproved.java

Compare this code with that of @ref{Stack Class}.  @footnote{Notice how all
of the prior code except what is changed can easily be reused using
TexiWebJr's modular system.}

@(StackImproved.java@)=
class StackImproved {
  @<Stack Private Instance Variables@>
  @<Stack Constructor@>
  @<Stack Instance Methods@>
}

@

@subheading Stack Private Instance Variables

@<Stack Private Instance Variables@>=
/* Now, both stck and tos are private.  This means
   that they cannot be accidentally or maliciously
   altered in a way that would be harmful to the stack.
 */

private int[] stck = new int[10];
private int tos;

@

Now both @code{stck}, which holds the stack, and @code{tos}, which is the
index of the top of the stack, are specified as @code{private}.  This means
that they cannot be accessed or altered except through @code{push()} and
@code{pop()}.  Making @code{tos} private, for example, prevents other parts
of your program from inadvertently setting it to a value that is beyond the
end of the @code{stck} array.  In other words, the following code, added to
the end of the @code{TestStack.java} program (@pxref{TestStack-Main-Method}),
would be illegal and the program would not compile:

@example
mystack1.tos = -2;
mystack2.stck[3] = 100;
@end example


@c -----------------------------------------------------------------------------

@node static Keyword
@section @code{static} Keyword
@cindex @code{static} Keyword
@cindex keyword @code{static}
@cindex @code{static} members

There will be times when you want to define a class member that will be used
independently of any object of that class.  Normally, a class member must be
accessed in conjunction with an object of its class.  However, it is possible
to create a member that can be used by itself without reference to a specific
instance.  To create such a member, precede its declaration with the keyword
@code{static}.  When a member is declared @code{static}, it can be accessed
before any objects of its class are created, and without reference to any
object.

You can declare both methods and variables to be @code{static}.  Instance
variables declared as @code{static} are essentially global variables.  When
objects of its class are declared, no copy of a @code{static} variable is
made.  Instead, all instances of the class share the same @code{static}
variable.

@subheading Restrictions on @code{static} Methods
@cindex static restrictions on methods

Methods declared as @code{static} have several restrictions:

@itemize
@item
they can only directly call other @code{static} methods of their class;
@item
they can only directly access @code{static} variables of their class;
@item
they cannot refer to @code{this} or @code{super} in any way;
@end itemize

@subheading @code{static} Block
@cindex @code{static} initialization block

If you need to do computation in order to initialize your @code{static}
variables, you can declare a @code{static} block that gets executed exactly
once, when the class is first loaded (@dfn{static initialization block}).

@example
class UseStatic @{
  static int a = 3;
  static int b;

  static @{
    b = a * 4;
  @}
@}
@end example

As soon as the @code{UseStatic} class is loaded, all of the @code{static}
statements are run.  First, @code{a} is set to @samp{3}, then the
@code{static} block executes and initializes @code{b} to @samp{a * 4} or
@samp{12}.  Then @code{main()} is called (not shown).

@subheading Use of @code{static} Members Outside Their Class
@cindex global members

Outside of the class in which they are defined, @code{static} methods and
variables can be used independently of any object.  To do so, you need only
specify the name of their class followed by the dot operator:
@slanted{classname.method()}.  @slanted{classname} is the name of the class
in which the @code{static} method is declared.  A @code{static} variable can
be accessed in the same way.  This is how Java implements a controlled
version of global methods and global variables.


@c -----------------------------------------------------------------------------

@node final Keyword
@section @code{final} Keyword
@cindex @code{final} Keyword
@cindex keyword @code{final}
@cindex constant, @code{final} variable

A field can be declared as @code{final}.  Doing so prevents its contents from
being modified, making it, esentially, a constant.  This means that you must
initialize a @code{final} field when it is declared.  You can do this in one
of two ways: when it is declared, or within a constructor.

In addition to fields, both method parameters and local variables can be
declared as @code{final}.  Declaring a parameter as @code{final} prevents it
from being changed within the method.  Declaring a local variable
@code{final} prevents it from being assigned a value more than once.

The keyword @code{final} can also be applied to methods, but its meaning is
different than when applied to variables.  This usage of @code{final} is
described in the next chapter (@pxref{Inheritance}).


@c -----------------------------------------------------------------------------

@node Arrays 2
@section Arrays Revisited
@cindex Arrays
@cindex arrays as objects
@cindex @code{length} instance variable

Arrays are implemented as objects.  Because of this, there is a special array
attribute that you will want to take advantage of.  Specifically, the size of
an array---that is, the number of elements that an array can hold---is found
in its @code{length} instance variable.  All arrays have this variable, and
it will always hold the size of the array.  Keep in mind that the value of
@code{length} has nothing to do with the number of elements that are actually
in use.  It only reflects the number of elements taht the array is designed
to hold.

@c -----------------------------------------------------------------------------

@node Nested and Inner Classes
@section Nested and Inner Classes
@cindex nested classes
@cindex static and non-static nested classes
@cindex inner classes
@cindex classes, nested and inner
@cindex inner classes, event handling
@cindex anonymous inner classes
@cindex inner classes, anonymous

It is possible to define a class within another class; such classes are known
as @dfn{nested classes}.  The scope of a nested class is bounded by the scope
of its enclosing class.  A nested class does not exist independently of its
enclosing class.  A nested class has access to the members, including private
members, of the enclosing class.  However,the enclosing class does not have
access to the members of the nested class.  A nested class that is declared
directly within its enclosing class scope is a member of its enclosing
class.  It is also possible to declare a nested class that is local to a
block.

@heading Static Nested Class

There are two types of nested class: @dfn{static} and @dfn{inner}.  A
static nested class is one that has the @code{static} modifer applied.
Because it is static, it must access the non-static members of its enclosing
class through an object.  That is, it cannot refer to non-static members of
its enclosing class directly.  Static nested classes are seldom used.

@heading Inner Class

The most important type of nested class is the @dfn{inner} class.  An inner
class is a non-static nested class.  It has access to all of the variables
and methods of its outer class and may refer to them directly in the same way
that other non-static members of the outer class do.

An instance of an inner class can be created only in the context of its
enclosing class.  The Java compiler will report an error otherwise.  In
general, an inner class instance is often creaed by code wihtin its enclosing
scope.

It is possible to define inner classes within any block scope, including
within the block defined by a method or even within the body of a @code{for}
loop.

@heading Handling Events

While nested classes are not applicable to all situations, they are
particularly helpful when handling events.  @xref{Event Handling}.  There are
also @dfn{anonymous inner classes}, inner classes that don't have a name.

@c -----------------------------------------------------------------------------

@node String Class
@section The @code{String} Class
@cindex @code{String} Class
@cindex class @code{String}

Every string you create is an object of type @code{String}.  Even string
constants are @code{String} objects.  For example, in the statement
@kbd{System.out.println("This is a String, too");}, the quote is a
@code{String} object.  

Objects of type @code{String} are immutable; once a @code{String} object is
created, its contents cannot be altered.  Java defines peer classes of
@code{String}, called @code{StringBuffer} and @code{StringBuilder}, which
allow strings to be altered, so all of the normal string manipulations are
still available.

@heading Constructing @code{String} Objects and Concatenating @code{Strings}
@cindex @code{String} construction
@cindex @code{String} concatenation
@cindex @code{String} operator @kbd{+}

Strings can be constructed in a variable of ways.  The easiest is to use a
statement:

@example
String myString = "this is a test";
@end example

Java defines one operator for @code{String} objects: @kbd{+}.  It is used to
concatenate two strings.

@example
String myString = "I" + " like " + "Java.";
@end example

@heading @code{String} Methods
@cindex @code{String} methods
@cindex @code{equals()}
@cindex @code{length()}
@cindex @code{charAT()}

The @code{String} class contains several methods that you can use.

@itemize
@item
boolean @code{equals(@slanted{secondStr})}
@item
int @code{length()}
@item
char @code{charAt(@slanted{index})}
@end itemize


@c -----------------------------------------------------------------------------

@node Command-Line Arguments
@section Using Command-Line Arguments
@cindex command-line arguments
@cindex arguments, command-line

Sometimes you will want to pass information into a program when you run it.
This is accomplished by passing @dfn{command-line arguments} to
@code{main()}.  A command-line argument is the informatino that directly
follows the program's name on the command line when it is executed.  To
access the command-line arguments inside a Java program, access the
@code{String} arguments passed to the @code{args} parameter of
@code{main()}.  The first command-line argument is stored at @code{args[0]},
the second at @code{args[1]}, and so on.  All command-line arguments are
passed as strings.  You must convert numeric values to their internal forms
manually.  @xref{java Lang}.

@c -----------------------------------------------------------------------------

@node Varargs
@section Varargs: Variable-Length Arguments
@cindex varargs
@cindex variable-length arguments
@cindex arguments, varargs
@cindex variable-arity method
@cindex varargs method
@cindex method, varargs

Beginning with JDK 5, Java has included a feature that simplifies the
creation of methods that need to take a variable number of arguments.  This
feature is called @dfn{varargs} and it is short for @dfn{variable-length
arguments}.  A method that takes a variable number of arguments is called a
@dfn{variable-arity method}, or simply @dfn{varargs method}.

A variable-length argument is specified by three period (@dots{}).  For
example: @kbd{static void vaTest (int @dots{} v) @{}.  This syntax tells the
compiler that @code{vaTest()} can be called with zero or more arguments.  As
a result, @code{v} is implicitly declared as an array of type @code{int[]}.
Thus, inside @code{vaTest()}, @code{v} is accessed using the normal array
syntax. 

A method can have @emph{normal} parameters along with a variable-length
parameter, but the variable-length parameter must be the final parameter
declared by the method.  Further, there can be only one varargs parameter.

@example
int doIt(int a, int b, double c, int @dots{} vals) @{
@end example

After the first three arguments, any remaining arguments are passed to
@code{vals}.  

@heading Overloading Vararg Methods
@cindex vararg overloading
@cindex vararg ambiguity

You can overload a method that takes a variable-length argument (i.e., it can
be given a different type, or additional parameters can be included, or a non
varargs parameter).

Note that unexpected errors can result when overloading a method that takes a
variable-length argument.  These errors involve ambiguity because it is
possible to create an ambiguous call to an overloaded varargs method.  In
such a case, the program will not compile.  While each individual method
declaration might be valid, the call might yet be ambiguous.





@c *****************************************************************************

@node Inheritance
@chapter Inheritance
@cindex Inheritance
@cindex superclass
@cindex subclass
@cindex hierarchical classifications

Inheritance is a cornerstone of object-oriented programming because it allows
the creation of hierarchical classifications.  Using inheritance, you can
create a general class that defines traits common to a set of related items.
This class can then be inherited by other, more specific classes, each adding
those things that are unique to them.

A class that is inherited is called a @dfn{superclass}.  The class that does
the inheriting is called a @dfn{subclass}.  A subclass is a specialized
version of a subclass.  It inherits all of the members defined by the
superclass and adds its own, unique elements.


@c -----------------------------------------------------------------------------

@node Inheritance Basics
@section Inheritance Basics
@cindex inheritance basics
@cindex keyword @code{extends}
@cindex @code{extends} keyword

To @emph{inherit} a class, incorporate the definition of one class into
another by using the @code{extends} keyword.

@example
class A @{@dots{}@}
class B extends A @{@dots{}@}
@end example

A subclass will include all of the members of its superclass.  The subclass
can directly reference all of the members of the superclass as well.
Subclasses can be superclasses of other subclasses.

@heading General Form of a Subclass Inheriting a Superclass

@float GeneralForm,Subclass
@display
class @ii{subclass-name} extends @ii{superclass-name} @{
  @ii{body of class}
@}
@end display
@caption{Subclass General Form}
@end float

A subclass can have only one superclass.  Java does not support the
inheritance of multiple superclasses into a single subclass.

@c ....................................

@node Member Access and Inheritance
@subsection Member Access and Inheritance
@cindex inheritance, member access
@cindex member access, inheritance
@cindex @code{private} and inheritance

Although a subclass includes all of the members of its superclass, it cannot
access those members of the superclass that have been declared as
@code{private}.  A class member that has been declared as @code{private} will
remain private to its class.  It is not accessible by any code outside its
class, including subclasses.

A major advantage of inheritance is that once you have created a superclass
that defines the attributes commoin to a set of objects, it can be used to
create any number of more specific subclasses.  Each subclass can precisely
tailor its own classification.

@c ....................................

@node Superclass Referencing Subclass
@subsection A Superclass Variable Can Reference a Subclass Object
@cindex superclass referencing subclass
@cindex reference variable, superclass

A reference variable of a superclass can be assigned a reference to any
subclass derived from that superclass.  

It is important to understand that itis the @emph{type of the reference
variable} --- not the type of the object that it refers to --- that
determines what members can be accessed.  That is, when a reference to a
subclass object is assigned to a superclass reference variable, you will have
access @emph{only} to those parts of the object defined by the superclass.
The superclass has no knowledge of what a subclass adds to it.


@c *****************************************************************************

@node Using super
@section Using @code{super}
@cindex @code{super}, using

Whenever a subclass needs to refer to its immediate superclass, it can do so
by use of the keyword @code{super}.  @code{super} has two general forms.  The
first calls the superclass' constructor.  The second is used to access a
member of the superclass that has been hidden by a member of a subclass.

@c .....................................

@node super Calling Superclass Constructor
@subsection Using @code{super} to Call Superclass Constructors
@cindex @code{super} calling superclass constructors

A subclass can call a constructor defined by its superclass by use of the
following form of @code{super}:

@float GeneralForm,SuperCallingConstructor
@display
super(@ii{arg-list});
@end display
@caption{@code{super} Calling a Constructor}
@end float

@ii{arg-list} specifies any arguments needed by the constructor in the
superclass.  @code{super()} must always be the first statement executed
inside a subclass' constructor.  @code{super()} can be called using any form
defined by the superclass.

@c .....................................

@node super Referencing Superclass
@subsection @code{super} Referencing Superclass
@cindex @code{super} referencing superclass
@cindex member hiding

The second form of @code{super} acts somewhat like @code{this}, except that
it always refers to the superclass of the subclass in which it is used.

@float GeneralForm,SuperReferencingSuperclass
@display
super.@ii{member}
@end display
@caption{@code{super} Referencing its Superclass}
@end float

@ii{member} can be either a method or an instance variable.  This form of
@code{super} is most applicable to situations in which member names of a
subclass hide members by the same name in the superclass.

@example
i = super.i;
@end example

@code{super} allows access to the @code{i} defined in the superclass.
@code{super} can also be used to call methods that are hidden by a subclass.


@c -----------------------------------------------------------------------------

@node Multilevel Hierarchy
@section Creating a Multilevel Hierarchy
@cindex multilevel hierarchy
@cindex hierarchy, multilevel, creating
@cindex hierarchy, files

You can buidl hierarchies that contain as many layers of inheritance as you
like.  It is acceptable to use a subclass as a superclass of antoher.  Each
subclass inherits all of tghe traits found in all of its superclasses.

@code{super} always refers to the constructor in the closest superclass.

While an entire class hierarchy can be created in a single file, the
individual classes (superclasses and subclasses) can be placed into their own
files and compiled separately.  Using separate files is the norm, not the
exception, in creating class hierarchies.


@c -----------------------------------------------------------------------------

@node Constructors Executed
@section When Constructors are Executed
@cindex hierarchy, constructors executed

In a class hierarchy, constructors complete their execution in order of
derivation, from superclass to subclass.


@c -----------------------------------------------------------------------------

@node Method Overriding
@section Method Overriding
@cindex method overriding
@cindex overriding, method
@cindex overload versus override

In a class hierarchy, when a method in a subclass has the same name and type
signature as a method in its superclass, then the method in the subclass is
said to @dfn{override} the method in the superclass.  When an overriden
method is called from within its subclass, it will always refer to the
version of that method defined by the subclass.  The version of the method
defined by the superclass will be hidden.

If you wish to access the superclass version of an overridden method, you can
so by using @code{super}.

Method overriding occurs @emph{only} when the names and the type signatures
of the two methods are identical.  If they are not, then the two methods are
simply overloaded (no name hiding takes place).


@c -----------------------------------------------------------------------------

@node Dynamic Method Dispatch
@section Dynamic Method Dispatch
@cindex dynamic method dispatch
@cindex polymorphism, run-time

Method overriding forms the basis for one of Java's most powerful concepts:
@dfn{dynamic method dispatch}.  This is a meachanism by which a call to an
overrident method is resolved at run time, rather than compile time.  This is
important because this is how Java implements run-time polymorphism.

A superclass reference variable can refer to a subclass object.  Java uses
this fact to resolve calls to overriden methods at run time.  When an
overriden method is called through a superclass reference, Java determines
which version of that method to execute based upon the type of the object
being referred to at the time the call occurs.  Thus, this determination is
made at run time.  When different types of objects are referred to, different
versions of an overridden method will be called.  In other words, @emph{it is
the type of the object being referred to} (not the type of the reference
variable) that determines which version of an overridden method will be
executed.  Therefore, if a superclass contains a method that is overridden by
a subclass, then when different types of objects are referred to through a
superclass reference variable, different versions of the method are executed.

@c .....................................

@node Why Overridden Methods
@subsection Why Overridden Methods?
@cindex polymorphism, dynamic run-time
@cindex one interface, many methods polymorphism

Overridden methods allow Java to support run-time polymorphism.  Polymorphism
is essential to object-oriented programming for one reason: it allows a
general class to specify methods that will be common to all of its
derivatives, while allowing subclasses to define the specific implementation
of some or all of those methods.  Overridden methods are another way that
Java implements the ``one interface, multiple methods'' aspect of
polymorphism.

Successfully applying polymorphism is understanding that the superclasses and
subclasses form a hierarchy which moves from lesser to greater
specialization.  Used correctly, the superclass provides all elements that a
subclass can use directly.  It also defines those methods that the derived
class must implement on its own.  This allows the subclass the flexibility to
define its own methods, yet still enforces a consistent interface.  Thus, by
combining inheritance with overridden methods, a superclass can define the
general form of the methods that will be used by all of its subclasses.

Dynamic, run-time polymorphism is one of the most powerful mechanisms that
object-oriented design brings to bear on code reuse and robustness.  The
ability of existing code libraries to call methods on instances of new
classes without recompiling while maintaining a clean abstract interface is a
profoundly powerful tool.

@c .....................................

@node Applying Method Overriding
@subsection Applying

Let's look at a practical example that uses method overriding.  The following
program creates a superclass called @code{Figure} that stores the dimensions
of a two-dimensional object.  It also defines a method called @code{area()}
that computes the area of an object.  The program derives two subclasses from
@code{Figure}.  The first is @code{Rectangle} and the second is
@code{Triangle}.  Each of these subclasses overrides @code{area()} so that it
returns the area of a rectangle and a triangle respectively.

@(FindAreas.java @)=
@<FindAreas SuperClass Figure @>
@<FindAreas SubClass Rectangle @>
@<FindAreas SubClass Triangle @>
@<FindAreas Main Class @>

@

@subsubheading Output

The output from the program should be:

@example
Inside Area for Rectangle.
Area is 45
Inside Area for Triangle.
Area is 40
Area for Figure is undefined.
Area is 0
@end example

Through the dual mechanisms of inheritance and run-time polymorphism, it is
possible to define one consistent interface that is used by several
different, yet related, types of objects.  In this case, if an object is
derived from @code{Figure}, then its area can be obtained by calling
@code{area()}. The interface to this operation is the same no matter what
type is being used.

@c .....................................

@node FindAreas SuperClass Figure Node
@subsubsection FindAreas Superclass Figure Section

@<FindAreas SuperClass Figure @>=
class Figure {
  @<Figure Instance Variable Declarations @>
  @<Figure Constructor @>
  @<Figure Area Method Declaration @>
}

@

@subsubheading Figure Instance Variable Declarations

@<Figure Instance Variable Declarations @>=
double dim1;
double dim2;

@

@subsubheading Figure Constructor

@<Figure Constructor @>=
Figure (double 1, double b) {
  dim1 = a;
  dim2 = b;
}

@

@subsubheading Figure Area Method Declaration

It will be this method that will be overridden by the two subclasses; while
this method will not produce any output, each of the subclasses will provide
a formula for their own area and output that number, even though the same
method (@code{area()}) is being called in each case from the same variable.

@<Figure Area Method Declaration @>=
double area() {
  System.out.println("Area for Figure is undefined.");
  return 0;
}

@

@c .....................................

@node FindAreas SubClass Rectangle Node
@subsubsection FindAreas SubClass Rectangle Section

@<FindAreas SubClass Rectangle @>=
class Rectangle extends Figure {
  @<Rectangle Constructor @>
  @<Rectangle Area Method Declaration @>
}

@

@subsubheading Rectangle Constructor

@<Rectangle Constructor @>=
Rectangle (double a, double b) {
  super(a, b);
}

@

@subsubheading Rectangle Area Method Declaration

@<Rectangle Area Method Declaration @>=
// override area for rectangle
double area() {
  System.out.println("Inside Area for Rectangle.";
  return dim1 * dim2;
}

@

@c .....................................

@node FindAreas SubClass Triangle Node
@subsubsection FindAreas SubClass Triangle Section

@<FindAreas SubClass Triangle @>=
class Triangle extends Figure {
  @<Triangle Constructor @>
  @<Triangle Area Method Declaration @>
}

@

@subsubheading Triangle Constructor

@<Triangle Constructor @>=
Triangle (double a, double b) {
  super(a, b);
}

@

@subsubheading Triangle Area Method Declaration

@<Triangle Area Method Declaration @>=
// override area for right triangle
double area () {
  System.out.println("Inside Area for Triangle.");
  return dim1 * dim2 / 2;
}

@

@c .....................................


@node FindAreas Main Class Node
@subsubsection FindAreas Main Class Section

@<FindAreas Main Class @>=
class FindAreas {
  @<FindAreas Main Method Declaration @>
}

@

@subsubheading FindAreas Main Method Declaration

@<FindAreas Main Method Declaration @>=
public static void main (String[] args[]) {
  @<Create Basic Figure Objects @>
  @<Create Basic Figure Reference Variable @>
  @<Call Overridden Methods One By One @>
}

@

@subsubheading Create Basic Figure Objects

@<Create Basic Figure Objects @>=
Figure f = new Figure(10, 10);
Rectangle r = new Rectangle(9, 5);
Triangle t = new Triangle(10, 8);

@

@subsubheading Create Basic Figure Reference Variable

This superclass reference variable @code{Figure figref} will hold,
alternately, references to each of the classes and will call the method
@code{area()} on each, producing a different result each time.  This is the
essence of method overriding and dynamic method dispatch.

@<Create Basic Figure Reference Variable @>=
Figure figref;

@

@subsubheading Call Overridden Methods One By One

@<Call Overridden Methods One By One @>=
figref = r;
System.out.println("Area is " + figref.area());

figref = t;
System.out.println("Area is " + figref.area());

figref = f;
System.out.println("Area is " + figref.area());

@


@c -----------------------------------------------------------------------------

@node Using Abstract Classes
@section Using Abstract Classes
@cindex abstract class, inheritance
@cindex abstract method
@cindex @code{abstract} type modifier

There are situations in which you will want to define a superclass that
declares the structure of a given abstraction without providing a complete
implementation of every method.  That is, sometimes you will wnat to create a
superclass that only defines a generalized form that will be shared by all of
its subclasses, leaving it to each subclass to fill in the details.  Such a
class determines the nature of the methods that the subclasses must
implement.  One way this situation can occur is when a superclass is unable
to create a meaningful implementation for a method.  This is the case with
@code{Figure} in the preceding example.  The definition of @code{area()} is
simply a placeholder.  It will not compute and display the area of any type
of object.

It is not uncommon for a method to have no meaningful definition in the
context of its superclass.  Java's solution to this problem is the
@dfn{abstract method}.

You can require that certain methods be overridden by subclasses by
specifying the @code{abstract} type modifier.  These methods are sometimes
referred to as @dfn{subclasser responsibility} because they have no
implementation specified in the superclass.  Thus, a subclass must override
them --- it cannot simply use the version defined in the superclass.

To declare an abstract method, use the general form:

@float GeneralForm,AbstractMethodDeclaration
@display
abstract @ii{type} @ii{name} (@ii{parameter-list});
@end display
@caption{Abstract Method Declaration---General Form}
@end float

@noindent No method body is present.

Any class that contains one or more abstract methods must also be declared
abstract.  To declare a class abstract, simply use the @code{abstract}
keyword in front of the @code{class} keyword at the beginning of the class
declaration.  There can be no objects of an abstract class.  That is, an
abstract class cannot be directlyi instantiated with the @code{new}
operator.  You cannot declare abstract constructors or abstract static
methods.  Any subclass of an abstract class must either implement all of the
abstract methods in the superclass, or be declared @code{abstract} itself.
Abstract classes can include fully implemented methods.

@heading Abstract Classes Can Be Reference Variables
@cindex run-time polymorphism, abstract class

Although abstract classes cannot be used to instantiate objects, they can be
used to create object references, because Java's approach to run-time
polymorphism is implemented thruogh the use of superclass references.  Thus,
it must be possible to create a reference to an asbtract class so that it can
be used to point to a subclass object.  

@c .....................................

@node Improved Figure Class
@subsection Improved Figure Class

Using the abstract class, you can improve the @code{Figure} class.  Since
there is no meaningful concept of area for an undefined two-dimensional
figure, the following version of the program declares @code{area()} as
abstract inside @code{Figure}.  This means that all classes derived from
@code{Figure} must override @code{area()}.

@(AbstractAreas.java @)=
@<AbstractAreas Abstract Class Figure @>
@<FindAreas SubClass Rectangle @>
@<FindAreas SubClass Triangle @>
@<AbstractAreas Main Class @>

@

@c _____________________________________

@node AbstractAreas Abstract Class Figure Node
@subsubsection AbstractAreas Abstract Class Figure Section

Notice that much of this class stays the same as the original @code{Figure}
code, but includes two @code{abstract} declarations, one for the class, and
one for the @code{area()} method declaration.

@<AbstractAreas Abstract Class Figure @>=
abstract class Figure {
  @<Figure Instance Variable Declarations @>
  @<Figure Constructor @>
  @<AbstractAreas Abstract Area Method Declaration @>
}

@

@subsubheading AbstractAreas Abstract Area Method Declaration

@<AbstractAreas Abstract Area Method Declaration @>=
// areas is now an abstract method
abstract double area ();

@

@c .....................................

@node AbstractAreas Main Class
@subsubsection Abstract Main Class

@<AbstractAreas Main Class @>=
class AbstractAreas {
  @<AbstractAreas Main Method Declaration @>
}

@

@subsubheading AbstractAreas Main Method Declaration

@<AbstractAreas Main Method Declaration @>=
public static void main (String[] args) {
  @<Create Basic Figure Objects Except Figure @>
  @<Create Basic Figure Reference Variable @>
  @<Call Overridden Methods One By One Except Figure @>
}

@

@subsubheading Create Basic Figure Objects Except Figure

The only difference here is that because the superclass Figure is now
abstract, it cannot be instantiated using @code{new}.  It can, however, be
used as a reference variable, and so the declaration @kbd{Figure figref;} is
still valid and does not change from the prior implementation.  @strong{This
is the essence of run-time polymorphism and dynamic method dispatch.}

@<Create Basic Figure Objects Except Figure @>=
// abstract class Figure cannot be instantiated
// Figure f = new Figure (10, 10);
Rectangle r = new Rectangle (9, 5);
Triangle t = new Triangle (10, 8);

@

@subsubheading Call Overridden Methods One By One Except Figure

The only difference here is that, because there is no @code{Figure} object,
it cannot be referenced.

@<Call Overridden Methods One By One Except Figure @>=
figref = r;
System.out.println("Area is " + figref.area());

figref = t;
System.out.println("Area is " + figref.aread());

// there is no Figure object, so this will not work.
// figref = f;

@


@c -----------------------------------------------------------------------------

@node final with Inheritance
@section Using @code{final} with Inheritance
@cindex @code{final} with inheritance

The keyword @code{final} has three uses.

@enumerate
@item
create the equivalent of a name constant.
@item
prevent overriding
@item
prevent inheritance
@end enumerate

@c .....................................

@node final to Prevent Overriding
@subsection Using @code{final} to Prevent Overriding
@cindex @code{final} to prevent overriding
@cindex inline, inlining
@cindex late binding
@cindex early binding
@cindex binding, late, early
@cindex performance enhancement, inlining

There will be times when you want to prevent overriding from occurring.  To
disallow a method from being overridden, specify @code{final} as a modifier
at the start of its declaration.  Methods declared as @code{final} cannot be
overridden.

Methods declared as @code{final} can sometimes provide a performance
enhancement.  The compiler is free to @dfn{inline} calls to them because it
knows they will not be overridden by a subclass.  Inlining is an option only
with @code{final} methods.  Normally, Java resolves calls to methods
dynamically, at run time.  This is called @dfn{late binding}.  However, since
@code{final} methods cannot be overridden, a call to one can be resolved at
compile time.  This is called @dfn{early binding}.

@c .....................................

@node final to Prevent Inheritance
@subsection Using @code{final} to Prevent Inheritance
@cindex @code{final} to prevent inheritance

Sometimes you will want to prevent a class from being inherited.  To do this,
precede the class declaration with @code{final}.  Declaring a class as
@code{final} implicitly declares all of its methods as @code{final} also.


@c -----------------------------------------------------------------------------

@node Object Class
@section The Object Class
@cindex Object class

There is one special class, @code{Object}, defined by Java.  All other
classes are subclasses of @code{Object}.  That is, @code{Object} is a
superclass of all other classes.  This means that a reference variable of
type @code{Object} can refer to an object of any other class.  Also, since
arrays are implemented as classes, a variable of type @code{Object} can also
refer to any array.

@heading @code{Object} Methods

@code{Object} defines the following methods; this means they are available in
every object.

@ftable @code
@item Object clone()
Creates a new object that is the same as the object being cloned.
@item boolean equals(Object @slanted{object})
Determines whether one object is equal to another.
@item void finalize()
Called before an unused object is recycled.  (Deprecated by JDK 9).
@item Class<?> getClass()
Obtains the class of an object at run time.
@item int hashCode()
Returns the hash code associated with the invoking object.
@item void notify()
Resumes execution of a thread waiting on the invoking object.
@item void notifyAll()
Resumes execution of all threads waiting on the invoking object.
@item String toString()
Returns a string that describes the object.
@item void wait()
@itemx void wait(long @slanted{milliseconds})
@itemx void wait(long @slanted{millisconds}, int @slanted{nanoseconds})
Waits on another thread of execution
@end ftable

The methods
@itemize
@item
@code{getClass()}
@item
@code{notify()}
@item
@code{notifyAll()}
@item
@code{wait()}
@end itemize

@noindent are declared as @code{final}.  You may override the others.

However, notice two methods now:
@cindex @code{equals()}
@cindex @code{toString()}

@table @code
@item equals()
compares two objects; returns @code{true} if the objects are equal, and
@code{false} if not; the precise definition of equality can vary, depending
on the type of objects being compared.
@item toString()
returns a string that contains a description of the object on which it is
called; this method is automatically called when an object is output using
@code{println()}; many classes override this method; doing so allows them to
tailor a description specifically for the types of objects that they create.
@end table





@c *****************************************************************************

@node Packages
@chapter Packages
@cindex Packages (chapter)
@cindex containers, packages as
@cindex compartmentalized
@cindex class namespace, compartmentalize
@cindex packages, purposes, prevent collisions
@cindex collisions, prevention
@cindex packages, how stored
@cindex packages, import
@cindex import packages
@cindex hierarchical structure, packages

@ii{Packages} are containers for classes.  They are used to keep the class
namespace compartmentalized, i.e., to prevent collisions between file names.
Packages are stored in a hierarchical manner and are explicitly imported into
new class definitions.


@c -----------------------------------------------------------------------------

@node Packages Intro
@section Introduction to Packages
@cindex Introduction to Packages (section)
@cindex partitioning mechanism
@cindex naming mechanism
@cindex visibility mechanism
@cindex accessibility
@cindex exposure of code

Java provides a mechanism for partitioning the class namespace into
manageble chunks: the @dfn{PACKAGE}.  The package is both a naming and
a visibility control mechanism.  In other words, you can use the
package mechanism to define classes inside a package that are not
accessible by code outside the package; and you can define class
members that are exposed only to other members of the same package.

@c -----------------------------------------------------------------------------

@node Defining Packages
@section Defining Packages
@cindex Packages, Defining (section)
@cindex @command{package} command
@cindex default package
@cindex package statement
@cindex package namespace

To create a package (``define'' a package), include the
@command{package} command as the first statement in a Java source
file.  Thereafter, any classes declared within that file will belong
to the specified package.  The @command{package} statement defines a
namespace in which classes are stored.  Without the @command{package}
statement, classes are put into the @file{default} package (which has
no name).

@subheading General Form of @command{package} statement
@cindex package statement, general form

@float GeneralForm,PackageStatement
@display
package @ii{pkg}
@end display
@caption{Package Statement --- General Form}
@end float

@ii{pkg} is the name of the package.  For example:
@cindex package statement, example

@example
package mypackage;
@end example

@subheading File System Directories
@cindex packages stored in file system

Java uses the file system directories to store packages.  Therefore, the
@code{.class} files for any classes you declare to be part of
@code{mypackage} must be stored in a directory called @code{mypackage}.  The
directory name must match the package name exactly.

More than one file can include the same @command{package} statement.  The
@command{package} statement simply specifies to which package the classes
defined in a file belong.  It does not exclude other classes in other files
from being part of that same package.  Most real-world packages are spread
across many files.

@subheading Hierarchy of Packages
@cindex packages hierarchy
@cindex hierarchy of packages

You can create a hierarch of packages.  To do so, separate each package name
form the one above it by use of a period.  The general form of a multileveled
package statement is:
@cindex package statement, multilevel form

@float GeneralForm,PackageStatementMulti
@display
package @ii{pkg1[.pkg2[.pkg3]]}
@end display
@caption{Package Statement --- Multilevel Form}
@end float

A package hierarchy must be reflected in the file system of your Java
development system.  For example a package declared as:

@example
package a.b.c;
@end example

needs to be stored in directory @file{a/b/c}.

@cindex package renaming
Be sure to choose package names carefully; you cannot rename a package
without renaming the directory in which the classes are stored.


@c -----------------------------------------------------------------------------

@node Classpath
@section Finding Packages and CLASSPATH
@cindex @env{CLASSPATH} @option{-classpath}
@cindex finding packages
@cindex run-time system, finding packages
@cindex modules, packages
@cindex module path
@cindex JDK 9, package part of module

Packages are mirrored by directories.  How does the Java run-time system know
where to look for packages?

@table @b
@item @samp{cwd}
By default, the Java run-time system uses the currect working directory as
its starting point.  Thus, if your package is in a subdirectory of the
current directory, it will be found.
@item @env{CLASSPATH}
You can specify a directory path or paths by setting the @env{CLASSPATH}
environment variable.
@item @option{-classpath}
You can use the @option{-classpath} option with @command{java} and
@command{javac} to specify the path to your classes.
@item module path
Beginning with JDK 9, a package can be part of a module, and thus found on
the @file{module path}.
@end table

@subheading Example Finding a Package
@cindex packages, finding, example

Consider the following package specification:

@example
package mypack;
@end example

In order for programs to find @code{mypack}, the program can be executed from
a directory @strong{immediadely above} @code{mypack}, or the @env{CLASSPATH}
must be set to include the path to @code{mypack} or the @option{-classpath}
option must specify the path to @code{mypack} when the program is run via
@command{java}.

When the second or third of the above options is used, the @file{class
path} @strong{must not include} @file{mypack} itself.  It must simply
specify the @file{path} to just above @file{mypack}.  For example, if
the path to @file{mypack} is

@example
/MyPrograms/Java/mypack
@end example

then the class path to @code{mypack} is

@example
/MyPrograms/Java
@end example


@c -----------------------------------------------------------------------------

@node Member Access
@section Packages and Member Access
@cindex access control, packages
@cindex packages, access control
@cindex member access
@cindex access, member

Packages add another dimension to access control.  Classes and packages are
both means of encapsulating and containing the name space and scope of
variables and methods.  @emph{Packages} act as containiners for classes and
other subordinate packages.  @emph{Classes} act as containers for data and
code.  The class is Java's smallest unit of abstraction.  As it relates to
the interplay between classes and packages, Java addresses four categories of
visibility for class members:

@itemize
@item
Subclasses in the same package
@item
Non-subclasses in the same package
@item
Subclasses in different packages
@item
Classes that are neither in the same package nor subclasses
@end itemize

The three access modifiers

@itemize
@item
private
@item
public
@item
protected
@end itemize

provide a variaty of ways to produce many levels of access required by these
categories.
@cindex access control table

@float Table,PackageAccess
@multitable @columnfractions .4 .15 .15 .15 .15
@headitem Category @tab Private @tab None @tab Protected @tab public
@item
Same Class @tab Yes @tab Yes @tab Yes @tab Yes
@item
Same package subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Same package non-subclass @tab No @tab Yes @tab Yes @tab Yes
@item
Different package subclass @tab No @tab No @tab Yes @tab Yes
@item
Different package noni-subclass @tab No @tab No @tab No @tab Yes
@end multitable
@caption {Package Access Table --- Shows all combinations of the access
control modifiers}
@shortcaption{Package Access Table}
@end float


@c -----------------------------------------------------------------------------

@node Importing
@section Importing Packages
@cindex packages, importing
@cindex importing packages

Java includes the @command{import} statement to bring certain classes, or
entire packages, into visibility.  Once imported, a class can be referred to
directly, using only its name.  The @command{import} statement is a
convenience to the programmer and is not technically needed to write a
complete Java program.

In a Java source file, @command{import} statements occur immediately
following the @command{package} statement (if one exists) and before any
class definitions.  This is the general form of the @command{import}
statement:
@cindex import statement, general form and example

@float GeneralForm,Import
@display
import @ii{pkg1}[.@ii{pkg2}].(@ii{classname} | *);
@end display
@caption{Import Statement --- General Form}
@end float

Here, @ii{pkg1} is the name of a top-level package, and @ii{pkg2} is the name
of a subordinate package inside the outerpackage separated by a dot
(@t{.}).  There is no limit on the depth of a package hierarchy.  Finally,
you can specify either an explicit @file{classname} or a star (@t{*}), which
indicates that the Java compiler should import the entire package.

@example
import java.util.Date;
imort java.io.*;
@end example

@cindex standard Java classes, imported implicitly
@cindex @file{java.lang}
All of the standard Java SE classes included with Java begin with the name
@file{java}.  The basic language functions are stored in a package called
@file{java.lang}.  Normally, you have to import every package or class that
you want to use, but since Java is useless without much of the functionality
in @file{java.lang}, it is implicitly imported by the compiler for all
programs.  This is equivalent to the following line being at the top of all
your programs:

@example
import java.lang.*;
@end example

@cindex import is optional
@cindex fully qualified name
The @command{import} statement is @emph{optional}.  Any place you use a class
name, you can use its @emph{fully qualified name}, which includes its full
package hierarchy.

@cindex imported packages must be public
When a package is imported, only those items within the package declared as
@command{public} will be available to non-subclasses in the importing code.




@c *****************************************************************************

@node Interfaces
@chapter Interfaces
@cindex Interfaces (chapter)
@cindex interfaces, introduction
@cindex keyword interface
@cindex abstract class
@cindex interface, implement
@cindex polymorphism, one interface multiple methods

Using the keyword @command{interface}, you can fully abstract a class'
interface from its implementation.  That is, using @command{interface}, you
can specify what a class must do, but not how to do it.  Interfaces are
syntactically similar to classes, but they lack instance variables, and, as a
general rule, their methods are declared without any body.  Once it is
defined, any number of classes can implement an @command{interface}.  Also,
one class can implement any number of interfaces.  To implement an interfce,
a class must provide the complete set of methods required by the interface.
Each class is free to determine the details of its own implementation.  By
providing the @command{interface} keyword, Java allws you to fully utilize
the ``one interface, multiple methods'' aspect of polymorphism.

@cindex dynamic method resolution
@cindex run-time
@cindex compile time
@cindex method signatures compatible
@cindex static environment
Interfaces are designed to support @dfn{dynamic method resolution} at run
time.  Normally, in order for a method to be called from one class to
another, both classes need to be present at compile time so the Java compiler
can check to ensure that the method signatures are compatible.  This
requirement by itself makes for a static and nonextensible classing
environment.  Inevitably in a system like this, functionality gets pushed up
higher and higher in the class hierarchy so that the mechanisms will be
available to more and more subclasses.  Interfaces are designed to avoid this
problem.  @emph{They disconnect the definition of a method or set of methods
from the inheritance hierarchy.}  Since interfaces are in a different
hierarchy from classes, it is possible for classes that are unrelated in
terms of class hierarchy to implement the same interface.  This is where the
real power of interfaces is realized.


@c -----------------------------------------------------------------------------

@node Defining Interfaces
@section Defining Interfaces
@cindex interfaces, defining

An interface is defined much like a class.  Here is a simplified general form
of an interface definition:
@cindex interface definition, simplified general form

@float GeneralForm,InterfaceSimple
@display
@ii{access} interface @ii{name} @{
  @ii{return-type method-name1}(@ii{parameter-list});
  @ii{return-type method-name2}(@ii{parameter-list});

  @ii{type final-varname1} = @ii{value}
  @ii{type final-varname2} = @ii{value}
  @dots{}
  @ii{return-type method-nameN}(@ii{parameter-list});
  @ii{type final-varnameN} = @ii{value}
@}
@end display
@caption{Interface Definition --- Simplified General Form}
@end float

@cindex interface default access, no modified
@cindex interface public access
@cindex abstract methods, interface
@cindex interface methods, abstract methods
When no access modifier is included, then default access results, and the
interface is only available to other members of the package in which it is
declared.  When it is declared as @command{public}, the interface can be used
by code outside its package.  In this case, the interface mst be the only
public interface declared in the file, and the file must have the same name
as the interface.  The methods that are declared have no bodies.  They end
with a semicolon after the parameter list.  They are, essentially, abstract
methods.  Each class that includes such an interface must implement all of
the methods.

@subheading Variable Declarations inside Interfaces
@cindex interface variable declarations

As the general form shows, variables can be declared inside interface
declarations.  They are implicitly @command{final} and @command{static},
meaning they cannot be changed by the implementing class.  They must also be
initialized.  All methods and variables are implicitly @command{public}.

@node Implementing Interfaces
@section Implementing Interfaces
@cindex interfaces, implementing
@cindex @command{implements} clause

Once an interface has been defined, one or more classes can implement that
interface.  To implement an interface, include the @command{implements}
clause in a class definition, and then create the methods required by the
interface.  The general form of a class that includes the
@command{implements} clause looks like this:

@float GeneralForm,ClassImplementsInterface
@display
class @ii{clasname} [extends @ii{superclass}] [implements @ii{interface} [,@ii{interface}@dots{}] @{
  @ii{class-body}
@}
@end display
@caption{Class Implementing Interface --- General Form}
@end float

@cindex interface method defintion, declared @command{public}
The methods that implement an interface must be declared @command{public}.
The type signature of the implementing method must match exactly the type
signature specified in the @command{interface} definition.

It is both permissible and common for classes that implement interfaces to
define additional members of their own.


@c -----------------------------------------------------------------------------

@node Interface References
@section Accessing Implementations Through Interface References
@cindex interface references, accessing implementations
@cindex object references, interfaces
@cindex interfaces, key feature, reference look-ups
@cindex dynamic dispatch, interface method look-ups
@cindex dispatch through an interface

You can declare variables as object references that use an interface rather
than a class type.  Any instance of any class that implements the declared
interface can be referred to by such a variable.  When you call a method
through one of these references, the correct version will be called based on
the actual instance of the interface being referred to.  This is one of the
key features of interfaces.  The method to be executed is looked up
dynamically at run-time, allowing classes to be created later than the code
which calls methods on them.  The calling code can dispatch through an
interface without having to know anything about the ``callee.''  This process
is similar to using a superclass reference to access a subclass object.


@c -----------------------------------------------------------------------------

@node Partial Implementations
@section Partial Implementations
@cindex interface, partial implementation

If a class includes an interface but does not implement the methds required
by that interface, then that class must be declared as @command{abstract}.
Any class that inherits the abstract class must implement the interface or be
declared @command{abstract} itself.


@c -----------------------------------------------------------------------------

@node Nested Interfaces
@section Nested Interfaces
@cindex interfaces, nested
@cindex nested interfaces
@cindex member interfaces

An interface can be declared a member of a class or another interface.  Such
an interface is called a @dfn{member interface} or a @dfn{nested interface}.
A nested interface can be declared as @command{public}, @command{private}, or
@command{protected}.  This differs from a top-level interface, which must
either be declared as @command{public} or use the default access level.  When
a nexted interface is used outside of its enclosing scope, it must be
qualified by the name of the class or interface of which it is a member.
Thus, outside of the class or interface in which a nested interface is
declared, its name must be fully qualified.


@c -----------------------------------------------------------------------------

@node Applying Interfaces
@section Applying Interfaces
@cindex intefaces, applying

See detailed example @dots{}


@c -----------------------------------------------------------------------------

@node Variables in Interfaces
@section Variables in Interfaces
@cindex interfaces, final variables in
@cindex interfaces, shared constants

You can use interfaces to import shared constants into multiple classes by
simply declaring an interface that contains variables that are initialized to
the desired values.  When you include that interface in a class (when you
``implement'' the interface), all of those variable names will be in scope as
constants.  If an interface contains no methods, then any class that includes
such an interface doesn't actually implement anything.  It is as if that
class were importing this constant fields into the class name space as
@command{final} variables.


@c -----------------------------------------------------------------------------

@node Extending Interfaces
@section Interfaces Can Be Extended
@cindex interfaces, extending
@cindex interfaces, inheriting
@cindex @command{extents}, with interfaces
@cindex extending interfaces
@cindex inheriting interfaces

One interface can inherit another by use of the keyword @command{extends}.
The syntax is the same as for inheriting classes.  When a class implements an
interface that inherits another interface, it must provide implementations
for all methods required by the interface inheritance chain.


@c -----------------------------------------------------------------------------

@node Default Interface Methods
@section Default Interface Methods
@cindex index interface, default methods
@cindex default methods, interface
@cindex abstract methods, interface
@cindex interface, traditional form
@cindex JDK 8, default method in interface

Prior to JDK 8, an interface could not define any implementation whatsoever.
This meant that for all previous versions of Java, the methods specified by
an interface were abstract, constaining no body.  This is the traditional
form of an interface.  The release of JDK 8 changed this by adding a new
capability to @command{interface} called the @dfn{default method}.  A default
method lets you define a default implementation for an interface method.  It
is possible for an interface method to provide a body, rather than being
abstract.

@cindex default method, interface, motivation
@cindex preexisting code, default method, interface
A primary motivation for the default method was to provide a means by which
interfaces could be expanded without breaking existing code.  There must be
implementations for all methods defined by an interface.  If a new method
were added to a popular, widely used interface, then the addition of that
method would break existing code because no implementation would be found for
that new method.  The default method solves this problem by supplying an
implementation that willbe used if no other implementation is explicitly
provided.  Thus, the addition of a default method will not cause preexisting
code to break.

Another motivation for the default method was the desire to specify methods
in an interface that are, essentially, optional, depending on how the
interface is used.

@subheading Interfaces Do No Maintain State and Cannot Be Created
@cindex interfaces, key aspect, no state
@cindex difference between class and interface

It is important to point out that the addition of default methods does not
change a key aspect of @command{interface}: its inability to maintain state
information.  An interface still cannot have instance variables, for example.
Thus, @strong{the defining difference between an interface and a class is
that a class can maintain state information, but an interface cannot.}
Furthermore, it is still not possible to create an instance of an interface
by itself.  It must be implemented by a class.


@c -----------------------------------------------------------------------------

@node Interface Static Methods
@section Use Static Methods in an Interface
@cindex interface, static method
@cindex static method, interface
@cindex method, static, interface
@cindex JDK 8, static interface method

Another capability added to interface by JDK 8 is the ability to define one
or more @command{static} methods.  Like @command{static} methods in a class,
a @command{static} method defined by an interface can be called independently
of any object.  Thus, no implementation of the interface is necessary, and no
instance of the interface is required, in order to call a @command{static}
method.  Instead, a @command{static} method is called by specifying the
interface name, followed by a period, followed by the method name.  Here is
the general form:

@float GeneralForm,InterfaceStaticMethod
@display
@ii{InterfaceName.staticMethodName}
@end display
@caption{Interface Static Method, Calling}
@end float

Notice that this is similar to the way that a @command{static} method in a
class is called.  However, @command{static} interface methods are not
inherited by either an implementing class or a subinterface.


@c -----------------------------------------------------------------------------

@node Private Interface Methods
@section Private Interface Methods
@cindex interface methods, private
@cindex JDK 9, private interface method

Beginning with JDK 9, an interface can include a private method.  A private
interface method can be called only by a default method or another private
method defined by the same interface.  Because a private interface method is
specified @command{private}, it cannot be used by code outside the interface
in which it is defined.  This restriction includes subinterfaces because a
private inteface method is not inherited by a subinterface.

The key benefit of a private interface method is that it lets two or more
default methods use a common piece of code, thus avoiding code duplication.




@c *****************************************************************************

@node I/O
@chapter I/O
@cindex I/O
@cindex @file{java.io}
@cindex input/output system
@cindex @code{try-with-resources}
@cindex @code{volative}
@cindex @code{instanceof}
@cindex @code{native}
@cindex @code{strictfp}
@cindex @code{assert}

This chapter introduces @file{java.io}, which supports Java's basic
input/output system, including file I/O.  Support for I/O comes from Java's
core API libraries, not from language keywords.  In this chapter the
foundation of this subsystem is introduced so that you can see how it fits
into the larger context of the Java programming and execution environment.

This chapter also looks at the @code{try-with-resources} statement and
several more Java keywords:

@itemize
@item
@code{volatile}
@item
@code{instanceof}
@item
@code{native}
@item
@code{strictfp}
@item
@code{assert}
@end itemize

@c -----------------------------------------------------------------------------

@node I/O Basics
@section I/O Basics
@cindex I/O Basics
@cindex text-based console programs
@cindex console I/O

Most real applications of Java are not text-based, console programs.  Rather,
they are either graphically oriented programs that rely on one of Java's
graphical user interface (GUI) frameworks, such as Swing, the AWT, or JavaFX,
for user interaction, or they are Web applications.  Text-based console
programs do not constitute an important use for Java in the real world.
Java's support for console I/O is limited and somewhat awkword to use.
Text-based console I/O is just not that useful in real-world Java
programming.

Java does, however, provide strong, flexible support for I/O as it relates to
files and networks.  Java's I/O system is cohesive and consistent.  A general
overview of I/O is presented here.  A detailed description is found in
chapters describing the Java Library: @xref{java io Input Output} and
@xref{NIO}.  


@c .....................................

@node Streams
@subsection Streams
@cindex Streams
@cindex stream definition
@cindex Java I/O system
@cindex stream, input
@cindex stream, output
@cindex input stream
@cindex output stream
@cindex @file{java.io} package
@cindex package, @file{java.io}

Java programs perform I/O through streams.  A @dfn{stream} is an abstraction
that either produces or consumes information.  A stream is linked to a
physical device by the Java I/O system.  All streams behave in the same
manner, even if the actual physical device to which they are linked differ.
Thus, the same I/O classes and methods can be applied to different types of
devices.  This means that an input stream can abstract many different kinds
of input; from a disk file, a keyboard, or a network socket.  Likewise, an
output stream may refer to the console, a disk file, or a network
connection.  Java implements streams within class hierarchies defined in the
@file{java.io} package.

@c .....................................

@node Byte Streams Character Streams
@subsection Byte Streams and Character Streams
@cindex Byte Streams, definition
@cindex Character Streams, definition
@cindex Streams, Character
@cindex binary data, reading and writing
@cindex Unicode
@cindex internationalization, character streams

Java defines two types of streams:

@itemize
@item
byte streams
@item
character streams
@end itemize


@dfn{Byte streams} provide a convenient means for handling input and output
of bytes.  Byte streams are used when reading or writing binary data.
@dfn{Character streams} provide a convenient means for handling input  and
output of characters.  They use Unicode and therefore can be
internationalized.  In some cases, character streams are more efficient than
byte streams.

The original version of Java (Java 1.0) did not include character streams and
thus all I/O was byte-oriented.  Character streams were added by Java 1.1 and
certain byte-oriented classes and methods were deprecated.

At the lowest level, all I/O is still byte-oriented.  The character-based
streams simply provide a convenient and efficient means for handling
characters.  

@c _____________________________________

@node Byte Stream Class
@subsubsection The Byte Stream Class
@cindex Byte Stream Class
@cindex Stream Class, Byte

Byte streams are defined by using two class hierarchies.  At the top are two
abstract classes:

@itemize
@item
@file{InputStream}
@item
@file{OutputStream}
@end itemize

Each of these abstract classes has several concrete subclasses that handle
the differences among various devices, such as disk files, network
connnections, and memory buffers.  The byte stream classes in @file{java.io}
are shown in @ref{ByteStreamClasses}.

To use the stream classes, you must import @file{java.io}.

@float Table,ByteStreamClasses
@table @file
@item BufferedInputStream
@itemx BufferedOutputStream
Buffered input and output streams
@item ByteArrayInputStream
@itemx ByteArrayOutputStream
Input and Output streams that read from and write to a byte array
@item DataInputStream
@itemx DataOutputStream
Input and Output streams that contain methods for reading and writing the
Java standard data types
@item FileInputStream
@itemx FileOutputStream
Input and Output streams that read from and write to a file
@item FilterInputStream
@itemx FilterOutputStream
Implements @file{InputStream} and @file{OutputStream}
@item InputStream
@itemx OutputStream
Abstract classes that describe stream input and output
@item ObjectInputStream
@itemx ObjectOutputStream
Input and Output streams for objects
@item PipedInputStream
@itemx PipedOutputStream
Input and Output pipe
@item PrintStream
Output stream that contains @code{print()} and @code{println()}
@item PushbackInputStream
Input stream that allows bytes to be returned to the input stream
@item SequenceInputStream
Input stream that is a combination of two or more input streams that will be
read sequentially, one after the other
@end table
@caption{The Byte Stream Classes in @file{java.io}}
@end float

The abstract classes @file{InputStream} and @file{OutputStream} define
several key methods that the other stream classes implement.  Two of the most
important are:

@cindex @code{read()}, @file{InputStream} abstract class
@cindex @code{write()}, @file{OutputStream} abstract class

@itemize
@item
@code{read()}
@item
@code{write()}
@end itemize

@noindent which respectively read and write bytes of data.  Each has a form
that is abstract and must be overridden by derived stream classes.

@c _____________________________________

@node Character Stream Class
@subsubsection The Character Stream Class
@cindex Character Stream Class
@cindex Stream Class, Character
@cindex @file{Reader} abstract class
@cindex @file{Writer} abstract class
@cindex Unicode character streams
@cindex @file{java.io}
@cindex Unicode character streams
@cindex character streams, Unicode

Character streams are defined by using two class hierarchies.  At the top are
two abstract classes:

@itemize
@item
@file{Reader}
@item
@file{Writer}.
@end itemize

These abstract classes handle Unicode character streams.  Java has several
concrete subclasses of these.  The character stream classes in @file{java.io}
are shown in @ref{CharacterStreamClasses}.

@float Table,CharacterStreamClasses
@table @file
@item BufferedReader
@itemx BufferedWriter
Buffered input and output character streams
@item CharArrayReader
@itemx CharArrayWriter
Input and Output streams that read and write to and from a character array
@item FileReader
@itemx FileWriter
Input and Output streams that read from and write to a file
@item FilterReader
@itemx FilterWriter
Filtered read and writer
@item InputStreamReader
@itemx OutputStreamWriter
Input and Output streams that translate bytes to characters
@item LineNumberReader
Input stream that counts lines
@item PipedReader
@itemx PipedWriter
Input and Output pipes
@item PrintWriter
Output stream that contains @code{print()} and @code{println()}
@item PushbackReader
Input stream that allows characters to be return to the input stream
@item Reader
@itemx Writer
Abstract clases tha describe character stream input and output
@item StringReader
@itemx StringWriter
Input and output streams that read from and write to a string
@end table
@caption{The Character Stream I/O Classes in @file{java.io}}
@end float

The abstract classes @file{Reader} and @file{Writer} define several key
methods that the other stream classes implement.  Two of the most important
methods are:

@cindex @code{read()}, @file{Reader}
@cindex @code{write()}, @file{Writer}

@itemize
@item
@code{read()}
@item
@code{write()}
@end itemize

@noindent which read and write characters of data, respectively.  Each has a
form that is abstract and must be overridden by derived stream classes.

@c _____________________________________

@node Predefined Streams
@subsubsection The Predefined Streams
@cindex Predefined Streams
@cindex Streams, Predefined
@cindex @file{System} class
@cindex stream variables, predefined
@cindex @code{in}
@cindex @code{out}
@cindex @code{err}

The @file{java.lang} package defines a class called @file{System}, which
encapsulates several aspects of the run-time environment.  System contains
three predefined stream variables:

@enumerate
@item
@code{in} (standard input), an object of type @file{InputStream}
@item
@code{out} (standard output), an object of type @file{PrintStream}
@item
@code{err} (standard error), an object of type @file{PrintStream}
@end enumerate

@noindent These fields are declared as @code{public}, @code{static}, and
@code{final} within @file{System}.  This means that they can be used by any
other part of your program and without reference to a specific @file{System}
object.  While these are all byte streams, they can be wrapped within
character-based streams, if desired.


@c -----------------------------------------------------------------------------

@node Reading Console Input
@section Reading Console Input
@cindex Reading Console Input
@cindex console input, reading
@cindex internationalization, character streams
@cindex character-based stream
@cindex stream, character-based

For commercial applications, the preferred method of reading console input is
to use a character-oriented stream.  This makes your program easier to
internationalize and maintain.

@subheading @code{System.in} Wrapped in @file{BufferedReader}
@cindex @code{System.in}
@cindex @file{BufferedReader}
@cindex @file{Reader} abstract class
@cindex @file{InputStreamReader} concrete subclass
@cindex @file{InputStream}

Console input is accomplished by reading from @code{System.in}  To obtain a
character-based stream that is attached to the console, wrap @code{System.in}
in a @file{BufferedReader} object.  @file{BufferedReader} supports a buffered
input stream.  A commonly-used constructor is:

@display
BufferedReader(Reader @ii{inputReader})
@end display


@noindent Here, @ii{inputReader} is the stream that is linked to the instance
of @file{BufferedReader} that is being created.  @file{Reader} is the
abstract class.  One of its concrete subclasses is @file{InputStreamReader},
which converts bytes to characters.  To obtain a @file{InputStreamReader}
object that is linked to @code{System.in}, use the following constructor:

@display
InputStreamReader(InputStream @ii{inputStream})
@end display

Because @code{System.in} refers to an object of type @file{InputStream}, it
can be used for @ii{inputStream}.  Putting it all together, the following
line of code creates a @file{BufferedReader} that is connected to the
keyboard:

@example
BufferedReader br = new BufferedReader(
  new InputStreamReader(System.in));
@end example

@noindent After this statement executes, @code{br} is a character-based
  stream that is linked to the console through @code{System.in}.  


@c .....................................

@node Reading Characters
@subsection Reading Characters
@cindex characters, reading
@cindex reading characters
@cindex @code{read()}, from @file{BufferedReader}

To read a character from a @file{BufferedReader}, use @code{read()}.  The
version of @code{read()} that we will be using is

@display
int read() throws IOException
@end display

@noindent Each time that @code{read()} is called, it reads a character from
the input stream and returns it as an integer value. @footnote{Note that
@code{System.in} is line buffered by default; this means that no input is
actually passed to the program until the user presses @key{enter}.  This does
not make @code{file} particularly valuable for interactive console input.}
It returns -1 when an attempt is made to read at the end of the stream.  It
can throw an @code{IOException}.

@subsubheading Program Demonstrating Reading Characters from Console
@cindex @file{BRRead.java}

The following program demonstrates @code{read()} by reading characters from
the console until the user types a ``q''.  Any I/O exceptions that might be
generated are simply thrown out of @code{main()}.  In more sophisticated
applications, you can handle the exceptions explicitly.

@(BRRead.java@)=
@<Import java.io@>
class BRRead {
  public static void main(String[] args[]) throws IOException {
    @<BRRead BufferedReader Constructor@>
    @<BRRead Enter Characters@>
  }
}

@

@c _____________________________________

@node Import java.io
@subsubsection Import @file{java.io}
@cindex import @file{java.io}

@<Import java.io@>=
import java.io.*;

@

@c _____________________________________

@node BRRead BufferedReader Constructor Node
@subsubsection BRRead BufferedReader Constructor Section
@cindex BRRead BufferedReader Constructor

@<BRRead BufferedReader Constructor@>=
BufferedReader br = new BufferedReader(
  new InputStreamReader(System.in));
  
@

@c _____________________________________

@node BRRead Enter Characters Node
@subsubsection BRRead Enter Characters Section
@cindex BRRead Enter Characters

@<BRRead Enter Characters@>=
char c;
do {
  c = (char) br.read();
  System.out.println(c);
} while (c != 'q');

@


@c .....................................

@node Reading Strings
@subsection Reading Strings
@cindex strings, reading
@cindex reading strings

To read a string frmo the keyboard, use the version of @code{readLine()} that
is a member of the @file{BufferedReader} class.  Its general form is:

@display
String readLine() throws IOException
@end display

@noindent It returns a @code{String} object.

@subsubheading Program Demonstrating Reading a String from Console
@cindex @file{BRReadLines.java}

The following program demonstrates @file{BufferedReader} and the
@code{readLine()} method; the program reas and displays lines of text until
the word ``stop'' is entered.

@(BRReadLines.java@)=
@<Import java.io@>

class BRReadLines {
  public static void main(String[] args) throws IOException {
    @<BRReadLines BufferedReader Constructor@>
    @<BRReadLines Enter Lines@>
  }
}

@

@c _____________________________________

@node BRReadLines BufferedReader Constructor
@subsubsection BRReadLines BufferedReader Constructor
@cindex BRReadLines BufferedReader Constructor

@<BRReadLines BufferedReader Constructor@>=
// create a BufferedReader using System.in
BufferedReader br = new BufferedReader(
  new InputStreamReader(System.in))

@

@c _____________________________________

@node BRReadLines Enter Lines
@subsubsection BRReadLines Enter Lines
@cindex BRReadLines Enter Lines

@<BRReadLines Enter Lines@>=
String str;

System.out.println("Enter lines of text.");
System.out.println("Enter 'stop' to quit.");

do {
  str = br.readLine();
  System.out.println(str);

} while (!str.equals("stop"));

@


@c -----------------------------------------------------------------------------

@node Writing Console Output
@section Writing Console Output


@c -----------------------------------------------------------------------------

@node PrintWriter Class
@section The PrintWriter Class


@c -----------------------------------------------------------------------------

@node Reading and Writing Files
@section Reading and Writing Files


@c -----------------------------------------------------------------------------

@node Automatically Closing Files
@section Automatically Closing Files


@c -----------------------------------------------------------------------------

@node transient and volatile Modifiers
@section The @code{transient} and @code{volative} Modifiers


@c -----------------------------------------------------------------------------

@node Using instanceof
@section Using @code{instanceof}


@c -----------------------------------------------------------------------------

@node strictfp
@section @code{strictfp}


@c -----------------------------------------------------------------------------

@node Native Methods
@section Native Methods


@c -----------------------------------------------------------------------------

@node Using assert
@section Using @code{assert}


@c -----------------------------------------------------------------------------

@node Static Import
@section Static Import


@c -----------------------------------------------------------------------------

@node Overloaded Constructors with this
@section Invoking Overloaded Constructors Through @code{this()}


@c -----------------------------------------------------------------------------

@node Compact API Profiles
@section Compact API Profiles






@c *****************************************************************************

@node Generics
@chapter Generics
@cindex Generics (chapter)
@cindex generics, introduction
@cindex J2SE 5.0
@cindex Collections Framework
@cindex collections, generics
@cindex type abstraction, generics
@cindex abstract over types

@dfn{Generics}, introduced in J2SE 5.0, allows a type or method to operate on
objects of various types while providing compile-time type safety.  It adds
compile-time type safety to the Collections Framework and eliminates the need
of casting.  In other words, generics allow you to abstract over types.

Through the use of generics, it is possible to create classes, interfaces,
and methods that will work in a type-safe manner with various kinds of data.
Many algorithms are logically the same no matter what type of data they are
being applied to.  For example, the mechanism that supports a stack is the
same whether that stack is storing items of type @command{Integer},
@command{String}, @command{Object}, or @command{Thread}.  With generics, you
can define an algorithm once, independently of any specific type of data, and
then apply that algorithm to a wide variety of data types without any
additional effort.

Perhaps the one feature of Java that has been most significantly affected by
generics is the @cite{Collections Framework}.  A @dfn{collection} is a group
of objects.  The Collections Framework defines several classes, such as lists
and maps, that manage collections.  The collection classes have always been
able to work with any type of object.  The benefit that generics adds is that
the collection classes can now be used with complete type safety.

This chapter describes the syntax, theory, and use of generics.  It also
shows how generics provide type safety for some previously difficult cases.


@c -----------------------------------------------------------------------------

@node Motivation
@section Motivation for Generics
@cindex generics, motivation

@subheading Code Fragment Without Generics

Here is a typical code fragment abstracting over types by using @code{Object}
and type casting.

@example
List myIntList = new LinkedList(); // 1
myIntList.add(new Integer(0)); // 2
Integer x = (Integer) myIntList.iterator().next(); // 3
@end example

The cast on line 3 is annoying, although essential.  The compiler can
guarantee only that an @code{Object} will be returned by the iterator.  This
therefore adds both clutter and the possibility of a run-time error.

@subheading Code Fragment with Generics

Generics allow a programmer to mark their intent to restrict a list to a
particular data type.  Here is a version of the same code that uses generics.

@example
List<Integer> myIntList = new LinkedList<Integer>(); // 1'
myIntList.add(new Integer(0)); // 2'
Integer x = myIntList.iterator().next(); // 3'
@end example
@cindex generic interface
@cindex type parameter
@cindex type correctness
@cindex compile-time type check
@cindex generics, motivation, readability and robustness

In line 1, the type declaration for the variable @code{myIntList} specifies
that it is to hold a @code{List} of @code{Integer}s: @samp{List<Integer>}.
@code{List} is a @dfn{generic interface} that takes a @dfn{type parameter}
(@code{Integer}).  The type parameter is also specified when creating the
@code{List} object (@samp{new LinkedList<Integer>()}).  Also, the cast on
line 3 is gone.

So has this just moved the clutter around, from a type cast to a type
parameter?  No, because this has given the compiler the ability to check the
type correctness of the program @emph{at compile-time}.  When we say that
@code{myIntList} is declared with type @code{List<Integer>}, this tells us
something about the variable @code{myIntList}, which holds true wherever and
whenever it is used, and the compiler will guarantee it.  In contrast, the
cast tells us something the programmer thinks is true at a single point in
the code.

The net effect, especially in large programs, is improved readability and
robustness.


@c -----------------------------------------------------------------------------

@node What are Generics
@section What Are Generics
@cindex generics, what they are
@cindex parameterized types
@cindex generic class, method
@cindex @command{Object} type
@cindex type safety, generics
@cindex casts, generics, automatic, implicit
@cindex generics, casts

The term @dfn{generics} means @i{parameterized types}.  Parameterized types
are important because they enable you to create classes, interfaces, and
methods in whicht the type of data upon which they operate is specified as a
parameter.  Using generics, it is possible to create a single class, for
example, that automatically works with different types of data.  A class,
interface, or method that operates on a parameterized type is called
@dfn{generic}, as in @i{generic class} or @i{generic method}.

Java has always given the ability to create generalized classes, interfaces,
and methods by operating through references of type @code{Object}.
Generics added the type safety that was lacking.  They also streamlined the
process, because it is no longer necessary to explicitly employ casts to
translate between @code{Object} and the type of data that is being operate
upon.  Wtih generics, all casts are automatic and implicit.

@node Simple Generics Example
@section A Simple Generics Example
@cindex generics example
@cindex example, generics
@cindex generic class

The following program defines two classes.  The first is the generic class
@code{Gen}, and the second is @code{GenDemo}, which uses @code{Gen}.

@(SimpleGenerics.java@)=
@<Class Gen@>
@<Class GenDemo@>
@

@c .....................................

@node Class Gen<T>
@subsection Class Gen<T>
@cindex generic class
@cindex parameter, generic class
@cindex type parameter, generic class
@cindex parameterized type

This is a simple generic class.  The class @code{Gen} is declared with a
parameter of @samp{<T>}:

@example
class Gen<T> @{
@end example

@samp{T} is the name of a @dfn{type parameter}.  This name is used as a
placeholder for the actual type that will be passed to @code{Gen} when an
object is created.  Thus, @samp{T} is used within @code{Gen} whenever the
type parameter is needed.

Notice that @samp{T} is contained within @samp{< >}.  This syntax can be
generalized.  Whenever a type parameter is being declared, it is specified
within angle brackets.

Because @code{Gen} uses a type parameter, @code{Gen} is a @emph{generic
class}, which is also called a @emph{parameterized type}.

@subsubheading Outline of Class Gen<T>

Class @code{Gen} contains four parts:

@itemize
@item
an instance variable declaration
@item
a constructor
@item
a method returning the instance variable
@item
a method describing the type of the instance variable
@end itemize

@<Class Gen@>=
class Gen<T> {
  @<Instance Variable ob of Type T@>
  @<Constructor taking parameter of Type T@>
  @<Method returning object of type T@>
  @<Method showing type of T@>
}
@

@subsubheading Implementation of Class Gen<T>

@samp{T} is used to declare an object called @code{ob}.  @samp{T} is a
placeholder for the actual type that will be specified when a @code{Gen}
object is created.  Thus, @code{ob} will be an object of the type passed to
@samp{T}.  

@<Instance Variable ob of Type T@>=
T ob;	// declare an object of type T

@

@subsubheading The Constructor
@anchor{generics-constructor}

Here is the constructor for @code{Gen}.  Notice that its parameter, @code{o},
is of type @samp{T}.  This means that the actual type of @code{o} is
determined by the type passed to @samp{T} when a @code{Gen} object is
created.  Because both the parameter @code{o} and the member variable
@code{ob} are of type @samp{T}, they will both be the same actual type when
a @code{Gen} object is created.

@<Constructor taking parameter of Type T@>=
// Pass the constructor a reference to
// an object of type T
Gen (T o) {
  ob = o;
}

@

@subsubheading Instance Methods @code{getob()} and @code{showType()}

The type parameter @samp{T} can also be used to specify the return type of a
method, as here in @code{getob()}.  Because @code{ob} is also of type
@samp{T}, its type is compatible wih the return type specified by
@code{getob()}.  

@<Method returning object of type T@>=
// Return ob
T getob() {
  return ob;
}

@

@cindex @code{Class}
@cindex @code{Object}
@cindex @code{getClass()}, defined in @code{Object}
@cindex @code{Class} object, from @code{getClass()}
@cindex @code{getName()}, defined in @code{Class}
@cindex class name, from @code{getName()}

The method @code{showType()} displays the type of @samp{T} by calling
@code{getName()} on the @code{Class} object return by the call to
@code{getClass()} on @code{ob}.   The @code{getClass()} method is defined
by @code{Object} and is thus a member of @emph{all} class types.  It returns
a @code{Class} object that corresponds to the type of the class of the
object on which it is called.  @code{Class} defines the @code{getName()}
method, which returns a string representation of the class name.

@<Method showing type of T@>=
// Show type of T
void showType() {
  System.out.println("Type of T is " + ob.getClass().getName();
}

@


@c .....................................

@node Class GenDemo
@subsection Class GenDemo
@cindex generic code, demonstrating an implementation
@cindex erasure
@cindex type erasure

The @code{GenDemo} class demonstrates the generic @code{Gen} class.

But first, take note: The Java compiler does not actually create different
versions of @code{Gen}, or of any other generic class.  The compiler removes
all generic type information, substituting the necessary casts, to make your
code @strong{behave as if} a specific version of @code{Gen} were created.
There is really only one version of @code{Gen} that actually exists.

The process of removing generic type information is called @dfn{type
erasure}.  

@code{GenDemo} first creates a version of @code{Gen} for integers and calls
the methods defined in @code{Gen} on it.  It then does the same for a String
object.

@<Class GenDemo@>=
// Demonstrate the generic class
class GenDemo {
  public static void main(String args[]) {
    @<Create a Gen object for Integers@>
    @<Create a Gen object for Strings@>
  }
}

@

@c _____________________________________

@node GenDemo as Integer
@subsubsection Implementation of Class GenDemo with Type Integer
@cindex generic reference, creating
@cindex type argument, passed to type parameter

@<Create a Gen object for Integers@>=
@<Integer Type Parameter@>
@<Reference to Integer Instance@>
@<Show Type@>
@<Get Value@>
@

@subsubheading Integer Type Declaration
@cindex generic reference to Integer

A reference to an Integer is declared in @code{iOb}.  Here, the type
@samp{Integer} is specified within the angle brackets after @code{Gen}.
@samp{Integer} is a @dfn{type argument} that is passed to @code{Gen}'s type
parameter, @samp{T}.  This effectively creates a version of @code{Gen} in
which all references to @samp{T} are translated into references to
@samp{Integer}.  Thus, @code{ob} is of type @samp{Integer}, and the return
type of @code{getob()} is of type @samp{Integer}.

@<Integer Type Parameter@>=
Gen<Integer> iOb;

@

@subsubheading Reference Assignment
@cindex generic reference assignment to Integer
@cindex generic type checking
@cindex generics, compile-time error, mismatched types
@cindex generics, type safety benefit
@cindex autoboxing in generic reference

The next line assigns to @code{iOb} a reference to an instance of an
@samp{Integer} version of the @code{Gen} class.  When the @code{Gen}
constructor is called, the type argument @samp{Integer} is also specified.
This is because the type of the object (in this case @code{iOb} to which the
reference is being assigned is of type @code{Gen<Integer>}.  Thus, the
reference returned by @command{new} must also be of type
@code{Gen<Integer>}.  If it isn't, a compile-time error will result.  This
type checking is one of the main benefits of generics because it ensures type
safety.  

Notice the use of autoboxing to encapsulate the value 88 within an Integer
object.

@<Reference to Integer Instance@>=
iOb = new Gen<Integer>(88);

@

The automatic autoboxing could have been written explicitly, like so:
@example
iOb = new Gen<Integer>(Integer.valueOf(88));
@end example
@noindent but there would be no value to doing it that way.

@subsubheading Showing the Reference's Type

The program then uses @code{Gen}'s instance method to show the type of
@code{ob}, which is an @samp{Integer} in this case.

@<Show Type@>=
iOb.showType();

@

@subsubheading Showing the Reference's Value

The program now obtains the value of @code{ob} by assiging @code{ob} to an
@samp{int} variable.  The return type of @code{getob()} is @samp{Integer},
which unboxes into @samp{int} when assigned to an @samp{int} variable
(@code{v}).  There is no need to cast the return type of @code{getob()} to
@samp{Integer}.  

@<Get Value@>=
int v = iOb.getob();
System.out.println("value: " + v);
System.out.println();

@

@c _____________________________________

@node GenDemo as String
@subsubsection Implementation of Class GenDemo with Type String

@<Create a Gen object for Strings@>=
// Create a Gen object for Strings.
Gen<String> strOb = new Gen<String>("Generics Test");

// Show the type of data used by strOb
strOb.showType();

// Get the value of strOb.  Again, notice
// that no cast is needed.
String str = strOb.getob();
System.out.println("value: " + str);

@


@c -----------------------------------------------------------------------------

@node Notes about Generics
@section Notes About Generics

@c .....................................

@node Reference Types
@subsection Generics Work Only with Reference Types
@cindex generics, only reference types
@cindex generic type argument, reference type
@cindex type wrappers, generics
@cindex auto-boxing, generics
@cindex auto-unboxing, generics

When declaring an instance of a generic type, the type argument passed to the
type parameter must be a reference type.  It cannot be a primitive type, such
as @samp{int} or @samp{char}.

You can use the type wrappers to encapsulate a primitive type.  Java's
autoboxing and auto-unboxing mechanism makes the use of the type wrapper
transparent.  

@c .....................................

@node Type Arguments
@subsection Generic Types Differ Based on their Type Arguments
@cindex generic types differ, type arguments

A reference of one specific version of a generic type is not type-compatible
with another version of the same generic type.  In other words, the following
line of code is an error and will not compile:

@example
iOb = strOb; // Gen<Integer> != Gen<String>
@end example

These are references to different types because their type arguments differ.

@c .....................................

@node Subtyping
@subsection Generics and Subtyping
@cindex generics, subtyping

Is the following legal?

@example
List<String> ls = new ArrayList<String>(); // 1
List<Object> lo = ls; // 2
@end example

Line 1 is legal.  What about line 2?  This boils down to the question: ``is a
List of String a List of Object.''  Most people instinctively answer,
``Sure!''

Now look at these lines:

@example
lo.add(new Object()); // 3
String s = ls.get(0); // 4: Attempts to assign an Object to a String!
@end example

Here we've aliased @code{ls} and @code{lo}. Accessing @code{ls}, a list of
@code{String}, through the alias @code{lo}, we can insert arbitrary objects
into it. As a result @code{ls} does not hold just @code{Strings} anymore, and
when we try and get something out of it, we get a rude surprise.

The Java compiler will prevent this from happening of course. Line 2 will
cause a compile time error.

The take-away is that, if @code{Foo} is a subtype (subclass or subinterface)
of @code{Bar}, and @code{G} is some generic type declaration, it is not the
case that @code{G<Foo>} is a subtype of @code{G<Bar>}.

@c .....................................

@node Type Safety
@subsection How Generics Improve Type Safety
@cindex generics improve type safety
@cindex generics ensure type safety
@cindex generics eliminate casts
@cindex casts, eliminated in generics

Generics automatically ensure the type safety of all operations involving a
generic class, such as @code{Gen}.  They eliminate the need for the coder to
enter cases and to type-check code by hand.


@c -----------------------------------------------------------------------------

@node Two Type Parameters
@section A Generic Class with Two Type Parameters
@cindex generic class, two type parameters

You can declare more than one type parameter in a generic type.  To specify
two or more type parameters, use a comma-separated list.  When an object is
created, the same number of type arguments must be passed as there are type
parameters.  The type arguments can be the same or different.

@c .....................................

@node Two Types Example Code
@subsection Example of Code with Two Type Parameters

@(TwoTypeParameters.java@)=
@<Class TwoGen@>
@<Class SimpGen@>
@

@c _____________________________________

@node Class TwoGen
@subsubsection Class TwoGen

@<Class TwoGen@>=
@<Class Declaration@>
  @<Two Instance Variables Declarations@>
  @<Constructor of Two Parameters@>
  @<Instance Methods Show and Get@>
@

@subsubheading Class Declaration
@cindex generics, two type parameters, declaration
@cindex generics, two type arguments

Notice how @code{TwoGen} is declared.  It specifies two type parameters:
@samp{T} and @samp{V}, separated by a comma.  Because it has two type
parameters, two type arguments must be passed to @code{TwoGen} when an object
is created.

@<Class Declaration@>=
class TwoGen<T, V> {
@

@subsubheading Instance Variables Declarations

@<Two Instance Variables Declarations@>=
T ob1;
V ob2;

@

@subsubheading Constructor
@<Constructor of Two Parameters@>=
TwoGen(T o1, V 02) {
  ob1 = o1;
  ob2 = o2;
}

@

@subsubheading Instance Methods Show and Get
@<Instance Methods Show and Get@>=
void showTypes() {
  System.out.println("Type of T is " + ob1.getClass().getName());
  System.out.println("Type of V is " + ob2.getClass().getName());
}

T getob1() {
  return ob1;
}

V getob2() {
  return ob2;
}

@

@c _____________________________________

@node Class SimpGen
@subsubsection Class SimpGen

Two type arguments must be supplied to the constructor.  In this case, the
two type parameters are @samp{Integer} and @samp{String}.

@<Class SimpGen@>=
class SimpGen {
  public static void main(String args[]) {
    TwoGen<Integer, String> tgObj =
      new TwoGen<Integer, String>(88, "Generics");

    // Show the types
    tgObj.showTypes();

    // Obtain and show values
    int v = tgObj.getob1();
    System.out.println("value: " + v);

    String str = thObj.getob2();
    System.out.println("value: " + str);
  }
}
@


@c -----------------------------------------------------------------------------

@node Generic Class General Form
@section The General Form of a Generic Class
@cindex generic class, general form

The generics syntax shown above can be generalized.  Here is the syntax for
declaring a generic class:

@float GeneralForm,GenericClass
@display
class @ii{class-name}<@ii{type-param-list}> @{ @dots{}
@end display

Here is the full syntax for declaring a reference to a generic class and
instance creation:

@display
@ii{class-name}<@ii{type-arg-list}> @ii{var-name} =
  new @ii{class-name}<@ii{type-arg-list}>(@ii{cons-arg-list});
@end display
@caption{General Form for Declaring and Creating a Reference to a Generic
Class}
@shortcaption{General Form Generic Class}
@end float


@c -----------------------------------------------------------------------------

@node Bounded Types
@section Bounded Types
@cindex generics, bounded types
@cindex bounded types
@cindex upper bound
@cindex @command{extends} clause

Sometimes it can be useful to limit the types that can be passed to a type
parameter.  Java provides @dfn{bounded types}.  When specifying a type
parameter, you can create an upper bound that declares the superclass from
which all type arguments must be derived.  This is accomplished through the
use of an @command{extends} clause when specifying the type parameter:

@display
 <@ii{T} extends @ii{superclass}>
@end display

This specifies that @ii{T} can only be replaced by @ii{superclass} or
subclasses of @ii{superclass}.  Thus, @ii{superclass} defines an inclusive,
upper limit.

@subheading Interface Type as a Bound
@cindex generics, interface as bound
@cindex interface as bound, generics

In addition to using a class type as a bound, you can also use an interface
type.  In fact, youi can specify multiple interfaces as bounds.  Furthermore,
a bound can include both a class type and one or more interfaces.  In this
case, the class type must be specified first.  When a bound includes an
interface type, only type arguments that implement that interface are legal.

When specifying a bound that has a class and an interface, or multiple
interfaces, use the @kbd{&} operator to connnect them.

@example
class Gen<T extends MyClass & MyInterface> @{ @dots{}
@end example

Any type argument passed to @samp{T} must be a subclass of @code{MyClass} and
implement @code{MyInterface}.


@c -----------------------------------------------------------------------------

@node Wildcard Arguments
@section Using Wildcard Arguments
@cindex generics, wildcard arguments
@cindex wildcard arguments, generics

@c .....................................

@node Wildcard Motivation
@subsection Wildcard Motivation
@cindex wildcards, motivation

Consider the problem of writing a routine that prints out all the elements in
a collection. Here's how you might write it in an older version of the
language (i.e., a pre-5.0 release):

@example
void printCollection(Collection c) @{
    Iterator i = c.iterator();
    for (k = 0; k < c.size(); k++) @{
        System.out.println(i.next());
    @}
@}
@end example

And here is a naive attempt at writing it using generics (and the new
@kbd{for loop} syntax):

@example
    for (Object e : c) @{
        System.out.println(e);
    @}
@}
@end example

The problem is that this new version is much less useful than the old
one. Whereas the old code could be called with any kind of collection as a
parameter, the new code only takes @code{Collection<Object>}, which, as we've
just demonstrated, is @emph{not} a supertype of all kinds of collections!

So what is the supertype of all kinds of collections? It's written
@kbd{Collection<?>} (pronounced @dfn{collection of unknown}), that is, a
collection whose element type matches anything. It's called a @dfn{wildcard
type}.  We can write:

@example
void printCollection(Collection<?> c) @{
    for (Object e : c) @{
        System.out.println(e);
    @}
@}
@end example

and now, we can call it with any type of collection.  Notice that inside
@code{printCollection()}, we can still read elements from @code{c} and give
them type @code{Object}. This is always safe, since whatever the actual type
of the collection, it does contain objects. It isn't safe to add arbitrary
objects to it however:

@example
Collection<?> c = new ArrayList<String>();
c.add(new Object()); // Compile time error
@end example

Since we don't know what the element type of @code{c} stands for, we cannot
add objects to it. The @code{add()} method takes arguments of type @code{E},
the element type of the collection. When the actual type parameter is
@code{?}, it stands for some unknown type. Any parameter we pass to
@code{add} would have to be a subtype of this unknown type. Since we don't
know what type that is, we cannot pass anything in. The sole exception is
@code{null}, which is a member of every type.

On the other hand, given a @code{List<?>}, we can call @code{get()} and make
use of the result. The result type is an unknown type, but we always know
that it is an object. It is therefore safe to assign the result of
@code{get()} to a variable of type @code{Object} or pass it as a parameter
where the type @code{Object} is expected.

@c .....................................

@node Wildcard Syntax
@subsection Wildcard Syntax
@cindex wildcard syntax

Sometimes type safety can get in the way of perfectly acceptable constructs.
In such cases, there is a @dfn{wildcard} argument that can be used.  The
wildcard argument is specified by the @kbd{?}, and it represents an unknown
type.  It would be used in place of a type parameter, for example:

@example
boolean sameAvg(Stats<?> ob) @{
  if(average() == ob.average())
    return true;

  return false;
@}
@end example

Here, @samp{Stats<?>} matches any @code{Stats} object (@code{Integer},
@code{Double}), allowing any two @code{Stats} objects to have their averages
compared.  The wildcard does not affect what type of @code{Stats} object can
be created.  That is governed by the @command{extends} clause in the
@code{Stats} declaration.  The wildcard simply matches any @emph{valid}
@code{Stats} object.

@c .....................................

@node Bounded Wildcards
@subsection Bounded Wildcards
@cindex wildcards, bounded
@cindex bounded wildcards

Wildcard arguments can be bounded in much the same way that a type parameter
can be bounded (the @dfn{bounded wildcard argument}.  A bounded wildcard is
especially important when you are creating a generic type that will operate
on a class hierarchy.

A bounded wildcard specifies either an upper bound or a lower bound for the
type argument.  This enables you to restrict the types of objects upon which
a method will operate.

@c _____________________________________

@subsubheading Upper Bounded Wildcard
@cindex bounded wildcards, upper bound
@cindex upper bounded wildcard

The most common bounded wildcard is the upper bound, which is created using
an @command{extends} clause.In general, to establish an upper bound for a
wildcard, use the following type of wildcard expression:
@cindex bounded wildcards, upper bound
@cindex upper bound wildcard argument

@float GeneralForm,UpperBoundedWildcard
@display
<? extends @ii{superclass}>
@end display
@caption{General Form of Upper Bounded Wildcard Syntax}
@shortcaption{Upper Bounded Wildcard}
@end float

where @ii{superclass} is the name of the class that serves as the upper
bound.  This is an inclusive clause.

@c _____________________________________

@subsubheading Lower Bounded Wildcard
@cindex bounded wildcards, lower bound
@cindex lower bounded wildcard

You can also specify a lower bound for a wildcard by adding a @command{super}
clause to a wildcard declaration.  Here is its general form:

@float GeneralForm,LowerBoundedWildcard
@display
<? super @ii{subclass}>
@end display
@caption{General Form of Lower Bounded Wildcard Syntax}
@shortcaption{Lower Bounded Wildcard}
@end float

Only classes that are superclasses of @ii{subclass} are acceptable arguments


@c -----------------------------------------------------------------------------

@node Generic Methods
@section Creating a Generic Method
@cindex generic method, creating
@cindex creating generic method

It is possible to declare a generic method that uses one or more type
parameters of its own.  It is also possible to create a generic method that
is enclosed within a non-generic class.

@subheading Generalized Form

@float GeneralForm,GenericMethod
@display
< @ii{type-param-list} > @ii{ret-type} @ii{meth-name} ( @ii{param-list} ) @{ @dots{}
@end display
@caption{General Form for Declaring a Generic Method}
@shortcaption{Generic Method Declaration}
@end float

@c .....................................

@node Example of Generic Method
@subsection Example of Generic Method
@cindex generic method, example
@cindex example generic method

The following program declares a non-generic class called @code{GenMethDemo}
and a static @strong{generic method} within that class called @code{isIn()}.
The @code{isIn()} method determines if an object is a member of an array.  It
can be used with any type of object and array as long as the array contains
objects that are compatible with the type of the object being sought.

@(GenMethDemo.java@)=
class GenMethDemo {
  @<Static Method isIn@>
  @<GenMethDemo Main@>
}
@

@c _____________________________________

@node Method isIn
@subsubsection Method isIn()

The @strong{type parameters} are declared @emph{before} the return type of
the method.

@<Static Method isIn@>=
static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {

  for (int i = 0; i < y.length; i++)
    if (x.equals(y[i]) return true;

  return false;
}

@

The type @ii{T} is @strong{upper-bounded} by the @code{Comparable} interface,
which must be of the same type as @ii{T}.  Likewise, the second type, @ii{V},
is also @strong{upper-bounded} by @ii{T}.  Thus, @ii{V} must be either the
same type as @ii{T} or a subclass of @ii{T}.  This relationship enforces that
@code{isIn()} can be called only with arguments that are compatible with each
other.

@cindex generic method, static
@cindex static generic method
While @code{isIn()} is static in this case, generic methods can be either
static or non-static; there is no restriction in this regard.

@subsubheading Explicitly Including Type Arguments
@cindex generic methods, including type arguments

There is generally no need to specify type arguments when calling this method
from within the @code{main} routine.  This is because the type arguments are
automatically discerned, and the types of @ii{T} and @ii{V} are adjusted
accordingly.

Although type inference will be sufficient for most generic method calls, you
can explicitly specify the type argument if needed.  For example, here is how
the first call to @code{isIn()} looks when the type argumetns are specified:

@example
GenMethDemo.<Integer, Integer>isIn(2, nums)
@end example

@c _____________________________________

@node GenMethDemo Main
@subsubsection GenMethDemo Main

@<GenMethDemo Main@>=
public static void main(String args[]) {

  // call isIn() with Integer type
  Integer nums[] = { 1, 2, 3, 4, 5 };

  if ( isIn(2, nums) )
    System.out.println("2 is in nums");

  if ( @isIn(7, nums))
    System.out.println("7 is not in nums");

  System.out.println();

  // call isIn() with String type
  String strs[] = { "one", "two", "three", "four", "five" };

  if ( isIn("two", strs))
    System.out.println("two is in strs");

  if ( !isIn("seven", strs))
    System.out.println("seven is not in strs");

  // call isIn() with mixed types
  // WILL NOT COMPILE! TYPES MUST BE COMPATIBLE
  // if ( isIn("two", nums))
  //    System.out.println("two is in nums");
}

@


@c -----------------------------------------------------------------------------

@node Generic Constructors
@section Generic Constructors
@cindex generics, generic constructors
@cindex generic constructors

It is possible for constructors to be generic, even if their class is not
(@pxref{generics-constructor}). The syntax is the same (type parameters come
first).

@display
< @ii{type-param-list}> @ii{constructor-name} ( @ii{param-list} ) @{ @dots{}
@end display




@c ****************************************************************************

@node Enumerations
@chapter Enumerations
@cindex Enumerations
@cindex JDK 5
@cindex @command{final}, traditional enums
@cindex enumeration object
@cindex data type, enumeration
@cindex enumeration capabilities

Enumerations were added by JDK 5.  In earlier versions of Java, enumerations
were implemented using @command{final} variables.

An @dfn{enumeration} is a list of named constants that define a new data type
and its legal values.  In other words, an enumeration defines a class type.
An @dfn{enumeration object} can only hold values that were declared in the
list.  Other values are not allowed.  An enumeration allows the programmer to
define a set of values that a data type can legally have.

By making enumerations classes, the capabilities of the enumeration are
greatly expanded.  An enumeration can have:

@itemize
@item
constructors
@item
methods
@item
instance variables
@end itemize

@node Enumeration Basics
@section Enumeration Basics
@cindex Enumeration, basics
@cindex keyword, @code{enum}

An enumeration is created using the @code{enum} keyword.

@example
enum Apple @{
     Jonathon, GoldenDel, RedDel, Winesap, Cortland
@}
@end example

@subheading enumeration constants

@cindex enumeration constants
@cindex self-typed constants
The enum constants @samp{Jonathon}, @samp{GoldenDel}, etc. are called
@dfn{enumeration constants}.  The enumeration constants are declared as
@samp{public static final} members of the enum.  Their type is the type of
the enumeration in which they are declared.  These constants are called
@dfn{self-typed}, in which ``self'' refers to the enclosing enumeration.  

@subheading enumeration objects
@cindex enumeration variable
@cindex variable, enum type
@cindex enum variable, declare

You can create a variable of an enumeration type.  You do not
instantiate an @code{enum} using @command{new}.  Rather, you declare
an @code{enum} variable like you do for primitive types: @samp{Apple
ap}.  Now, the variable @code{ap} can only hold values of type
@samp{Apple}.

@example
Apple ap;
ap = Apple.RedDel;
@end example

The @code{enum} type (i.e., @code{Apple}) must be part of the expression.

@subheading Comparing for Equality; Switch
@cindex enumeration comparison
@cindex equality, enum types
@cindex @code{==}
@cindex @command{switch} statement, enum types

Two enumeration constants can be compared for equality using the @code{==}
relational operator.  Furthermore, an enumneration value can be used to
control a @command{switch} statement.  The @code{enum} prefix (type) is not
required for @command{switch}.

@example
switch(ap) @{
  case Jonathon: @dots{}
  case Winesap: @dots{}
@}
@end example

@subheading Printing Enum Types
@cindex enums, printing

When an enumeration object is printed, its name is output (without the
@code{enum} type): @samp{System.out.println(ap)} would produce
@samp{RedDel}.

@node Enum Methods
@section Enum Methods @command{values()} and @command{valueOf()}
@cindex enumeration methods
@cindex methods, enumeration
@cindex enum @command{values()}
@cindex enum @command{valueOf()}

All enumerations inherit two methods:

@deftypemethod Enum {public static @ii{enum-type}[]} values ()
The @command{values()} method returns an array that contains a list of the
enumeration constants.
@end deftypemethod

@deftypemethod Enum {public static @ii{enum-type}} valueOf (String @var{str})
The @command{valueOf()} method returns the enumeration constant whose value
corresponds to the string passed in @var{str}.
@end deftypemethod

@subheading Examples using @command{values()} and @command{valueOf()} Methods

@noindent
@samp{Apple allapples[] = Apple.values();} is an example of using the
@command{values()} method to populate an array with enumeration constants.

@example
for(Apple a : Apple.values()) @{
  System.out.println(a);
@}
@end example

@noindent
is an example of iterating directly on the @command{values()} method.

@example
Apple ap;
ap = Apple.valueOf("Winesap");
System.out.println("ap contains " + ap);
@end example

@noindent
is an example of using the @command{valueOf()} method to obtain the
enumeration constant corresponding to the value of a string.

@node Enumerations as Class Types
@section Java Enumerations are Class Types
@cindex enumerations as class types
@cindex enumeration constructor
@cindex enumeration instance variables
@cindex enumeration methods
@cindex enumeration constants

A Java enumeration is a class type.  That is, @code{enum} defines a class,
which has much the same capabilities as other classes.  An enumeration can be
given constructors, instance variables, and methods.  It can even implement
interfaces.  Each enumeration constant is an object of its enumeration type.
When an enumeration is given a constructor, the constructor is called when
each enumeration constant is created.  Also, each enumeration constant has
its own copy of any instance variables defined by the enumeration.

@example
enum Apple @{
  Jonathon(10), GoldenDel(9), RedDel(12), Winesap(15), Cortland(8);
  private int price;
  Apple(int p) @{ price = p; @}
  int getPrice() @{ return price; @}
@}

class EnumDemo @{
  public static void main (String[] args) @{
    Apple ap;
  @}
@}
@end example

In this example, the enumeration @samp{Apple} is given an instance variable
@code{price}, a constructor, and an instance method @samp{getPrice()}.  When
the variable @samp{ap} is declared in @samp{main()}, the constructor for
@samp{Apple} is called once for each constant that is specified.  The
arguments to the constructor are placed in parentheses after the name of each
constant.  Thereafter, each enumeration constant has its own copy of
@samp{price}, which can be obtained by calling the instance method
@samp{getPrice()}.  In addition, there can be multiple overloaded
constructors just as for any other class.

@subheading Restrictions on Enums
@cindex enumeration restrictions

@itemize
@item
An enumeration cannot inherit another class.
@item
An @code{enum} cannot be a superclass (@code{enum} cannot be extended).
@end itemize

The key is to remember that each enumeration constant is an object of the
class in which it is defined.

@node Inherit Enum
@section Enumerations Inherit @code{Enum}
@cindex enumerations inherit @code{Enum}

All enumerations automatically inherit from one superclass:
@code{java.lang.Enum}.  This class defines several methods  that are
available for use by all enumerations.

@subheading @code{ordinal()} and @code{compareTo()}

@deftypemethod Enum {final int} ordinal ()
The @code{ordinal()} method returns a value that indicates an enumeration
constant's position in the list of constants, called its @dfn{ordinal
value}.  In other words, calling @code{ordinal()} returns the ordinal value
of the invoking constant (zero indexed).
@end deftypemethod

@deftypemethod Enum {final int} compareTo (@ii{enum-type} @var{e})
The ordinal values of two constants can be compared using the
@code{compareTo()} method.  Both the invoking constant and @var{e} must be of
the same enumeration @ii{enum-type}.  This method returns a negative value, a
zero, or a positive value depending on whether the invoking constant's
ordinal value is less than, equal to, or greater than the passed-in
enumeration constant's ordinal value.
@end deftypemethod

@subheading @code{equals()} and @code{==}

@deftypemethod Enum boolean equals (@ii{enum-type} @var{e})
@deftypemethodx Enum boolean == (@ii{enum-type} @var{e})
Compare for equality an invoking enum constant with a referenced enum
constant. 
@end deftypemethod


An invoking enum constant can compare for equality itself with any
other object by using @code{equals()} or, equivalently, @code{==}, which
overrides the @code{equals()} method defined in @code{Object}.
@code{equals()} will return true only if both objects refer to the same
constant within the same enumeration.  (In other words, @code{equals} does
not just compare ordinal values in general.)





@c *****************************************************************************

@part The Java Standard Library

@node Strings
@chapter String Handling
@cindex Strings
@cindex String Handling

@node java Lang
@chapter @file{java.lang}
@cindex @file{java.lang}

Classes and interfaces defined by @file{java.lang}, which is automatically
imported into all programs.  Contains classes and interfaces that are
fundamental to all of Java programming.  Beginning with JDK 9, all of
@file{java.lang} is part of the @file{java.base} module.

@subheading @file{java.lang} includes the following classes
@cindex classed in @file{java.lang}

@itemize
@item Boolean
@item Byte
@item Character
@itemize
@item Character.Subset
@item Character.UnicodeBlock
@end itemize
@item Class
@item ClassLoader
@item ClassValue
@item Compiler
@item Double
@item Enum
@item Float
@item InheritableThreadLocal
@item Integer
@item Long
@item Math
@item Module
@itemize
@item ModuleLayer
@item ModuleLayer.Controller
@end itemize
@item Number
@item Object
@item Package
@item Process
@itemize
@item ProcessBuilder
@item ProcessBuilder.Redirect
@end itemize
@item Runtime
@itemize
@item RuntimePermission
@item Runtime.Version
@end itemize
@item SecurityManager
@item Short
@item StackFramePermission
@item StackTraceElement
@item StackWalker
@item StrictMath
@item String
@itemize
@item StringBuffer
@item StringBuilder
@end itemize
@item System
@itemize
@item System.LoggerFinder
@end itemize
@item Thread
@itemize
@item ThreadGroup
@item ThreadLocal
@end itemize
@item Throwable
@item Void
@end itemize

@subheading @file{java.lang} includes the following interfaces
@cindex interfaces in @file{java.lang}

@itemize
@item Appendable
@item AutoClosable
@item CharSequence
@item Clonable
@item Comparable
@item Iterable
@item ProcessHandle
@itemize
@item ProcessHandle.Info
@end itemize
@item Readable
@item Runnable
@item StackWalker.StackFrame
@item System.Logger
@item Thread.UncaughtExceptionHandler
@end itemize

@node Primitive Wrappers
@section Primitive Type Wrappers
@cindex Primitive Wrappers
@cindex Wrappers, Primitives
@cindex type wrappers

Java uses primitive types for @samp{int}, @samp{char}, etc. for performance
reasons.  These primitives are not part of the object hierarchy; they are
passed by-value, not by reference.  Sometimes you may need to create an
object representation for a primitive type.  To store a primitive in a
class, you need to wrap the primitive type in a class.

Java provides classes that correspond to each of the primitive types.
These classes encapsulate or @dfn{wrap} the primitive types within a
class.  They are commonly referred to as @dfn{type wrappers}.

@node Number
@subsection Number

@node Double and Float
@subsection Double and Float

@node isInfiinite() and isNaN()
@subsection isInfinite() and isNaN()

@node Byte Short Integer Long
@subsection Byte, Short, Integer, Long

@node Numbers to from String
@subsection Converting Numbers to and from String

@node java util Collections
@chapter @file{java.util} --- Part 1: The Collections Framework
@cindex @file{java.util} Collections Framework

@node java util Utility Classes
@chapter @file{java.util} --- Part 2: Utility Classes
@cindex @file{java.util} Utility Classes

@node  java io Input Output
@chapter @file{java.io} --- Input/Output
@cindex @file{java.io}

@node NIO
@chapter NIO
@cindex NIO

@node Networking
@chapter Networking
@cindex Networking

@node Event Handling
@chapter Event Handling
@cindex Event Handling

@node AWT
@chapter AWT: Working with Windows, Graphics, and Text
@cindex AWT
@cindex Windows
@cindex Graphics
@cindex Text

@node AWT Controls
@chapter Using AWT Controls, Layout Managers, and Menus
@cindex AWT Controls
@cindex AWT Layout Managers, Menus

@node Images
@chapter Images
@cindex Images

@node Concurrency
@chapter The Concurrency Utilities
@cindex Concurrency Utilities

@node Streams API
@chapter The Stream API
@cindex Stream API
@cindex API, Stream

@node Regular Expressions
@chapter Regular Expressions and Other Packages
@cindex Regular Expressions

@node Swing
@chapter Introducinvg Swing
@cindex Swing

@node The Makefile
@appendix The Makefile
@cindex Makefile, The (appendix)

@(Makefile@)=
@<Makefile CONSTANTS@>
@<Makefile DEFAULTS@>
@<Makefile TANGLE WEAVE@>
@<Makefile CLEAN@>
@

@node Makefile Constants
@appendixsec Makefile Constants
@cindex Constants

@<Makefile CONSTANTS@>=
FILENAME := JavaSE9

@

@node Makefile Defaults
@appendixsec Makefile Default Targets
@cindex Makefile defaults

@<Makefile DEFAULTS@>=
.PHONY: all
all: tangle weave

@

@node Makefile Tangle Weave
@appendixsec Makefile Tangle Weave Targets
@cindex Makefile Tangle
@cindex Makefiel Weave

@<Makefile TANGLE WEAVE@>=
.PHONY: tangle weave jrtangle jrweave
tangle: jrtangle
weave: jrweave

jrtangle: $(FILENAME).twjr
	jrtangle $(FILENAME).twjr

jrweave: $(FILENAME).texi

$(FILENAME).texi: $(FILENAME).twjr
	jrweave $(FILENAME).twjr > $(FILENAME).texi
@

@node Makefile Clean
@appendixsec Makefile Clean Targets
@cindex Makefile Clean targets

@<Makefile CLEAN@>=
.PHONY: clean
clean:
	rm -f *~
	rm -f $(FILENAME).???

@

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@node List of Tables
@unnumbered List of Tables
@listoffloats Table

@node List of General Forms
@unnumbered List of General Forms
@listoffloats GeneralForm

@node Bibliography
@unnumbered Bibliography

@node Concept Index
@unnumbered Index

@printindex cp

@node Function Index
@unnumbered Function Index

@printindex fn

@bye

TODO:
